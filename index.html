<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Why Faster-Than-Light Travel Is Impossible</title>
<style>
  :root {
    --bg: #0a0e1a;
    --card: #111827;
    --border: #1e293b;
    --accent: #3b82f6;
    --accent2: #8b5cf6;
    --accent3: #06b6d4;
    --warn: #f59e0b;
    --danger: #ef4444;
    --text: #e2e8f0;
    --muted: #94a3b8;
    --dim: #475569;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    line-height: 1.6;
    overflow-x: hidden;
  }

  /* Starfield background */
  #starfield {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 0; pointer-events: none;
  }

  .content-wrap {
    position: relative; z-index: 1;
  }

  /* Hero */
  .hero {
    text-align: center;
    padding: 80px 20px 60px;
    background: linear-gradient(180deg, rgba(59,130,246,0.08) 0%, transparent 100%);
  }
  .hero h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 800;
    background: linear-gradient(135deg, #60a5fa, #a78bfa, #06b6d4);
    -webkit-background-clip: text; background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 16px;
    letter-spacing: -0.02em;
  }
  .hero p {
    color: var(--muted);
    font-size: 1.15rem;
    max-width: 680px;
    margin: 0 auto;
  }
  .hero .equation-hero {
    font-size: clamp(1.4rem, 3vw, 2.2rem);
    margin: 30px 0 10px;
    font-family: 'Georgia', serif;
    font-style: italic;
    color: var(--accent3);
    text-shadow: 0 0 30px rgba(6,182,212,0.3);
  }

  /* Sections */
  section {
    max-width: 1100px;
    margin: 0 auto;
    padding: 60px 20px;
  }
  section h2 {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 8px;
    color: #f1f5f9;
  }
  section h2 .num {
    color: var(--accent);
    font-size: 0.9em;
    margin-right: 6px;
  }
  section > .subtitle {
    color: var(--muted);
    margin-bottom: 30px;
    font-size: 1.05rem;
  }

  /* Cards */
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 30px;
    margin-bottom: 24px;
  }
  .card h3 {
    font-size: 1.15rem;
    margin-bottom: 12px;
    color: #f1f5f9;
  }

  /* Canvas containers */
  .canvas-wrap {
    background: #080c16;
    border-radius: 12px;
    overflow: hidden;
    margin: 16px 0;
    position: relative;
  }
  .canvas-wrap canvas {
    display: block;
    width: 100%;
    height: auto;
  }

  /* Sliders */
  .slider-group {
    margin: 20px 0;
  }
  .slider-group label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 0.95rem;
  }
  .slider-group label .val {
    color: var(--accent3);
    font-family: 'Courier New', monospace;
    font-weight: 700;
  }
  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--border);
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px; height: 20px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(59,130,246,0.5);
    transition: transform 0.15s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  /* Readouts */
  .readouts {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin: 20px 0;
  }
  .readout {
    background: rgba(59,130,246,0.06);
    border: 1px solid rgba(59,130,246,0.15);
    border-radius: 10px;
    padding: 14px 16px;
    text-align: center;
  }
  .readout .label {
    font-size: 0.78rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 4px;
  }
  .readout .value {
    font-size: 1.4rem;
    font-weight: 700;
    font-family: 'Courier New', monospace;
  }
  .readout .value.blue { color: var(--accent); }
  .readout .value.cyan { color: var(--accent3); }
  .readout .value.purple { color: var(--accent2); }
  .readout .value.yellow { color: var(--warn); }
  .readout .value.red { color: var(--danger); }

  /* Derivation */
  .derivation {
    background: rgba(139,92,246,0.06);
    border: 1px solid rgba(139,92,246,0.15);
    border-radius: 12px;
    padding: 24px;
    margin: 20px 0;
  }
  .derivation h4 {
    color: var(--accent2);
    margin-bottom: 12px;
    font-size: 1rem;
  }
  .deriv-step {
    font-family: 'Georgia', serif;
    font-style: italic;
    font-size: 1.15rem;
    color: var(--text);
    padding: 8px 0;
    border-bottom: 1px solid rgba(139,92,246,0.1);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .deriv-step:last-child { border-bottom: none; }
  .deriv-step .step-num {
    font-family: system-ui; font-style: normal;
    background: var(--accent2);
    color: #fff;
    width: 26px; height: 26px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.75rem; font-weight: 700;
    flex-shrink: 0;
  }
  .deriv-step .annotation {
    font-family: system-ui; font-style: normal;
    font-size: 0.82rem;
    color: var(--muted);
    margin-left: auto;
  }

  /* Examples grid */
  .examples-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 16px;
  }
  .example-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 24px;
    transition: transform 0.2s, border-color 0.2s;
  }
  .example-card:hover {
    transform: translateY(-3px);
    border-color: var(--accent);
  }
  .example-card .icon {
    font-size: 2rem;
    margin-bottom: 10px;
  }
  .example-card h4 {
    font-size: 1.05rem;
    margin-bottom: 8px;
    color: #f1f5f9;
  }
  .example-card p {
    font-size: 0.9rem;
    color: var(--muted);
    line-height: 1.5;
  }
  .example-card .stat {
    margin-top: 12px;
    padding: 8px 12px;
    background: rgba(59,130,246,0.08);
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
    color: var(--accent3);
  }

  /* Tabs */
  .tab-bar {
    display: flex;
    gap: 4px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .tab-btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 8px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s;
  }
  .tab-btn:hover { border-color: var(--accent); color: var(--text); }
  .tab-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* Footer */
  footer {
    text-align: center;
    padding: 40px 20px 60px;
    color: var(--dim);
    font-size: 0.9rem;
  }

  /* Divider */
  .section-divider {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 20px;
  }
  .section-divider hr {
    border: none;
    border-top: 1px solid var(--border);
  }

  /* Clock comparison layout */
  .clock-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
  @media (max-width: 700px) {
    .clock-row { grid-template-columns: 1fr; }
  }
  .clock-label {
    text-align: center;
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 6px;
    color: var(--muted);
  }

  /* Explanation text */
  .explain {
    color: var(--muted);
    font-size: 0.92rem;
    line-height: 1.7;
    margin: 12px 0;
  }
  .explain strong { color: var(--text); }

  /* Spacetime diagram region labels */
  .st-legend {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin: 14px 0 6px;
  }
  .st-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
    color: var(--muted);
  }
  .st-legend-item .swatch {
    width: 14px; height: 14px;
    border-radius: 3px;
    flex-shrink: 0;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
</style>
</head>
<body>

<canvas id="starfield"></canvas>

<div class="content-wrap">

<!-- Hero -->
<header class="hero">
  <h1>Why Faster-Than-Light Travel Is Impossible</h1>
  <p>An interactive exploration of Einstein's Special Relativity, time dilation, and the cosmic speed limit.</p>
  <div class="equation-hero">E = mc&sup2;</div>
</header>

<!-- Section 1: Twin Paradox -->
<section id="sec-twins">
  <h2><span class="num">01</span> The Twin Paradox</h2>
  <p class="subtitle">One twin stays home. The other rockets to a star and back. When they reunite, the traveler is younger. This is real.</p>

  <div class="card">
    <p class="explain">
      The <strong>twin paradox</strong> is the most famous consequence of time dilation. Twin A stays on Earth.
      Twin B travels to a distant star at high speed, turns around, and returns. Because Twin B's clock
      runs slower during the trip, <strong>Twin B ages less</strong>. This isn't symmetric &mdash; Twin B
      <em>accelerated</em> (changed direction), breaking the symmetry between the two frames.
    </p>

    <div class="slider-group">
      <label>Travel velocity <span class="val" id="twin-vel-label">0.50c</span></label>
      <input type="range" id="twin-vel" min="10" max="99" value="50" step="1">
    </div>
    <div class="slider-group">
      <label>Destination distance <span class="val" id="twin-dist-label">5.0 ly</span></label>
      <input type="range" id="twin-dist" min="1" max="50" value="10" step="1">
    </div>

    <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
      <button id="twin-play" class="tab-btn active" style="flex:1;min-width:100px;">Launch Trip</button>
      <button id="twin-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
      <button id="twin-speed" class="tab-btn" style="flex:1;min-width:100px;">Speed: 1&times;</button>
    </div>

    <div class="canvas-wrap">
      <canvas id="twin-canvas" width="800" height="750"></canvas>
    </div>

    <div class="readouts" style="margin-top:16px;">
      <div class="readout">
        <div class="label">Earth Twin Age</div>
        <div class="value yellow" id="tw-earth-age">30.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Traveler Twin Age</div>
        <div class="value cyan" id="tw-trav-age">30.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Earth Time Elapsed</div>
        <div class="value blue" id="tw-earth-time">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Traveler Time Elapsed</div>
        <div class="value purple" id="tw-trav-time">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Age Difference</div>
        <div class="value red" id="tw-diff">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Trip Phase</div>
        <div class="value" id="tw-phase" style="color:var(--muted);">Ready</div>
      </div>
    </div>

    <p class="explain" style="margin-top:16px;">
      <strong>Why isn't this a paradox?</strong> From the rocket's frame, doesn't Earth's clock run slow too?
      Yes &mdash; during each constant-velocity leg, each twin sees the other's clock running slow.
      But the traveler <em>turns around</em> (accelerates), which is <strong>not</strong> an inertial frame change.
      The turnaround breaks the symmetry. In the spacetime diagram below, the traveler's worldline
      has a <strong>kink</strong> &mdash; it's a longer path through spacetime, but a <em>shorter</em> proper time.
      The straight worldline (staying home) always accumulates the most proper time between two events.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 2: Photon Clocks -->
<section id="sec-clocks">
  <h2><span class="num">02</span> Photon Clock &amp; Time Dilation</h2>
  <p class="subtitle">A photon bouncing between two mirrors reveals how time itself slows for moving objects.</p>

  <div class="card">
    <p class="explain">
      A <strong>photon clock</strong> bounces a photon between two mirrors. At rest, the photon travels straight up and down.
      But when the clock moves, the photon must travel a longer diagonal path. Since light speed is constant (c),
      <strong>the moving clock ticks slower</strong> &mdash; this is time dilation.
    </p>

    <div class="slider-group">
      <label>Velocity <span class="val" id="clock-vel-label">0.00c</span></label>
      <input type="range" id="clock-vel" min="0" max="99" value="0" step="1">
    </div>

    <div class="clock-row">
      <div>
        <div class="clock-label">Stationary Clock</div>
        <div class="canvas-wrap">
          <canvas id="clock-rest" width="400" height="300"></canvas>
        </div>
      </div>
      <div>
        <div class="clock-label">Moving Clock (v = <span id="clock-v-display">0.00c</span>)</div>
        <div class="canvas-wrap">
          <canvas id="clock-moving" width="400" height="300"></canvas>
        </div>
      </div>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Velocity</div>
        <div class="value cyan" id="r-vel">0.00c</div>
      </div>
      <div class="readout">
        <div class="label">Lorentz Factor (γ)</div>
        <div class="value purple" id="r-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="r-dilation">1.000×</div>
      </div>
      <div class="readout">
        <div class="label">1 Earth Hour =</div>
        <div class="value blue" id="r-traveler">60.0 min</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 2b: Spacetime Diagram -->
<section id="sec-spacetime">
  <h2><span class="num">02b</span> Minkowski Spacetime Diagram</h2>
  <p class="subtitle">The geometry of the universe &mdash; why the speed of light divides spacetime into reachable and forever-unreachable regions.</p>

  <div class="card">
    <p class="explain">
      A <strong>spacetime diagram</strong> plots space (horizontal) against time (vertical, in units of ct).
      Light always travels at 45&deg; lines, forming the <strong>light cone</strong>. Any massive object's worldline
      must stay <em>inside</em> the cone (steeper than 45&deg;). To go faster than light would mean leaving
      the cone &mdash; entering a region where cause and effect break down.
    </p>

    <div class="slider-group">
      <label>Observer velocity <span class="val" id="st-vel-label">0.00c</span></label>
      <input type="range" id="st-vel" min="0" max="990" value="0" step="10">
    </div>

    <div class="canvas-wrap">
      <canvas id="spacetime-canvas" width="800" height="600"></canvas>
    </div>

    <div class="st-legend">
      <div class="st-legend-item"><span class="swatch" style="background:rgba(250,204,21,0.4)"></span> Future light cone (reachable)</div>
      <div class="st-legend-item"><span class="swatch" style="background:rgba(96,165,250,0.25)"></span> Spacelike region (FTL needed)</div>
      <div class="st-legend-item"><span class="swatch" style="background:#f59e0b"></span> Light (45&deg;, c)</div>
      <div class="st-legend-item"><span class="swatch" style="background:#06b6d4"></span> Object worldline</div>
      <div class="st-legend-item"><span class="swatch" style="background:#a855f7"></span> Simultaneity line (moving frame)</div>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Worldline angle</div>
        <div class="value cyan" id="st-angle">90.0&deg;</div>
      </div>
      <div class="readout">
        <div class="label">Light cone angle</div>
        <div class="value yellow" id="st-cone">45.0&deg;</div>
      </div>
      <div class="readout">
        <div class="label">Proper time ratio</div>
        <div class="value purple" id="st-proper">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Simultaneity tilt</div>
        <div class="value blue" id="st-simtilt">0.0&deg;</div>
      </div>
    </div>

    <p class="explain">
      As velocity increases, the worldline tilts toward the light cone and the <strong>simultaneity line</strong>
      (what the moving observer calls "now") tilts symmetrically. At v = c, both collapse onto the light cone.
      Beyond c, the worldline would enter the <strong>spacelike region</strong> &mdash; the object would arrive
      before it left in some reference frames, violating causality.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 3: Lorentz Factor -->
<section id="sec-lorentz">
  <h2><span class="num">03</span> The Lorentz Factor</h2>
  <p class="subtitle">The mathematical heart of special relativity &mdash; and why it blows up at light speed.</p>

  <div class="card">
    <div class="canvas-wrap">
      <canvas id="lorentz-graph" width="800" height="400"></canvas>
    </div>

    <div class="slider-group">
      <label>Explore velocity <span class="val" id="lorentz-vel-label">0.00c</span></label>
      <input type="range" id="lorentz-vel" min="0" max="999" value="0" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">v / c</div>
        <div class="value cyan" id="l-v">0.000</div>
      </div>
      <div class="readout">
        <div class="label">γ (Lorentz Factor)</div>
        <div class="value purple" id="l-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Length Contraction</div>
        <div class="value blue" id="l-length">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">Relativistic Mass</div>
        <div class="value yellow" id="l-mass">1.000× m₀</div>
      </div>
    </div>

    <div class="derivation">
      <h4>Derivation from the Photon Clock</h4>
      <div class="deriv-step">
        <span class="step-num">1</span>
        <span>Light path at rest: L = c&middot;t₀</span>
        <span class="annotation">straight up-down</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">2</span>
        <span>Light path moving: D = c&middot;t</span>
        <span class="annotation">diagonal path</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">3</span>
        <span>(c&middot;t)&sup2; = (v&middot;t)&sup2; + (c&middot;t₀)&sup2;</span>
        <span class="annotation">Pythagorean theorem</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">4</span>
        <span>c&sup2;t&sup2; &minus; v&sup2;t&sup2; = c&sup2;t₀&sup2;</span>
        <span class="annotation">rearrange</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">5</span>
        <span>t&sup2;(1 &minus; v&sup2;/c&sup2;) = t₀&sup2;</span>
        <span class="annotation">factor out t&sup2;</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">6</span>
        <span>t = t₀ / &radic;(1 &minus; v&sup2;/c&sup2;) = γ&middot;t₀</span>
        <span class="annotation">time dilation!</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">7</span>
        <span>γ = 1 / &radic;(1 &minus; v&sup2;/c&sup2;)</span>
        <span class="annotation">Lorentz factor</span>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 3b: Length Contraction -->
<section id="sec-contraction">
  <h2><span class="num">03b</span> Length Contraction</h2>
  <p class="subtitle">Moving objects physically shrink along their direction of motion &mdash; watch a starship compress as it accelerates toward c.</p>

  <div class="card">
    <p class="explain">
      Just as time dilates, <strong>lengths contract</strong>. An object moving at velocity v is measured by a stationary
      observer to be shorter by a factor of 1/γ: <strong>L = L₀ / γ</strong>.
      At 0.87c the ship is half its rest length. At 0.99c it's compressed to just 14%. The ship's occupants
      notice nothing different about their own ship &mdash; instead, they see the <em>universe</em> contracted ahead of them.
    </p>

    <div class="slider-group">
      <label>Velocity <span class="val" id="lc-vel-label">0.00c</span></label>
      <input type="range" id="lc-vel" min="0" max="990" value="0" step="5">
    </div>

    <div class="canvas-wrap">
      <canvas id="lc-canvas" width="800" height="480"></canvas>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Length (L₀)</div>
        <div class="value blue" id="lc-rest">100.0 m</div>
      </div>
      <div class="readout">
        <div class="label">Observed Length (L)</div>
        <div class="value cyan" id="lc-obs">100.0 m</div>
      </div>
      <div class="readout">
        <div class="label">Contraction</div>
        <div class="value yellow" id="lc-pct">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">γ (Lorentz)</div>
        <div class="value purple" id="lc-gamma">1.000</div>
      </div>
    </div>

    <div style="display:flex;gap:12px;margin-top:8px;flex-wrap:wrap;">
      <button id="lc-flyby" class="tab-btn active" style="flex:1;min-width:140px;">Launch Fly-By</button>
      <button id="lc-flyby-reset" class="tab-btn" style="flex:1;min-width:140px;">Reset</button>
    </div>

    <p class="explain" style="margin-top:16px;">
      The <strong>top view</strong> shows the ship at rest for reference. The <strong>bottom view</strong> shows how a
      stationary observer measures the same ship as it flies past. Press <em>Launch Fly-By</em> to see
      contracted ships streak past the observation platform at your chosen speed. The ruler and grid
      stay fixed &mdash; only the ship contracts.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 4: Energy -->
<section id="sec-energy">
  <h2><span class="num">04</span> The Infinite Energy Barrier</h2>
  <p class="subtitle">E = mc&sup2; is only the rest energy. The full picture shows why FTL requires infinite energy.</p>

  <div class="card">
    <div class="tab-bar">
      <button class="tab-btn active" data-tab="energy-ke">Kinetic Energy</button>
      <button class="tab-btn" data-tab="energy-total">Total Energy</button>
      <button class="tab-btn" data-tab="energy-momentum">Momentum</button>
    </div>

    <div id="energy-ke" class="tab-content active">
      <div class="canvas-wrap">
        <canvas id="ke-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain">
        Relativistic kinetic energy: <strong>KE = (γ - 1)mc&sup2;</strong>. As v approaches c, γ approaches infinity,
        so the energy needed grows without bound. No finite energy source can accelerate mass to light speed.
      </p>
    </div>

    <div id="energy-total" class="tab-content">
      <div class="canvas-wrap">
        <canvas id="total-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain">
        Total relativistic energy: <strong>E = γmc&sup2;</strong>. At rest (v=0), this reduces to E = mc&sup2;.
        The rest mass energy of a 1 kg object is <strong>9 × 10&sup1;&sup6; joules</strong> &mdash; equivalent to ~21 megatons of TNT.
      </p>
    </div>

    <div id="energy-momentum" class="tab-content">
      <div class="canvas-wrap">
        <canvas id="momentum-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain">
        Relativistic momentum: <strong>p = γmv</strong>. Unlike classical p = mv, this diverges as v &rarr; c.
        The energy-momentum relation: <strong>E&sup2; = (pc)&sup2; + (mc&sup2;)&sup2;</strong> unifies energy, momentum, and mass.
      </p>
    </div>

    <div class="slider-group">
      <label>Object velocity <span class="val" id="energy-vel-label">0.00c</span></label>
      <input type="range" id="energy-vel" min="0" max="999" value="0" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Energy (mc&sup2;)</div>
        <div class="value blue" id="e-rest">1.00</div>
      </div>
      <div class="readout">
        <div class="label">Kinetic Energy</div>
        <div class="value yellow" id="e-ke">0.00</div>
      </div>
      <div class="readout">
        <div class="label">Total Energy (γmc&sup2;)</div>
        <div class="value red" id="e-total">1.00</div>
      </div>
      <div class="readout">
        <div class="label">Momentum (γmv)</div>
        <div class="value purple" id="e-mom">0.00</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 5: Real-World Examples -->
<section id="sec-examples">
  <h2><span class="num">05</span> Real-World Evidence</h2>
  <p class="subtitle">Special relativity isn't just theory &mdash; we measure its effects every day.</p>

  <div class="examples-grid">
    <div class="example-card">
      <div class="icon">&#x1F6F0;</div>
      <h4>GPS Satellites</h4>
      <p>GPS satellites move at ~3.9 km/s. Without relativistic corrections, positioning would drift by ~11 km/day. Both special and general relativity corrections are applied.</p>
      <div class="stat">v = 0.0000130c | &Delta;t = 7 &mu;s/day (SR)</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x269B;</div>
      <h4>Muon Decay</h4>
      <p>Cosmic ray muons should decay in ~2.2&mu;s and travel only ~660m. But we detect them at sea level because time dilation at 0.998c extends their lifetime by ~15x.</p>
      <div class="stat">v = 0.998c | γ &asymp; 15.8 | range: ~10 km</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x1F500;</div>
      <h4>Particle Accelerators</h4>
      <p>At the LHC, protons reach 0.999999991c. Their relativistic mass is ~7,454 times rest mass. Each proton carries energy comparable to a flying mosquito &mdash; in a single subatomic particle.</p>
      <div class="stat">v = 0.999999991c | γ &asymp; 7,454</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x2B50;</div>
      <h4>Stellar Aberration</h4>
      <p>Stars appear slightly shifted due to Earth's orbital velocity (~30 km/s). This aberration angle matches relativistic predictions exactly, not Newtonian ones.</p>
      <div class="stat">v = 0.0001c | aberration &asymp; 20.5&quot;</div>
    </div>
  </div>

  <div class="card" style="margin-top: 24px;">
    <h3>Interactive: Muon Decay Simulation</h3>
    <p class="explain">Watch muons created at 15 km altitude travel toward Earth. At rest, they'd decay after ~660m. Time dilation lets them reach the surface.</p>
    <div class="canvas-wrap">
      <canvas id="muon-canvas" width="800" height="300"></canvas>
    </div>
    <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
      <button id="muon-start" class="tab-btn active" style="flex:1;min-width:120px;">Start Simulation</button>
      <button id="muon-reset" class="tab-btn" style="flex:1;min-width:120px;">Reset</button>
    </div>
    <div class="readouts" style="margin-top:16px;">
      <div class="readout">
        <div class="label">Classical Muons Surviving</div>
        <div class="value yellow" id="muon-classical">100%</div>
      </div>
      <div class="readout">
        <div class="label">Relativistic Muons Surviving</div>
        <div class="value cyan" id="muon-relativistic">100%</div>
      </div>
      <div class="readout">
        <div class="label">Altitude</div>
        <div class="value blue" id="muon-alt">15.0 km</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 6: Relativistic Mass & E=mc² -->
<section id="sec-emc2">
  <h2><span class="num">06</span> E = mc&sup2; and Mass-Energy Equivalence</h2>
  <p class="subtitle">Mass is frozen energy. Energy has inertia. This is why the speed limit exists.</p>

  <div class="card">
    <div class="canvas-wrap">
      <canvas id="emc2-graph" width="800" height="400"></canvas>
    </div>

    <div class="slider-group">
      <label>Mass (kg) <span class="val" id="mass-label">1.00 kg</span></label>
      <input type="range" id="mass-slider" min="1" max="100" value="1" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Energy</div>
        <div class="value cyan" id="emc2-rest">9.0 &times; 10&sup1;&sup6; J</div>
      </div>
      <div class="readout">
        <div class="label">Equivalent TNT</div>
        <div class="value yellow" id="emc2-tnt">21.5 MT</div>
      </div>
      <div class="readout">
        <div class="label">Could Power</div>
        <div class="value blue" id="emc2-power">A city for 2.9 years</div>
      </div>
    </div>

    <p class="explain" style="margin-top:16px;">
      <strong>Why does E = mc&sup2; create a speed limit?</strong> When you push an object, you add energy.
      That energy increases its inertia (resistance to further acceleration). The faster it goes,
      the more energy each additional m/s requires. Approaching c, the energy requirement
      diverges to infinity. The object's inertia becomes infinite before it can reach c.
      <br><br>
      Massless particles (photons) <em>must</em> travel at exactly c &mdash; they have no rest frame.
      Anything with mass is forever trapped below c.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 7: Speed comparison -->
<section id="sec-compare">
  <h2><span class="num">07</span> Putting It All Together</h2>
  <p class="subtitle">Adjust the velocity and watch all relativistic effects simultaneously.</p>

  <div class="card">
    <div class="slider-group">
      <label>Velocity <span class="val" id="master-vel-label">0.00c</span></label>
      <input type="range" id="master-vel" min="0" max="9999" value="0" step="1">
    </div>

    <div class="canvas-wrap">
      <canvas id="combined-graph" width="800" height="400"></canvas>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">γ (Lorentz)</div>
        <div class="value purple" id="c-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="c-time">1.000&times;</div>
      </div>
      <div class="readout">
        <div class="label">Length (% of rest)</div>
        <div class="value cyan" id="c-length">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">Energy (units mc&sup2;)</div>
        <div class="value red" id="c-energy">1.000</div>
      </div>
    </div>

    <p class="explain">
      The vertical dashed line marks your chosen velocity. Notice how <strong>all quantities diverge
      simultaneously</strong> as v &rarr; c. This isn't a coincidence &mdash; it's the geometry of spacetime itself.
      The speed of light isn't just a speed limit for light; it's woven into the fabric of the universe.
    </p>
  </div>
</section>

<footer>
  Built to illuminate the beauty of Einstein's Special Relativity
</footer>

</div><!-- /content-wrap -->

<script>
// ==================== UTILITIES ====================
const c = 299792458; // m/s
const gamma = (beta) => 1 / Math.sqrt(1 - beta * beta);
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp = (a, b, t) => a + (b - a) * t;

function fmt(n, d = 3) {
  if (n >= 1e18) return (n / 1e18).toFixed(1) + ' × 10¹⁸';
  if (n >= 1e16) return (n / 1e16).toFixed(1) + ' × 10¹⁶';
  if (n >= 1e12) return (n / 1e12).toFixed(1) + ' × 10¹²';
  if (n >= 1e9) return (n / 1e9).toFixed(1) + ' × 10⁹';
  if (n >= 1e6) return (n / 1e6).toFixed(1) + ' × 10⁶';
  if (n >= 1e4) return (n / 1e4).toFixed(1) + ' × 10⁴';
  if (n >= 100) return n.toFixed(1);
  if (n >= 10) return n.toFixed(2);
  return n.toFixed(d);
}

function setupCanvas(id) {
  const canvas = document.getElementById(id);
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = canvas.getAttribute('width') | 0;
  const h = canvas.getAttribute('height') | 0;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.maxWidth = '100%';
  canvas.style.height = 'auto';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { canvas, ctx, w, h };
}

// ==================== STARFIELD ====================
(function initStarfield() {
  const canvas = document.getElementById('starfield');
  const ctx = canvas.getContext('2d');
  let stars = [];
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    stars = Array.from({ length: 200 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      r: Math.random() * 1.5 + 0.3,
      a: Math.random() * 0.6 + 0.2,
      speed: Math.random() * 0.0005 + 0.0002,
      phase: Math.random() * Math.PI * 2
    }));
  }
  resize();
  window.addEventListener('resize', resize);
  function draw(t) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    stars.forEach(s => {
      const flicker = 0.5 + 0.5 * Math.sin(t * s.speed * 1000 + s.phase);
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,220,255,${s.a * flicker})`;
      ctx.fill();
    });
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

// ==================== PHOTON CLOCKS (smooth) ====================
(function initClocks() {
  const restC = setupCanvas('clock-rest');
  const moveC = setupCanvas('clock-moving');
  const slider = document.getElementById('clock-vel');
  let beta = 0;
  const mirrorGap = 180;
  const mirrorY1 = 50;
  const mirrorY2 = mirrorY1 + mirrorGap;
  const TRAIL_LEN = 18;

  // Trail buffers
  const restTrail = [];
  const moveTrail = [];

  // Mirror flash state (0-1, decays)
  let restFlash = 0, moveFlash = 0;
  let restLastDir = true, moveLastDir = true; // true = going down

  // Proper timestamps
  let prevTs = null;
  let accumTime = 0;

  function drawMirror(ctx, x, y, halfW, flash, color) {
    // Mirror body
    const grad = ctx.createLinearGradient(x - halfW, y - 3, x + halfW, y + 3);
    grad.addColorStop(0, '#1e293b');
    grad.addColorStop(0.5, '#334155');
    grad.addColorStop(1, '#1e293b');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(x - halfW, y - 3, halfW * 2, 6, 2);
    ctx.fill();
    // Reflective highlight
    ctx.strokeStyle = `rgba(148,163,184,${0.4 + flash * 0.6})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - halfW + 4, y);
    ctx.lineTo(x + halfW - 4, y);
    ctx.stroke();
    // Flash glow
    if (flash > 0.01) {
      const fg = ctx.createRadialGradient(x, y, 0, x, y, 40 * flash);
      fg.addColorStop(0, color.replace(')', `,${flash * 0.5})`).replace('rgb', 'rgba'));
      fg.addColorStop(1, 'transparent');
      ctx.fillStyle = fg;
      ctx.fillRect(x - 50, y - 50, 100, 100);
    }
  }

  function drawPhoton(ctx, x, y, color, trail, radius) {
    // Trail
    for (let i = 0; i < trail.length; i++) {
      const a = (i / trail.length) * 0.35;
      const r = (i / trail.length) * (radius || 4) * 0.8;
      ctx.beginPath();
      ctx.arc(trail[i].x, trail[i].y, r, 0, Math.PI * 2);
      ctx.fillStyle = color.replace(')', `,${a})`).replace('rgb', 'rgba');
      ctx.fill();
    }
    // Outer glow
    const g1 = ctx.createRadialGradient(x, y, 0, x, y, 18);
    g1.addColorStop(0, color.replace(')', ',0.4)').replace('rgb', 'rgba'));
    g1.addColorStop(0.5, color.replace(')', ',0.1)').replace('rgb', 'rgba'));
    g1.addColorStop(1, 'transparent');
    ctx.fillStyle = g1;
    ctx.fillRect(x - 20, y - 20, 40, 40);
    // Inner glow
    const g2 = ctx.createRadialGradient(x, y, 0, x, y, 8);
    g2.addColorStop(0, '#ffffff');
    g2.addColorStop(0.3, color);
    g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    // Core
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
  }

  function drawTicks(ctx, w, h, count, label, color) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, w / 2, h - 8);
    // Tick counter with color
    ctx.font = 'bold 18px Courier New';
    ctx.fillStyle = color;
    ctx.fillText(count, w / 2, h - 26);
    ctx.font = '10px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.fillText('ticks', w / 2 + 28, h - 24);
  }

  function drawPythagorean(ctx, topX, botX, alpha) {
    if (alpha < 0.02) return;
    const cx = (topX + botX) / 2;
    // Vertical leg (c·t₀)
    ctx.strokeStyle = `rgba(6,182,212,${alpha * 0.7})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.moveTo(cx, mirrorY1);
    ctx.lineTo(cx, mirrorY2);
    ctx.stroke();
    // Horizontal leg (v·t)
    ctx.strokeStyle = `rgba(245,158,11,${alpha * 0.7})`;
    ctx.beginPath();
    ctx.moveTo(cx, mirrorY2);
    ctx.lineTo(botX, mirrorY2);
    ctx.stroke();
    // Hypotenuse (c·t)
    ctx.strokeStyle = `rgba(168,85,247,${alpha * 0.9})`;
    ctx.setLineDash([]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(topX, mirrorY1);
    ctx.lineTo(botX, mirrorY2);
    ctx.stroke();
    ctx.setLineDash([]);
    // Labels
    ctx.font = 'italic 11px Georgia';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(6,182,212,${alpha})`;
    ctx.fillText('c·t₀', cx - 14, (mirrorY1 + mirrorY2) / 2 + 4);
    ctx.fillStyle = `rgba(245,158,11,${alpha})`;
    ctx.fillText('v·t', (cx + botX) / 2, mirrorY2 + 15);
    ctx.fillStyle = `rgba(168,85,247,${alpha})`;
    const hx = (topX + botX) / 2 + 14;
    const hy = (mirrorY1 + mirrorY2) / 2 - 6;
    ctx.fillText('c·t', hx, hy);
    // Right angle marker
    const sz = 8;
    ctx.strokeStyle = `rgba(100,116,139,${alpha * 0.6})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx + sz, mirrorY2);
    ctx.lineTo(cx + sz, mirrorY2 - sz);
    ctx.lineTo(cx, mirrorY2 - sz);
    ctx.stroke();
  }

  function animate(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50); // cap at 50ms to handle tab-switching
    prevTs = ts;
    accumTime += dt;

    const restPeriod = 1200;
    const g = beta > 0 ? gamma(beta) : 1;
    const movePeriod = restPeriod * g;

    const restTicks = Math.floor(accumTime / restPeriod);
    const moveTicks = Math.floor(accumTime / movePeriod);

    // --- Rest clock ---
    {
      const { ctx, w, h } = restC;
      ctx.clearRect(0, 0, w, h);
      const cx = w / 2;

      const phase = (accumTime % restPeriod) / restPeriod;
      const goingDown = phase < 0.5;
      const t = goingDown ? phase * 2 : (1 - phase) * 2;
      // Ease in-out for smoother bounce
      const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      const py = goingDown ? lerp(mirrorY1, mirrorY2, et) : lerp(mirrorY2, mirrorY1, et);

      // Flash on direction change
      if (goingDown !== restLastDir) {
        restFlash = 1;
        restLastDir = goingDown;
      }
      restFlash *= 0.9;

      // Vertical guide
      ctx.strokeStyle = 'rgba(71,85,105,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.beginPath();
      ctx.moveTo(cx, mirrorY1 + 6);
      ctx.lineTo(cx, mirrorY2 - 6);
      ctx.stroke();
      ctx.setLineDash([]);

      drawMirror(ctx, cx, mirrorY1, 35, goingDown ? 0 : restFlash, 'rgb(6,182,212)');
      drawMirror(ctx, cx, mirrorY2, 35, goingDown ? restFlash : 0, 'rgb(6,182,212)');

      // Update trail
      restTrail.push({ x: cx, y: py });
      if (restTrail.length > TRAIL_LEN) restTrail.shift();

      drawPhoton(ctx, cx, py, 'rgb(6,182,212)', restTrail);
      drawTicks(ctx, w, h, restTicks, 'Stationary Observer', '#06b6d4');
    }

    // --- Moving clock ---
    {
      const { ctx, w, h } = moveC;
      ctx.clearRect(0, 0, w, h);

      const phase = (accumTime % movePeriod) / movePeriod;
      const goingDown = phase < 0.5;
      const t = goingDown ? phase * 2 : (1 - phase) * 2;
      const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

      const drift = beta * 120;
      const cx = w / 2;
      const topX = cx - drift;
      const botX = cx + drift;
      const px = goingDown ? lerp(topX, botX, et) : lerp(botX, topX, et);
      const py = goingDown ? lerp(mirrorY1, mirrorY2, et) : lerp(mirrorY2, mirrorY1, et);

      if (goingDown !== moveLastDir) {
        moveFlash = 1;
        moveLastDir = goingDown;
      }
      moveFlash *= 0.9;

      // Pythagorean triangle (more visible at higher speeds)
      drawPythagorean(ctx, topX, botX, Math.min(beta * 2, 1));

      // Diagonal guide path
      ctx.strokeStyle = 'rgba(168,85,247,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.beginPath();
      ctx.moveTo(topX, mirrorY1);
      ctx.lineTo(botX, mirrorY2);
      ctx.moveTo(botX, mirrorY2);
      ctx.lineTo(topX, mirrorY1);
      ctx.stroke();
      ctx.setLineDash([]);

      drawMirror(ctx, topX, mirrorY1, 35, goingDown ? 0 : moveFlash, 'rgb(168,85,247)');
      drawMirror(ctx, botX, mirrorY2, 35, goingDown ? moveFlash : 0, 'rgb(168,85,247)');

      moveTrail.push({ x: px, y: py });
      if (moveTrail.length > TRAIL_LEN) moveTrail.shift();

      drawPhoton(ctx, px, py, 'rgb(168,85,247)', moveTrail);
      drawTicks(ctx, w, h, moveTicks, 'Moving Observer', '#a855f7');

      // Velocity arrow
      if (beta > 0.01) {
        const arrowY = mirrorY2 + 30;
        ctx.strokeStyle = 'rgba(245,158,11,0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx - 50, arrowY);
        ctx.lineTo(cx + 50, arrowY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + 50, arrowY);
        ctx.lineTo(cx + 42, arrowY - 4);
        ctx.moveTo(cx + 50, arrowY);
        ctx.lineTo(cx + 42, arrowY + 4);
        ctx.stroke();
        ctx.fillStyle = 'rgba(245,158,11,0.7)';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('v = ' + beta.toFixed(2) + 'c →', cx, arrowY - 8);
      }
    }

    requestAnimationFrame(animate);
  }

  slider.addEventListener('input', () => {
    beta = slider.value / 100;
    const g = beta > 0 ? gamma(beta) : 1;
    document.getElementById('clock-vel-label').textContent = beta.toFixed(2) + 'c';
    document.getElementById('clock-v-display').textContent = beta.toFixed(2) + 'c';
    document.getElementById('r-vel').textContent = beta.toFixed(2) + 'c';
    document.getElementById('r-gamma').textContent = fmt(g);
    document.getElementById('r-dilation').textContent = fmt(g) + '×';
    const travMinutes = 60 / g;
    document.getElementById('r-traveler').textContent = travMinutes.toFixed(1) + ' min';
  });

  requestAnimationFrame(animate);
})();

// ==================== SPACETIME DIAGRAM ====================
(function initSpacetime() {
  const { ctx, w, h } = setupCanvas('spacetime-canvas');
  const slider = document.getElementById('st-vel');
  let beta = 0;
  let animBeta = 0; // smoothly interpolated
  let animTime = 0;
  let prevTs = null;

  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;
    animTime += dt;

    // Smooth interpolation toward target beta
    animBeta += (beta - animBeta) * Math.min(1, dt * 0.008);

    ctx.clearRect(0, 0, w, h);
    const ox = w / 2;    // origin x
    const oy = h * 0.75; // origin y (lower part so more future visible)
    const scale = Math.min(w, h) * 0.33;

    // --- Background regions ---
    // Future light cone fill (timelike)
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(ox, oy - scale * 2.5);
    ctx.lineTo(ox + scale * 1.8, oy - scale * 1.8);
    ctx.closePath();
    ctx.fillStyle = 'rgba(250,204,21,0.06)';
    ctx.fill();

    // Past light cone fill
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.2, oy + scale * 1.2);
    ctx.lineTo(ox, oy + scale * 1.6);
    ctx.lineTo(ox + scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(250,204,21,0.03)';
    ctx.fill();

    // Spacelike regions (left and right of cone)
    ctx.fillStyle = 'rgba(96,165,250,0.03)';
    // Left spacelike
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(0, oy);
    ctx.lineTo(ox - scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fill();
    // Right spacelike
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox + scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(w, oy);
    ctx.lineTo(ox + scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fill();

    // --- Grid ---
    ctx.strokeStyle = 'rgba(30,41,59,0.6)';
    ctx.lineWidth = 0.5;
    for (let i = -5; i <= 5; i++) {
      // Vertical grid (space)
      const gx = ox + i * scale * 0.4;
      ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
      // Horizontal grid (time)
      const gy = oy + i * scale * 0.4;
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }

    // --- Axes ---
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    // Space axis (x)
    ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(w, oy); ctx.stroke();
    // Time axis (ct)
    ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, h); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('x (space)', w - 10, oy - 10);
    ctx.textAlign = 'center';
    ctx.fillText('ct (time)', ox + 28, 18);

    // Axis arrows
    ctx.fillStyle = '#475569';
    ctx.beginPath();
    ctx.moveTo(ox, 4); ctx.lineTo(ox - 5, 14); ctx.lineTo(ox + 5, 14);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(w - 4, oy); ctx.lineTo(w - 14, oy - 5); ctx.lineTo(w - 14, oy + 5);
    ctx.closePath(); ctx.fill();

    // --- Light cone lines (45°) ---
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    // Future
    ctx.beginPath();
    ctx.moveTo(ox - scale * 2, oy - scale * 2);
    ctx.lineTo(ox, oy);
    ctx.lineTo(ox + scale * 2, oy - scale * 2);
    ctx.stroke();
    // Past
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.moveTo(ox - scale * 1.5, oy + scale * 1.5);
    ctx.lineTo(ox, oy);
    ctx.lineTo(ox + scale * 1.5, oy + scale * 1.5);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Light cone label
    ctx.fillStyle = '#f59e0b';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('v = c', ox + scale * 0.9 + 4, oy - scale * 0.9 - 4);
    ctx.textAlign = 'right';
    ctx.fillText('v = c', ox - scale * 0.9 - 4, oy - scale * 0.9 - 4);

    // --- Region labels ---
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(250,204,21,0.4)';
    ctx.fillText('FUTURE', ox, oy - scale * 1.1);
    ctx.fillText('(timelike)', ox, oy - scale * 1.1 + 15);
    ctx.fillStyle = 'rgba(250,204,21,0.25)';
    ctx.fillText('PAST', ox, oy + scale * 0.55);
    ctx.fillStyle = 'rgba(96,165,250,0.35)';
    ctx.fillText('SPACELIKE', ox + scale * 1.1, oy - scale * 0.15);
    ctx.font = '10px system-ui';
    ctx.fillText('(FTL needed)', ox + scale * 1.1, oy);
    ctx.fillStyle = 'rgba(96,165,250,0.35)';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('SPACELIKE', ox - scale * 1.1, oy - scale * 0.15);
    ctx.font = '10px system-ui';
    ctx.fillText('(FTL needed)', ox - scale * 1.1, oy);

    // --- Object worldline ---
    const b = animBeta;
    const wlLen = scale * 2;
    // Worldline: dx/d(ct) = v/c = beta, so for ct units up, x = beta * ct
    const wlEndX = ox + b * wlLen;
    const wlEndY = oy - wlLen;

    // Worldline glow
    ctx.strokeStyle = 'rgba(6,182,212,0.15)';
    ctx.lineWidth = 8;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();
    ctx.strokeStyle = 'rgba(6,182,212,0.3)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();
    // Worldline core
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();

    // Arrowhead on worldline
    const wlAngle = Math.atan2(wlEndY - oy, wlEndX - ox);
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.moveTo(wlEndX, wlEndY);
    ctx.lineTo(wlEndX - 10 * Math.cos(wlAngle - 0.3), wlEndY - 10 * Math.sin(wlAngle - 0.3));
    ctx.lineTo(wlEndX - 10 * Math.cos(wlAngle + 0.3), wlEndY - 10 * Math.sin(wlAngle + 0.3));
    ctx.closePath(); ctx.fill();

    // Worldline label
    ctx.fillStyle = '#06b6d4';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    const lblOff = b > 0.3 ? -16 : 8;
    ctx.fillText('worldline', wlEndX + 8, wlEndY + lblOff);
    ctx.font = '11px system-ui';
    ctx.fillText('v = ' + b.toFixed(2) + 'c', wlEndX + 8, wlEndY + lblOff + 15);

    // --- Simultaneity line (tilted "now" for moving observer) ---
    // In Minkowski diagram, the simultaneity line tilts at angle arctan(v/c) from x-axis
    if (b > 0.01) {
      const simLen = scale * 1.5;
      const simEndX = ox + simLen;
      const simEndY = oy - b * simLen;
      const simStartX = ox - simLen;
      const simStartY = oy + b * simLen;

      ctx.strokeStyle = 'rgba(168,85,247,0.2)';
      ctx.lineWidth = 6;
      ctx.beginPath(); ctx.moveTo(simStartX, simStartY); ctx.lineTo(simEndX, simEndY); ctx.stroke();
      ctx.strokeStyle = '#a855f7';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath(); ctx.moveTo(simStartX, simStartY); ctx.lineTo(simEndX, simEndY); ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#a855f7';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('"now" (moving frame)', simEndX + 6, simEndY - 4);
    }

    // --- Animated photon on the light cone ---
    const photonPhase = (animTime % 3000) / 3000;
    const photonDist = photonPhase * scale * 1.5;
    const ppx = ox + photonDist;
    const ppy = oy - photonDist;
    // Right-going photon
    const pg = ctx.createRadialGradient(ppx, ppy, 0, ppx, ppy, 6);
    pg.addColorStop(0, '#fbbf24');
    pg.addColorStop(1, 'transparent');
    ctx.fillStyle = pg;
    ctx.fillRect(ppx - 8, ppy - 8, 16, 16);
    ctx.beginPath(); ctx.arc(ppx, ppy, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fef3c7'; ctx.fill();
    // Left-going photon
    const ppx2 = ox - photonDist;
    const ppy2 = oy - photonDist;
    const pg2 = ctx.createRadialGradient(ppx2, ppy2, 0, ppx2, ppy2, 6);
    pg2.addColorStop(0, '#fbbf24');
    pg2.addColorStop(1, 'transparent');
    ctx.fillStyle = pg2;
    ctx.fillRect(ppx2 - 8, ppy2 - 8, 16, 16);
    ctx.beginPath(); ctx.arc(ppx2, ppy2, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fef3c7'; ctx.fill();

    // --- Proper time tick marks along worldline ---
    if (b > 0.01) {
      const g = gamma(Math.min(b, 0.999));
      const tickSpacing = scale * 0.3;
      const numTicks = Math.floor(wlLen / tickSpacing);
      const perpAngle = wlAngle + Math.PI / 2;
      ctx.strokeStyle = 'rgba(6,182,212,0.5)';
      ctx.lineWidth = 1;
      for (let i = 1; i <= numTicks; i++) {
        const frac = (i * tickSpacing) / wlLen;
        const tx = lerp(ox, wlEndX, frac);
        const ty = lerp(oy, wlEndY, frac);
        ctx.beginPath();
        ctx.moveTo(tx - 5 * Math.cos(perpAngle), ty - 5 * Math.sin(perpAngle));
        ctx.lineTo(tx + 5 * Math.cos(perpAngle), ty + 5 * Math.sin(perpAngle));
        ctx.stroke();
      }
      // Corresponding coordinate-time ticks on ct axis
      ctx.strokeStyle = 'rgba(148,163,184,0.3)';
      for (let i = 1; i <= numTicks; i++) {
        const frac = (i * tickSpacing) / wlLen;
        const ty = oy - frac * wlLen;
        ctx.beginPath();
        ctx.moveTo(ox - 5, ty);
        ctx.lineTo(ox + 5, ty);
        ctx.stroke();
      }
    }

    // --- Origin event dot ---
    ctx.beginPath();
    ctx.arc(ox, oy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#f1f5f9';
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('event (here, now)', ox - 10, oy + 4);

    requestAnimationFrame(draw);
  }

  slider.addEventListener('input', () => {
    beta = slider.value / 1000;
    const b = Math.min(beta, 0.999);
    document.getElementById('st-vel-label').textContent = beta.toFixed(2) + 'c';

    // Worldline angle from space axis: angle = arctan(ct / x) = arctan(1/beta)
    // From vertical (ct axis): theta = arctan(beta)
    const wlAngleDeg = beta > 0.001 ? Math.atan(1 / beta) * 180 / Math.PI : 90;
    document.getElementById('st-angle').innerHTML = wlAngleDeg.toFixed(1) + '&deg;';
    document.getElementById('st-cone').innerHTML = '45.0&deg;';

    const g = beta > 0.001 ? gamma(b) : 1;
    document.getElementById('st-proper').textContent = (1 / g).toFixed(3);

    const simTilt = Math.atan(beta) * 180 / Math.PI;
    document.getElementById('st-simtilt').innerHTML = simTilt.toFixed(1) + '&deg;';
  });

  requestAnimationFrame(draw);
})();

// ==================== LORENTZ GRAPH ====================
(function initLorentz() {
  const { ctx, w, h } = setupCanvas('lorentz-graph');
  const slider = document.getElementById('lorentz-vel');
  let currentBeta = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);
    ctx.save();
    ctx.translate(16, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('γ (Lorentz Factor)', 0, 0);
    ctx.restore();

    // Grid + tick marks
    const maxGamma = 20;
    for (let g = 0; g <= maxGamma; g += 5) {
      const y = pad.t + gh - (g / maxGamma) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(g.toString(), pad.l - 8, y + 4);
    }
    for (let v = 0; v <= 1; v += 0.2) {
      const x = pad.l + v * gw;
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      ctx.fillText(v.toFixed(1) + 'c', x, pad.t + gh + 20);
    }

    // Curve
    ctx.beginPath();
    ctx.strokeStyle = '#a855f7';
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 500; i++) {
      const b = (i / 500) * 0.999;
      const g = gamma(b);
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(g, maxGamma) / maxGamma) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Asymptote at v=c
    ctx.strokeStyle = 'rgba(239,68,68,0.5)';
    ctx.setLineDash([6, 4]);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pad.l + gw, pad.t);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('v = c (impossible for mass)', pad.l + gw - 6, pad.t + 16);

    // Current point
    if (currentBeta > 0) {
      const g = gamma(Math.min(currentBeta, 0.9999));
      const x = pad.l + currentBeta * gw;
      const y = pad.t + gh - (Math.min(g, maxGamma) / maxGamma) * gh;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(6,182,212,0.4)';
      ctx.beginPath();
      ctx.moveTo(x, pad.t + gh);
      ctx.lineTo(x, y);
      ctx.lineTo(pad.l, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.fillStyle = '#06b6d4';
      ctx.fill();
      ctx.strokeStyle = '#0e7490';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 1000;
    const g = currentBeta > 0 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    document.getElementById('lorentz-vel-label').textContent = currentBeta.toFixed(3) + 'c';
    document.getElementById('l-v').textContent = currentBeta.toFixed(3);
    document.getElementById('l-gamma').textContent = fmt(g);
    document.getElementById('l-length').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('l-mass').textContent = fmt(g) + '× m₀';
    draw();
  });

  draw();
})();

// ==================== LENGTH CONTRACTION ====================
(function initContraction() {
  const { ctx, w, h } = setupCanvas('lc-canvas');
  const slider = document.getElementById('lc-vel');
  const flybyBtn = document.getElementById('lc-flyby');
  const flybyResetBtn = document.getElementById('lc-flyby-reset');

  let beta = 0;
  let prevTs = null;

  // Fly-by state
  let flybyActive = false;
  let flybyShips = []; // {x, beta, color}

  const REST_LEN = 100; // meters (conceptual)
  const SHIP_PX_REST = 280; // pixels at rest
  const topY = 10;       // top view area
  const midY = h / 2 - 10;  // divider
  const botY = h / 2 + 10;  // bottom view area
  const viewH = h / 2 - 20;

  // --- Ship drawing ---
  function drawShip(ctx, cx, cy, lengthPx, heightPx, color, label, faded) {
    const hw = lengthPx / 2;
    const hh = heightPx / 2;
    const alpha = faded ? 0.25 : 1;

    ctx.globalAlpha = alpha;

    // Engine glow (rear)
    if (!faded && beta > 0.01) {
      const eg = ctx.createRadialGradient(cx - hw - 4, cy, 0, cx - hw - 4, cy, hh * 1.8);
      eg.addColorStop(0, 'rgba(6,182,212,0.25)');
      eg.addColorStop(1, 'transparent');
      ctx.fillStyle = eg;
      ctx.fillRect(cx - hw - hh * 2, cy - hh * 2, hh * 4, hh * 4);
    }

    // Hull body
    ctx.beginPath();
    ctx.moveTo(cx + hw, cy);                          // nose tip
    ctx.lineTo(cx + hw * 0.65, cy - hh);              // top front
    ctx.lineTo(cx - hw * 0.6, cy - hh);               // top rear
    ctx.lineTo(cx - hw, cy - hh * 0.5);               // engine top
    ctx.lineTo(cx - hw, cy + hh * 0.5);               // engine bottom
    ctx.lineTo(cx - hw * 0.6, cy + hh);               // bottom rear
    ctx.lineTo(cx + hw * 0.65, cy + hh);              // bottom front
    ctx.closePath();

    const hGrad = ctx.createLinearGradient(cx, cy - hh, cx, cy + hh);
    hGrad.addColorStop(0, color);
    hGrad.addColorStop(0.4, lightenColor(color, 40));
    hGrad.addColorStop(1, darkenColor(color, 40));
    ctx.fillStyle = hGrad;
    ctx.fill();
    ctx.strokeStyle = lightenColor(color, 60);
    ctx.lineWidth = 1;
    ctx.stroke();

    // Cockpit window
    const winW = Math.max(lengthPx * 0.12, 6);
    const winH = Math.max(heightPx * 0.35, 4);
    ctx.beginPath();
    ctx.ellipse(cx + hw * 0.4, cy, winW / 2, winH / 2, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(6,182,212,0.6)';
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.beginPath();
    ctx.ellipse(cx + hw * 0.4 - 1, cy - 1, winW * 0.25, winH * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Engine nozzles
    const nozW = Math.max(lengthPx * 0.04, 3);
    ctx.fillStyle = '#475569';
    for (let n = -1; n <= 1; n += 2) {
      ctx.fillRect(cx - hw - nozW, cy + n * hh * 0.25 - nozW / 2, nozW, nozW);
    }

    // Hull detail lines
    ctx.strokeStyle = lightenColor(color, 30) + '66';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
      const lx = cx - hw * 0.6 + (i / 4) * lengthPx * 0.8;
      ctx.beginPath();
      ctx.moveTo(lx, cy - hh + 2);
      ctx.lineTo(lx, cy + hh - 2);
      ctx.stroke();
    }

    // Nacelles / wings
    const wingSpan = hh * 1.5;
    ctx.fillStyle = darkenColor(color, 20);
    // Top wing
    ctx.beginPath();
    ctx.moveTo(cx - hw * 0.2, cy - hh);
    ctx.lineTo(cx - hw * 0.5, cy - wingSpan);
    ctx.lineTo(cx - hw * 0.7, cy - wingSpan);
    ctx.lineTo(cx - hw * 0.5, cy - hh);
    ctx.closePath();
    ctx.fill();
    // Bottom wing
    ctx.beginPath();
    ctx.moveTo(cx - hw * 0.2, cy + hh);
    ctx.lineTo(cx - hw * 0.5, cy + wingSpan);
    ctx.lineTo(cx - hw * 0.7, cy + wingSpan);
    ctx.lineTo(cx - hw * 0.5, cy + hh);
    ctx.closePath();
    ctx.fill();

    // Wing-tip engines
    if (lengthPx > 40) {
      ctx.fillStyle = '#94a3b8';
      ctx.beginPath();
      ctx.ellipse(cx - hw * 0.6, cy - wingSpan, nozW * 1.2, nozW * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - hw * 0.6, cy + wingSpan, nozW * 1.2, nozW * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;

    // Label
    if (label) {
      ctx.fillStyle = faded ? '#475569' : '#e2e8f0';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, cy + hh * 1.5 + 22);
    }
  }

  function lightenColor(hex, amount) {
    const r = Math.min(255, parseInt(hex.slice(1,3), 16) + amount);
    const g = Math.min(255, parseInt(hex.slice(3,5), 16) + amount);
    const b = Math.min(255, parseInt(hex.slice(5,7), 16) + amount);
    return `rgb(${r},${g},${b})`;
  }
  function darkenColor(hex, amount) {
    const r = Math.max(0, parseInt(hex.slice(1,3), 16) - amount);
    const g = Math.max(0, parseInt(hex.slice(3,5), 16) - amount);
    const b = Math.max(0, parseInt(hex.slice(5,7), 16) - amount);
    return `rgb(${r},${g},${b})`;
  }

  // --- Ruler ---
  function drawRuler(ctx, x, y, totalPx, label, segments) {
    const segW = totalPx / segments;
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.fillStyle = '#64748b';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    // Main line
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + totalPx, y);
    ctx.stroke();
    // Ticks
    for (let i = 0; i <= segments; i++) {
      const tx = x + i * segW;
      const major = i % 2 === 0;
      ctx.beginPath();
      ctx.moveTo(tx, y - (major ? 6 : 3));
      ctx.lineTo(tx, y + (major ? 6 : 3));
      ctx.stroke();
      if (major) {
        ctx.fillText(Math.round(i * REST_LEN / segments) + '', tx, y + 16);
      }
    }
    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.fillText(label, x + totalPx / 2, y - 12);
  }

  // --- Dimension bracket ---
  function drawBracket(ctx, x1, x2, y, label, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    const bh = 6;
    ctx.beginPath();
    ctx.moveTo(x1, y - bh); ctx.lineTo(x1, y); ctx.lineTo(x2, y); ctx.lineTo(x2, y - bh);
    ctx.stroke();
    // Arrow heads
    ctx.beginPath();
    ctx.moveTo(x1 + 5, y - 2); ctx.lineTo(x1, y); ctx.lineTo(x1 + 5, y + 2);
    ctx.moveTo(x2 - 5, y - 2); ctx.lineTo(x2, y); ctx.lineTo(x2 - 5, y + 2);
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, (x1 + x2) / 2, y + 15);
  }

  // --- Grid ---
  function drawGrid(ctx, x, y, gw, gh, cellSize) {
    ctx.strokeStyle = 'rgba(30,41,59,0.5)';
    ctx.lineWidth = 0.5;
    for (let gx = 0; gx <= gw; gx += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x + gx, y);
      ctx.lineTo(x + gx, y + gh);
      ctx.stroke();
    }
    for (let gy = 0; gy <= gh; gy += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x, y + gy);
      ctx.lineTo(x + gw, y + gy);
      ctx.stroke();
    }
  }

  // --- Main animation ---
  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;

    const g = beta > 0.001 ? gamma(Math.min(beta, 0.999)) : 1;
    const contractedPx = SHIP_PX_REST / g;
    const contractedM = REST_LEN / g;

    ctx.clearRect(0, 0, w, h);

    const cx = w / 2;

    // ===== TOP: Rest frame =====
    const topCenterY = topY + viewH / 2;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, topY, w, viewH);

    // Grid
    drawGrid(ctx, cx - SHIP_PX_REST / 2 - 40, topY + 10, SHIP_PX_REST + 80, viewH - 20, 28);

    // Section label
    ctx.fillStyle = 'rgba(148,163,184,0.3)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('REST FRAME (v = 0)', 14, topY + 22);

    // Rest ship
    drawShip(ctx, cx, topCenterY, SHIP_PX_REST, 50, '#3b82f6', null, false);

    // Ruler above
    drawRuler(ctx, cx - SHIP_PX_REST / 2, topY + 24, SHIP_PX_REST, 'Rest length (m)', 10);

    // Bracket below
    drawBracket(ctx, cx - SHIP_PX_REST / 2, cx + SHIP_PX_REST / 2, topCenterY + 46,
      'L₀ = ' + REST_LEN.toFixed(0) + ' m', '#3b82f6');

    // ===== DIVIDER =====
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, midY);
    ctx.lineTo(w - 20, midY);
    ctx.stroke();
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('— as seen by stationary observer —', cx, midY + 4);

    // ===== BOTTOM: Observer's frame =====
    const botCenterY = botY + viewH / 2;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, botY + 8, w, viewH);

    // Grid (same spacing as top — shows contraction against fixed reference)
    drawGrid(ctx, cx - SHIP_PX_REST / 2 - 40, botY + 18, SHIP_PX_REST + 80, viewH - 20, 28);

    // Section label
    ctx.fillStyle = 'rgba(148,163,184,0.3)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('OBSERVER FRAME (v = ' + beta.toFixed(2) + 'c)', 14, botY + 30);

    // Ghost rest-length outline (faded)
    if (beta > 0.01) {
      drawShip(ctx, cx, botCenterY, SHIP_PX_REST, 50, '#3b82f6', null, true);
    }

    // Contracted ship
    const shipH = 50;
    drawShip(ctx, cx, botCenterY, contractedPx, shipH, '#06b6d4', null, false);

    // Ruler (same total width as rest ruler for comparison)
    drawRuler(ctx, cx - SHIP_PX_REST / 2, botY + 32, SHIP_PX_REST, 'Observer\'s ruler (m)', 10);

    // Bracket below contracted ship
    drawBracket(ctx, cx - contractedPx / 2, cx + contractedPx / 2, botCenterY + 46,
      'L = ' + contractedM.toFixed(1) + ' m (' + (100 / g).toFixed(1) + '%)', '#06b6d4');

    // Contraction arrows (showing squeeze)
    if (beta > 0.05) {
      const restHalf = SHIP_PX_REST / 2;
      const conHalf = contractedPx / 2;
      ctx.strokeStyle = 'rgba(239,68,68,0.5)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([3, 3]);
      // Left
      ctx.beginPath();
      ctx.moveTo(cx - restHalf, botCenterY - shipH * 0.8);
      ctx.lineTo(cx - conHalf, botCenterY - shipH * 0.3);
      ctx.stroke();
      // Right
      ctx.beginPath();
      ctx.moveTo(cx + restHalf, botCenterY - shipH * 0.8);
      ctx.lineTo(cx + conHalf, botCenterY - shipH * 0.3);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ===== FLY-BY ANIMATION =====
    if (flybyActive) {
      flybyShips.forEach(ship => {
        ship.x += ship.speed * dt;
      });
      // Remove off-screen ships
      flybyShips = flybyShips.filter(s => s.x < w + 200);

      // Draw fly-by ships in a strip between sections
      flybyShips.forEach(ship => {
        const sg = ship.beta > 0.001 ? gamma(Math.min(ship.beta, 0.999)) : 1;
        const sLen = 120 / sg;
        const sH = 22;
        const sy = midY;

        // Motion blur trail
        const trailLen = ship.beta * 80;
        const tGrad = ctx.createLinearGradient(ship.x - sLen / 2 - trailLen, sy, ship.x - sLen / 2, sy);
        tGrad.addColorStop(0, 'transparent');
        tGrad.addColorStop(1, ship.color + '44');
        ctx.fillStyle = tGrad;
        ctx.fillRect(ship.x - sLen / 2 - trailLen, sy - sH, trailLen, sH * 2);

        drawShip(ctx, ship.x, sy, sLen, sH, ship.color, null, false);

        // Velocity label
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(ship.beta.toFixed(2) + 'c', ship.x, sy - sH - 6);
      });

      // Spawn new ships periodically
      if (flybyShips.length === 0 || (flybyShips.length < 4 && flybyShips[flybyShips.length - 1].x > 80)) {
        const speeds = [0.1, 0.5, 0.8, 0.95];
        const colors = ['#22c55e', '#3b82f6', '#a855f7', '#ef4444'];
        if (flybyShips.length < speeds.length) {
          const idx = flybyShips.length;
          flybyShips.push({
            x: -180,
            beta: speeds[idx],
            speed: (0.15 + speeds[idx] * 0.35),
            color: colors[idx]
          });
        }
      }
    }

    // Formula overlay
    ctx.fillStyle = 'rgba(17,24,39,0.7)';
    ctx.beginPath();
    ctx.roundRect(w - 200, h - 40, 190, 30, 6);
    ctx.fill();
    ctx.fillStyle = '#a855f7';
    ctx.font = 'italic 14px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('L = L₀ / γ = L₀ √(1 − v²/c²)', w - 105, h - 20);

    requestAnimationFrame(draw);
  }

  // --- Slider ---
  slider.addEventListener('input', () => {
    beta = slider.value / 1000;
    const g = beta > 0.001 ? gamma(Math.min(beta, 0.999)) : 1;
    const contractedM = REST_LEN / g;
    document.getElementById('lc-vel-label').textContent = beta.toFixed(2) + 'c';
    document.getElementById('lc-rest').textContent = REST_LEN.toFixed(1) + ' m';
    document.getElementById('lc-obs').textContent = contractedM.toFixed(1) + ' m';
    document.getElementById('lc-pct').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('lc-gamma').textContent = fmt(g);
  });

  // --- Fly-by controls ---
  flybyBtn.addEventListener('click', () => {
    flybyActive = !flybyActive;
    flybyBtn.textContent = flybyActive ? 'Stop Fly-By' : 'Launch Fly-By';
    if (flybyActive) flybyShips = [];
  });
  flybyResetBtn.addEventListener('click', () => {
    flybyActive = false;
    flybyShips = [];
    flybyBtn.textContent = 'Launch Fly-By';
  });

  requestAnimationFrame(draw);
})();

// ==================== ENERGY GRAPHS ====================
(function initEnergy() {
  const keC = setupCanvas('ke-graph');
  const totC = setupCanvas('total-graph');
  const momC = setupCanvas('momentum-graph');
  const slider = document.getElementById('energy-vel');
  let currentBeta = 0;

  function drawGraph(setup, fn, label, color, maxY, yLabel) {
    const { ctx, w, h } = setup;
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 70, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);
    ctx.save();
    ctx.translate(14, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    // Grid
    for (let i = 0; i <= 4; i++) {
      const val = (maxY / 4) * i;
      const y = pad.t + gh - (i / 4) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(fmt(val, 1), pad.l - 8, y + 4);
    }

    // Classical comparison (dashed)
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(100,116,139,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 1.5;
    for (let i = 0; i <= 400; i++) {
      const b = (i / 400) * 0.999;
      let classicalVal;
      if (label === 'KE') classicalVal = 0.5 * b * b;
      else if (label === 'Total') classicalVal = 1 + 0.5 * b * b;
      else classicalVal = b;
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(classicalVal, maxY) / maxY) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Relativistic curve
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 500; i++) {
      const b = (i / 500) * 0.999;
      const val = fn(b);
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Legend
    ctx.fillStyle = color;
    ctx.fillRect(pad.l + 10, pad.t + 8, 20, 3);
    ctx.fillStyle = '#e2e8f0';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Relativistic', pad.l + 36, pad.t + 13);
    ctx.fillStyle = '#64748b';
    ctx.fillRect(pad.l + 10, pad.t + 24, 20, 3);
    ctx.fillText('Classical (Newtonian)', pad.l + 36, pad.t + 29);

    // Current point
    if (currentBeta > 0.001) {
      const val = fn(Math.min(currentBeta, 0.9999));
      const x = pad.l + currentBeta * gw;
      const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(6,182,212,0.4)';
      ctx.beginPath();
      ctx.moveTo(x, pad.t + gh);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#06b6d4';
      ctx.fill();
    }
  }

  function update() {
    const keFunc = (b) => gamma(b) - 1;
    const totFunc = (b) => gamma(b);
    const momFunc = (b) => gamma(b) * b;

    drawGraph(keC, keFunc, 'KE', '#f59e0b', 20, 'KE / mc²');
    drawGraph(totC, totFunc, 'Total', '#ef4444', 20, 'E / mc²');
    drawGraph(momC, momFunc, 'p', '#a855f7', 20, 'p / mc');
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 1000;
    const g = currentBeta > 0.001 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    const ke = g - 1;
    const mom = g * currentBeta;
    document.getElementById('energy-vel-label').textContent = currentBeta.toFixed(3) + 'c';
    document.getElementById('e-rest').textContent = '1.00 mc²';
    document.getElementById('e-ke').textContent = fmt(ke) + ' mc²';
    document.getElementById('e-total').textContent = fmt(g) + ' mc²';
    document.getElementById('e-mom').textContent = fmt(mom) + ' mc';
    update();
  });

  // Tabs
  document.querySelectorAll('#sec-energy .tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#sec-energy .tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('#sec-energy .tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab).classList.add('active');
      update();
    });
  });

  update();
})();

// ==================== MUON SIMULATION ====================
(function initMuon() {
  const { ctx, w, h } = setupCanvas('muon-canvas');
  const startBtn = document.getElementById('muon-start');
  const resetBtn = document.getElementById('muon-reset');
  let running = false;
  let altitude = 15000; // meters
  const totalAlt = 15000;
  const muonHalfLife = 1.56e-6; // seconds (half-life)
  const muonSpeed = 0.998; // fraction of c
  const gMuon = gamma(muonSpeed);
  let classicalSurvival = 1;
  let relativisticSurvival = 1;
  let animId = null;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 60, t: 20, b: 40 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Background gradient (sky to ground)
    const skyGrad = ctx.createLinearGradient(0, pad.t, 0, pad.t + gh);
    skyGrad.addColorStop(0, '#0c1445');
    skyGrad.addColorStop(0.85, '#1a2744');
    skyGrad.addColorStop(1, '#2d4a2d');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(pad.l, pad.t, gw, gh);

    // Altitude marks
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'right';
    for (let a = 0; a <= 15; a += 3) {
      const y = pad.t + gh - (a / 15) * gh;
      ctx.fillText(a + ' km', pad.l - 8, y + 4);
      ctx.strokeStyle = 'rgba(100,116,139,0.2)';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
    }

    // Ground
    ctx.fillStyle = '#3d5a3d';
    ctx.fillRect(pad.l, pad.t + gh - 2, gw, 4);
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.fillText('Sea Level', pad.l + gw / 2, pad.t + gh + 16);

    // Muon positions
    const progress = 1 - altitude / totalAlt;
    const currentY = pad.t + progress * gh;

    // Classical decay line (660m ~ 4.4% of 15km)
    const classicalRange = 660;
    const classicalY = pad.t + (classicalRange / totalAlt) * gh;
    ctx.strokeStyle = 'rgba(245,158,11,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t + gh - classicalY + pad.t);
    ctx.lineTo(pad.l + gw, pad.t + gh - classicalY + pad.t);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'left';
    ctx.fillText('Classical decay range (~660m)', pad.l + gw + 6, pad.t + gh - classicalY + pad.t + 4);

    // Draw muon particles - Classical (left half)
    const numMuons = 30;
    const leftX = pad.l + gw * 0.25;
    const rightX = pad.l + gw * 0.75;

    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Classical', leftX, pad.t + gh + 30);
    ctx.fillStyle = '#06b6d4';
    ctx.fillText('Relativistic', rightX, pad.t + gh + 30);

    for (let i = 0; i < numMuons; i++) {
      const angle = (i / numMuons) * Math.PI * 2;
      const spread = 40;

      // Classical
      const cx = leftX + Math.cos(angle + i) * spread * (i % 3 + 1) / 3;
      const cy = currentY + Math.sin(angle) * 8;
      const classAlpha = classicalSurvival > (i / numMuons) ? 0.8 : 0.08;
      ctx.beginPath();
      ctx.arc(cx, cy, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(245,158,11,${classAlpha})`;
      ctx.fill();

      // Relativistic
      const rx = rightX + Math.cos(angle + i) * spread * (i % 3 + 1) / 3;
      const ry = currentY + Math.sin(angle) * 8;
      const relAlpha = relativisticSurvival > (i / numMuons) ? 0.8 : 0.08;
      ctx.beginPath();
      ctx.arc(rx, ry, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(6,182,212,${relAlpha})`;
      ctx.fill();
    }
  }

  function step() {
    if (!running) return;
    const speed = muonSpeed * c; // m/s
    const dt = 0.016; // 16ms frame
    const simSpeed = 500; // speed up simulation
    const distStep = speed * dt * simSpeed / c * 150;

    altitude -= distStep;
    if (altitude < 0) altitude = 0;

    const distTraveled = totalAlt - altitude;
    const timeClassical = distTraveled / (muonSpeed * c);
    const timeRelativistic = timeClassical / gMuon;

    classicalSurvival = Math.pow(0.5, timeClassical / muonHalfLife);
    relativisticSurvival = Math.pow(0.5, timeRelativistic / muonHalfLife);

    document.getElementById('muon-classical').textContent = (classicalSurvival * 100).toFixed(1) + '%';
    document.getElementById('muon-relativistic').textContent = (relativisticSurvival * 100).toFixed(1) + '%';
    document.getElementById('muon-alt').textContent = (altitude / 1000).toFixed(1) + ' km';

    draw();

    if (altitude > 0) {
      animId = requestAnimationFrame(step);
    } else {
      running = false;
      startBtn.textContent = 'Start Simulation';
    }
  }

  startBtn.addEventListener('click', () => {
    if (running) {
      running = false;
      startBtn.textContent = 'Resume';
    } else {
      running = true;
      startBtn.textContent = 'Pause';
      step();
    }
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    if (animId) cancelAnimationFrame(animId);
    altitude = totalAlt;
    classicalSurvival = 1;
    relativisticSurvival = 1;
    startBtn.textContent = 'Start Simulation';
    document.getElementById('muon-classical').textContent = '100%';
    document.getElementById('muon-relativistic').textContent = '100%';
    document.getElementById('muon-alt').textContent = '15.0 km';
    draw();
  });

  draw();
})();

// ==================== E=mc² SECTION ====================
(function initEmc2() {
  const { ctx, w, h } = setupCanvas('emc2-graph');
  const slider = document.getElementById('mass-slider');

  function draw(mass) {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 70, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Bar chart comparison
    const items = [
      { label: `${mass} kg at rest\n(E=mc²)`, energy: mass * c * c, color: '#06b6d4' },
      { label: 'Hiroshima\n(~6.3×10¹³ J)', energy: 6.3e13, color: '#f59e0b' },
      { label: 'US daily energy\n(~2.7×10¹⁶ J)', energy: 2.7e16, color: '#a855f7' },
      { label: `${mass} kg at 0.9c\n(γmc²)`, energy: gamma(0.9) * mass * c * c, color: '#ef4444' },
    ];

    const maxE = Math.max(...items.map(i => i.energy));
    const barW = gw / items.length - 20;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.save();
    ctx.translate(14, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Energy (log scale)', 0, 0);
    ctx.restore();

    // Use log scale
    const logMax = Math.log10(maxE);
    const logMin = 10;

    items.forEach((item, i) => {
      const x = pad.l + (i + 0.5) * (gw / items.length) - barW / 2;
      const logE = Math.log10(Math.max(item.energy, 1));
      const barH = ((logE - logMin) / (logMax - logMin + 2)) * gh;

      // Bar
      const grad = ctx.createLinearGradient(x, pad.t + gh - barH, x, pad.t + gh);
      grad.addColorStop(0, item.color);
      grad.addColorStop(1, item.color + '44');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(x, pad.t + gh - barH, barW, barH, [4, 4, 0, 0]);
      ctx.fill();

      // Value on bar
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center';
      const eStr = item.energy.toExponential(1);
      ctx.fillText(eStr + ' J', x + barW / 2, pad.t + gh - barH - 8);

      // Label below
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px system-ui';
      const lines = item.label.split('\n');
      lines.forEach((line, li) => {
        ctx.fillText(line, x + barW / 2, pad.t + gh + 14 + li * 13);
      });
    });
  }

  slider.addEventListener('input', () => {
    const mass = parseFloat(slider.value);
    document.getElementById('mass-label').textContent = mass.toFixed(0) + ' kg';

    const energy = mass * c * c;
    const tntMegatons = energy / 4.184e15;
    const cityYears = energy / (1e9 * 3.15e7);

    document.getElementById('emc2-rest').innerHTML = (energy / 1e16).toFixed(1) + ' &times; 10&sup1;&sup6; J';
    document.getElementById('emc2-tnt').textContent = tntMegatons.toFixed(1) + ' MT';
    document.getElementById('emc2-power').textContent = `A city for ${cityYears.toFixed(1)} years`;
    draw(mass);
  });

  draw(1);
})();

// ==================== TWIN PARADOX ====================
(function initTwins() {
  const { ctx, w, h } = setupCanvas('twin-canvas');
  const velSlider = document.getElementById('twin-vel');
  const distSlider = document.getElementById('twin-dist');
  const playBtn = document.getElementById('twin-play');
  const resetBtn = document.getElementById('twin-reset');
  const speedBtn = document.getElementById('twin-speed');

  let beta = 0.5;
  let distLY = 5.0; // light-years one way
  let running = false;
  let finished = false;
  let simTime = 0; // Earth elapsed time in years
  let simSpeed = 1; // multiplier
  let prevTs = null;
  let animId = null;

  // Derived quantities
  function getTripStats() {
    const g = gamma(beta);
    const tOneWayEarth = distLY / beta;      // years (Earth frame)
    const tTotalEarth = 2 * tOneWayEarth;     // round trip, Earth
    const tTotalTraveler = tTotalEarth / g;    // round trip, traveler
    return { g, tOneWayEarth, tTotalEarth, tTotalTraveler };
  }

  function getPhase(earthTime) {
    const { tOneWayEarth, tTotalEarth } = getTripStats();
    if (earthTime <= 0) return { phase: 'ready', frac: 0, leg: 0 };
    if (earthTime >= tTotalEarth) return { phase: 'reunited', frac: 1, leg: 2 };
    if (earthTime < tOneWayEarth) return { phase: 'outbound', frac: earthTime / tOneWayEarth, leg: 0 };
    if (earthTime < tOneWayEarth * 1.0001) return { phase: 'turnaround', frac: 0.5, leg: 1 };
    return { phase: 'return', frac: (earthTime - tOneWayEarth) / tOneWayEarth, leg: 2 };
  }

  // ---- Drawing helpers ----
  function drawStar(ctx, x, y, r, spikes, color) {
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
      const angle = (i * Math.PI) / spikes - Math.PI / 2;
      const rad = i % 2 === 0 ? r : r * 0.4;
      const px = x + Math.cos(angle) * rad;
      const py = y + Math.sin(angle) * rad;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  function drawPerson(ctx, x, y, scale, faceColor, bodyColor, age) {
    const s = scale;
    // Body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.roundRect(x - 8 * s, y - 2 * s, 16 * s, 22 * s, 4 * s);
    ctx.fill();
    // Head
    ctx.fillStyle = faceColor;
    ctx.beginPath();
    ctx.arc(x, y - 12 * s, 10 * s, 0, Math.PI * 2);
    ctx.fill();
    // Eyes
    ctx.fillStyle = '#1e293b';
    ctx.beginPath();
    ctx.arc(x - 3.5 * s, y - 14 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.arc(x + 3.5 * s, y - 14 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.fill();
    // Mouth
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y - 9 * s, 3 * s, 0.1, Math.PI - 0.1);
    ctx.stroke();
    // Hair (grays with age)
    const grayAmount = Math.min(1, Math.max(0, (age - 40) / 40));
    const hairR = Math.round(lerp(60, 180, grayAmount));
    const hairG = Math.round(lerp(40, 180, grayAmount));
    const hairB = Math.round(lerp(30, 180, grayAmount));
    ctx.fillStyle = `rgb(${hairR},${hairG},${hairB})`;
    ctx.beginPath();
    ctx.ellipse(x, y - 20 * s, 10 * s, 5 * s, 0, Math.PI, 0);
    ctx.fill();
    // Age label
    ctx.fillStyle = '#e2e8f0';
    ctx.font = `bold ${11 * s}px system-ui`;
    ctx.textAlign = 'center';
    ctx.fillText(age.toFixed(1) + ' yr', x, y + 30 * s);
  }

  function drawRocket(ctx, x, y, scale, angle, flameOn) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    const s = scale;
    // Flame
    if (flameOn) {
      const flicker = 0.7 + Math.random() * 0.3;
      const fGrad = ctx.createLinearGradient(0, 12 * s, 0, 12 * s + 18 * s * flicker);
      fGrad.addColorStop(0, '#f59e0b');
      fGrad.addColorStop(0.4, '#ef4444');
      fGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = fGrad;
      ctx.beginPath();
      ctx.moveTo(-5 * s, 12 * s);
      ctx.lineTo(5 * s, 12 * s);
      ctx.lineTo(1 * s, 12 * s + 16 * s * flicker);
      ctx.lineTo(-1 * s, 12 * s + 16 * s * flicker);
      ctx.closePath();
      ctx.fill();
    }
    // Body
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath();
    ctx.moveTo(0, -14 * s);
    ctx.lineTo(-6 * s, 6 * s);
    ctx.lineTo(-8 * s, 12 * s);
    ctx.lineTo(8 * s, 12 * s);
    ctx.lineTo(6 * s, 6 * s);
    ctx.closePath();
    ctx.fill();
    // Nose cone
    const nGrad = ctx.createLinearGradient(0, -14 * s, 0, -4 * s);
    nGrad.addColorStop(0, '#ef4444');
    nGrad.addColorStop(1, '#b91c1c');
    ctx.fillStyle = nGrad;
    ctx.beginPath();
    ctx.moveTo(0, -14 * s);
    ctx.lineTo(-4 * s, -4 * s);
    ctx.lineTo(4 * s, -4 * s);
    ctx.closePath();
    ctx.fill();
    // Window
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.arc(0, -1 * s, 3 * s, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(-1 * s, -2 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.fill();
    // Fins
    ctx.fillStyle = '#64748b';
    ctx.beginPath();
    ctx.moveTo(-6 * s, 6 * s);
    ctx.lineTo(-12 * s, 14 * s);
    ctx.lineTo(-8 * s, 12 * s);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(6 * s, 6 * s);
    ctx.lineTo(12 * s, 14 * s);
    ctx.lineTo(8 * s, 12 * s);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;

    const { g, tOneWayEarth, tTotalEarth, tTotalTraveler } = getTripStats();

    if (running && !finished) {
      const realSecsForTrip = Math.max(6, Math.min(20, tTotalEarth * 2));
      const yearsPerMs = tTotalEarth / (realSecsForTrip * 1000) * simSpeed;
      simTime += dt * yearsPerMs;
      if (simTime >= tTotalEarth) {
        simTime = tTotalEarth;
        finished = true;
        running = false;
        playBtn.textContent = 'Trip Complete';
      }
    }

    const { phase, frac, leg } = getPhase(simTime);

    // Traveler proper time
    let travelerTime = 0;
    if (simTime <= tOneWayEarth) {
      travelerTime = simTime / g;
    } else {
      travelerTime = tOneWayEarth / g + (simTime - tOneWayEarth) / g;
    }
    if (simTime >= tTotalEarth) travelerTime = tTotalTraveler;

    const earthAge = 30 + simTime;
    const travAge = 30 + travelerTime;

    // Update readouts
    document.getElementById('tw-earth-age').textContent = earthAge.toFixed(1) + ' yr';
    document.getElementById('tw-trav-age').textContent = travAge.toFixed(1) + ' yr';
    document.getElementById('tw-earth-time').textContent = simTime.toFixed(1) + ' yr';
    document.getElementById('tw-trav-time').textContent = travelerTime.toFixed(1) + ' yr';
    document.getElementById('tw-diff').textContent = (simTime - travelerTime).toFixed(1) + ' yr';
    const phaseNames = { ready: 'Ready', outbound: 'Outbound →', turnaround: 'Turnaround ↩', return: '← Return', reunited: 'Reunited!' };
    document.getElementById('tw-phase').textContent = phaseNames[phase] || phase;

    // ---- Canvas drawing ----
    ctx.clearRect(0, 0, w, h);

    // STACKED LAYOUT: top = trip animation, bottom = full-width spacetime diagram
    const tripH = h * 0.34;
    const dividerY = tripH;
    const stTop = tripH + 16;

    // ========= TOP: Trip Animation (full width) =========
    const earthX = 100;
    const starX = w - 100;
    const groundY = tripH * 0.62;

    // Background: space gradient
    const spGrad = ctx.createLinearGradient(0, 0, 0, tripH);
    spGrad.addColorStop(0, '#05081a');
    spGrad.addColorStop(0.7, '#0a1030');
    spGrad.addColorStop(1, '#0c1225');
    ctx.fillStyle = spGrad;
    ctx.fillRect(0, 0, w, tripH);

    // Decorative stars
    const starSeed = [0.05,0.12,0.22,0.35,0.43,0.58,0.67,0.78,0.88,0.95,0.15,0.31,0.52,0.71,0.84];
    for (let i = 0; i < starSeed.length; i++) {
      const sx = starSeed[i] * w;
      const sy = starSeed[(i+5)%starSeed.length] * groundY * 0.6 + 8;
      const sr = 0.5 + starSeed[(i+3)%starSeed.length] * 1.3;
      ctx.beginPath();
      ctx.arc(sx, sy, sr, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,210,255,${0.15 + starSeed[(i+7)%starSeed.length] * 0.3})`;
      ctx.fill();
    }

    // Earth
    const earthR = 28;
    ctx.beginPath();
    ctx.arc(earthX, groundY, earthR, 0, Math.PI * 2);
    const eGrad = ctx.createRadialGradient(earthX - 6, groundY - 6, 3, earthX, groundY, earthR);
    eGrad.addColorStop(0, '#3b82f6');
    eGrad.addColorStop(0.5, '#2563eb');
    eGrad.addColorStop(1, '#1e3a5f');
    ctx.fillStyle = eGrad;
    ctx.fill();
    ctx.fillStyle = 'rgba(34,197,94,0.4)';
    ctx.beginPath();
    ctx.ellipse(earthX - 5, groundY - 4, 7, 10, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(earthX + 9, groundY + 5, 6, 5, 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Earth', earthX, groundY + earthR + 16);

    // Destination star
    drawStar(ctx, starX, groundY - 4, 20, 5, '#fbbf24');
    const sgGrad = ctx.createRadialGradient(starX, groundY - 4, 5, starX, groundY - 4, 36);
    sgGrad.addColorStop(0, 'rgba(251,191,36,0.3)');
    sgGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sgGrad;
    ctx.fillRect(starX - 40, groundY - 44, 80, 80);
    ctx.fillStyle = '#f59e0b';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(distLY.toFixed(1) + ' ly', starX, groundY + earthR + 16);

    // Distance line
    ctx.strokeStyle = 'rgba(100,116,139,0.3)';
    ctx.setLineDash([5, 8]);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(earthX + earthR + 6, groundY);
    ctx.lineTo(starX - 24, groundY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Rocket position
    let rocketX, rocketY, rocketAngle, flameOn = false;
    const rocketScale = 1.5;
    if (phase === 'ready') {
      rocketX = earthX + earthR + 30;
      rocketY = groundY;
      rocketAngle = Math.PI / 2;
    } else if (phase === 'outbound') {
      rocketX = lerp(earthX + earthR + 30, starX - 35, frac);
      rocketY = groundY - Math.sin(frac * Math.PI) * 40;
      rocketAngle = Math.PI / 2;
      flameOn = true;
    } else if (phase === 'turnaround') {
      rocketX = starX - 35;
      rocketY = groundY - 40;
      rocketAngle = Math.PI / 2;
      flameOn = true;
    } else if (phase === 'return') {
      rocketX = lerp(starX - 35, earthX + earthR + 30, frac);
      rocketY = groundY - Math.sin(frac * Math.PI) * 40;
      rocketAngle = -Math.PI / 2;
      flameOn = true;
    } else {
      rocketX = earthX + earthR + 30;
      rocketY = groundY;
      rocketAngle = Math.PI / 2;
    }

    drawRocket(ctx, rocketX, rocketY, rocketScale, rocketAngle, flameOn);

    // Twin figures at bottom of trip area
    const twinBaseY = tripH - 8;
    const twinEarthX = earthX + 60;
    const twinTravX = earthX + 120;

    drawPerson(ctx, twinEarthX, twinBaseY - 40, 1.15, '#fcd6a8', '#3b82f6', earthAge);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Earth Twin', twinEarthX, twinBaseY + 2);

    if (phase === 'ready' || phase === 'reunited') {
      drawPerson(ctx, twinTravX, twinBaseY - 40, 1.15, '#fcd6a8', '#a855f7', travAge);
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Traveler', twinTravX, twinBaseY + 2);
    }

    // Age difference highlight on reunion
    if (phase === 'reunited') {
      const diff = (simTime - travelerTime).toFixed(1);
      ctx.fillStyle = 'rgba(239,68,68,0.15)';
      ctx.beginPath();
      ctx.roundRect(twinEarthX - 10, twinBaseY - 86, twinTravX - twinEarthX + 20, 22, 6);
      ctx.fill();
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Δ ' + diff + ' years younger!', (twinEarthX + twinTravX) / 2, twinBaseY - 70);
    }

    // ========= DIVIDER =========
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, dividerY + 6);
    ctx.lineTo(w - 20, dividerY + 6);
    ctx.stroke();

    // ========= BOTTOM: Full-width Spacetime Diagram =========
    const stPad = { l: 70, r: 40, t: 14, b: 40 };
    const stW = w - stPad.l - stPad.r;
    const stH = h - stTop - stPad.t - stPad.b;
    const stOx = stPad.l;
    const stOy = stTop + stPad.t + stH;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, stTop, w, h - stTop);

    // Title
    ctx.fillStyle = '#64748b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('SPACETIME DIAGRAM', stPad.l, stTop + 10);

    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx, stTop + stPad.t);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx + stW, stOy);
    ctx.stroke();

    // Arrow on time axis
    ctx.fillStyle = '#475569';
    ctx.beginPath();
    ctx.moveTo(stOx, stTop + stPad.t);
    ctx.lineTo(stOx - 5, stTop + stPad.t + 12);
    ctx.lineTo(stOx + 5, stTop + stPad.t + 12);
    ctx.closePath();
    ctx.fill();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '13px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('x  (light-years)', stOx + stW / 2, stOy + 32);
    ctx.save();
    ctx.translate(stOx - 50, stTop + stPad.t + stH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('t  (years)', 0, 0);
    ctx.restore();

    // Scale: map distLY -> 60% of stW, tTotalEarth -> 85% of stH
    const xScale = (stW * 0.6) / Math.max(distLY, 0.1);
    const tScale = (stH * 0.85) / Math.max(tTotalEarth, 0.1);

    // Grid
    ctx.strokeStyle = 'rgba(30,41,59,0.4)';
    ctx.lineWidth = 0.5;
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    const tStep = Math.max(1, Math.ceil(tTotalEarth / 10));
    for (let t = tStep; t <= tTotalEarth * 1.1; t += tStep) {
      const y = stOy - t * tScale;
      if (y < stTop + stPad.t) break;
      ctx.beginPath();
      ctx.moveTo(stOx, y);
      ctx.lineTo(stOx + stW, y);
      ctx.stroke();
      ctx.textAlign = 'right';
      ctx.fillText(t.toFixed(0), stOx - 8, y + 4);
    }
    const xStep = Math.max(1, Math.ceil(distLY / 6));
    for (let x = xStep; x <= distLY * 1.15; x += xStep) {
      const px = stOx + x * xScale;
      if (px > stOx + stW) break;
      ctx.beginPath();
      ctx.moveTo(px, stOy);
      ctx.lineTo(px, stTop + stPad.t);
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.fillText(x.toFixed(0), px, stOy + 16);
    }

    // Light cone from origin
    ctx.strokeStyle = 'rgba(245,158,11,0.3)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1.5;
    const lcLen = Math.min(stW, stH);
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx + lcLen, stOy - lcLen);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx - Math.min(stPad.l - 14, lcLen), stOy - Math.min(stPad.l - 14, lcLen));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(245,158,11,0.4)';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('light (c)', stOx + lcLen * 0.35 + 6, stOy - lcLen * 0.35 - 6);

    // Earth worldline (vertical, stationary)
    ctx.strokeStyle = 'rgba(245,158,11,0.6)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx, stOy - tTotalEarth * tScale);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('Earth twin', stOx - 10, stOy - tTotalEarth * tScale + 16);

    // Traveler worldline (kinked V shape)
    const midX = stOx + distLY * xScale;
    const midY = stOy - tOneWayEarth * tScale;
    const endY = stOy - tTotalEarth * tScale;

    // Wide glow
    ctx.strokeStyle = 'rgba(6,182,212,0.1)';
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();
    // Narrow glow
    ctx.strokeStyle = 'rgba(6,182,212,0.25)';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();
    // Core
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();

    // Turnaround kink
    ctx.beginPath();
    ctx.arc(midX, midY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#a855f7';
    ctx.fill();
    ctx.strokeStyle = '#c084fc';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = '#a855f7';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('turnaround', midX + 12, midY + 5);

    // Outbound / return labels
    ctx.fillStyle = '#06b6d4';
    ctx.font = '12px system-ui';
    const outLblX = (stOx + midX) / 2 + 10;
    const outLblY = (stOy + midY) / 2;
    ctx.textAlign = 'left';
    ctx.fillText('outbound →', outLblX, outLblY);
    const retLblX = (stOx + midX) / 2 + 10;
    const retLblY = (midY + endY) / 2;
    ctx.fillText('← return', retLblX, retLblY);

    // Animated position dots
    if (simTime > 0 && simTime <= tTotalEarth) {
      let dotX, dotY;
      if (simTime <= tOneWayEarth) {
        const f = simTime / tOneWayEarth;
        dotX = lerp(stOx, midX, f);
        dotY = lerp(stOy, midY, f);
      } else {
        const f = (simTime - tOneWayEarth) / tOneWayEarth;
        dotX = lerp(midX, stOx, f);
        dotY = lerp(midY, endY, f);
      }
      // Traveler dot glow
      const dg = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, 16);
      dg.addColorStop(0, 'rgba(6,182,212,0.7)');
      dg.addColorStop(1, 'transparent');
      ctx.fillStyle = dg;
      ctx.fillRect(dotX - 18, dotY - 18, 36, 36);
      ctx.beginPath();
      ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();

      // Earth dot
      const eDotY = stOy - simTime * tScale;
      const edg = ctx.createRadialGradient(stOx, eDotY, 0, stOx, eDotY, 14);
      edg.addColorStop(0, 'rgba(245,158,11,0.7)');
      edg.addColorStop(1, 'transparent');
      ctx.fillStyle = edg;
      ctx.fillRect(stOx - 16, eDotY - 16, 32, 32);
      ctx.beginPath();
      ctx.arc(stOx, eDotY, 4.5, 0, Math.PI * 2);
      ctx.fillStyle = '#fef3c7';
      ctx.fill();

      // Connecting dashed line
      ctx.strokeStyle = 'rgba(148,163,184,0.3)';
      ctx.setLineDash([4, 5]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(stOx, eDotY);
      ctx.lineTo(dotX, dotY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Proper time annotations at endpoints
    if (simTime >= tTotalEarth) {
      // Background pill for Earth
      ctx.fillStyle = 'rgba(245,158,11,0.12)';
      ctx.beginPath();
      ctx.roundRect(stOx - 80, endY - 18, 74, 22, 4);
      ctx.fill();
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'right';
      ctx.fillText('τ = ' + tTotalEarth.toFixed(1) + ' yr', stOx - 10, endY - 2);
      // Background pill for Traveler
      ctx.fillStyle = 'rgba(6,182,212,0.12)';
      ctx.beginPath();
      ctx.roundRect(stOx + 6, endY - 18, 82, 22, 4);
      ctx.fill();
      ctx.fillStyle = '#06b6d4';
      ctx.textAlign = 'left';
      ctx.fillText('τ = ' + tTotalTraveler.toFixed(1) + ' yr', stOx + 10, endY - 2);
    }

    // Departure & arrival dots
    ctx.beginPath();
    ctx.arc(stOx, stOy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#e2e8f0';
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('departure', stOx + 10, stOy - 2);

    if (simTime >= tTotalEarth) {
      ctx.beginPath();
      ctx.arc(stOx, endY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#e2e8f0';
      ctx.fill();
      ctx.fillStyle = '#94a3b8';
      ctx.textAlign = 'left';
      ctx.fillText('reunion', stOx + 10, endY + 14);
    }

    animId = requestAnimationFrame(draw);
  }

  // ---- Slider events ----
  velSlider.addEventListener('input', () => {
    beta = velSlider.value / 100;
    document.getElementById('twin-vel-label').textContent = beta.toFixed(2) + 'c';
    if (!running && !finished) updatePreview();
  });
  distSlider.addEventListener('input', () => {
    distLY = distSlider.value / 2;
    document.getElementById('twin-dist-label').textContent = distLY.toFixed(1) + ' ly';
    if (!running && !finished) updatePreview();
  });

  function updatePreview() {
    const { tTotalEarth, tTotalTraveler } = getTripStats();
    document.getElementById('tw-earth-time').textContent = tTotalEarth.toFixed(1) + ' yr (total)';
    document.getElementById('tw-trav-time').textContent = tTotalTraveler.toFixed(1) + ' yr (total)';
    document.getElementById('tw-diff').textContent = (tTotalEarth - tTotalTraveler).toFixed(1) + ' yr';
  }

  // ---- Controls ----
  playBtn.addEventListener('click', () => {
    if (finished) return;
    if (running) {
      running = false;
      playBtn.textContent = 'Resume';
    } else {
      running = true;
      playBtn.textContent = 'Pause';
    }
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    finished = false;
    simTime = 0;
    prevTs = null;
    playBtn.textContent = 'Launch Trip';
    document.getElementById('tw-earth-age').textContent = '30.0 yr';
    document.getElementById('tw-trav-age').textContent = '30.0 yr';
    document.getElementById('tw-earth-time').textContent = '0.0 yr';
    document.getElementById('tw-trav-time').textContent = '0.0 yr';
    document.getElementById('tw-diff').textContent = '0.0 yr';
    document.getElementById('tw-phase').textContent = 'Ready';
    updatePreview();
  });

  const speeds = [1, 2, 5, 10];
  let speedIdx = 0;
  speedBtn.addEventListener('click', () => {
    speedIdx = (speedIdx + 1) % speeds.length;
    simSpeed = speeds[speedIdx];
    speedBtn.innerHTML = 'Speed: ' + simSpeed + '&times;';
  });

  // Initialize
  updatePreview();
  requestAnimationFrame(draw);
})();

// ==================== COMBINED GRAPH ====================
(function initCombined() {
  const { ctx, w, h } = setupCanvas('combined-graph');
  const slider = document.getElementById('master-vel');
  let currentBeta = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);

    // Grid
    const maxY = 15;
    for (let i = 0; i <= maxY; i += 5) {
      const y = pad.t + gh - (i / maxY) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(i.toString(), pad.l - 8, y + 4);
    }
    for (let v = 0; v <= 1; v += 0.2) {
      const x = pad.l + v * gw;
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      ctx.fillText(v.toFixed(1) + 'c', x, pad.t + gh + 20);
    }

    // Curves
    const curves = [
      { fn: (b) => gamma(b), color: '#a855f7', label: 'γ (Lorentz)' },
      { fn: (b) => gamma(b), color: '#f59e0b', label: 'Time Dilation' },
      { fn: (b) => 1 / gamma(b), color: '#06b6d4', label: 'Length (1/γ)', maxVal: 1 },
      { fn: (b) => gamma(b), color: '#ef4444', label: 'Energy (γmc²)' },
    ];

    // Length contraction uses different scale (0-1 mapped to 0-1 on graph)
    curves.forEach((curve, ci) => {
      ctx.beginPath();
      ctx.strokeStyle = curve.color;
      ctx.lineWidth = 2;
      for (let i = 0; i <= 500; i++) {
        const b = (i / 500) * 0.999;
        let val = curve.fn(b);
        if (ci === 2) val = val * maxY; // scale length to fill graph
        const x = pad.l + b * gw;
        const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();
    });

    // Legend
    curves.forEach((curve, i) => {
      const lx = pad.l + 12;
      const ly = pad.t + 14 + i * 18;
      ctx.fillStyle = curve.color;
      ctx.fillRect(lx, ly - 4, 16, 3);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(curve.label, lx + 22, ly);
    });

    // Current velocity line
    if (currentBeta > 0) {
      const x = pad.l + currentBeta * gw;
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x, pad.t);
      ctx.lineTo(x, pad.t + gh);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 10000;
    const g = currentBeta > 0.001 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    document.getElementById('master-vel-label').textContent = currentBeta.toFixed(4) + 'c';
    document.getElementById('c-gamma').textContent = fmt(g);
    document.getElementById('c-time').innerHTML = fmt(g) + '&times;';
    document.getElementById('c-length').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('c-energy').textContent = fmt(g);
    draw();
  });

  draw();
})();

// ==================== ROUNDRECT POLYFILL ====================
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, radii) {
    const r = Array.isArray(radii) ? radii[0] : (radii || 0);
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
  };
}
</script>

</body>
</html>
