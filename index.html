<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Why Faster-Than-Light Travel Is Impossible</title>
<style>
  :root {
    --bg: #0a0e1a;
    --card: #111827;
    --border: #1e293b;
    --accent: #3b82f6;
    --accent2: #8b5cf6;
    --accent3: #06b6d4;
    --warn: #f59e0b;
    --danger: #ef4444;
    --text: #e2e8f0;
    --muted: #94a3b8;
    --dim: #475569;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    line-height: 1.6;
    overflow-x: hidden;
  }

  /* Starfield background */
  #starfield {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 0; pointer-events: none;
  }

  .content-wrap {
    position: relative; z-index: 1;
  }

  /* Hero */
  .hero {
    text-align: center;
    padding: 60px 20px 20px;
    background: linear-gradient(180deg, rgba(59,130,246,0.08) 0%, transparent 100%);
  }
  .hero h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 800;
    background: linear-gradient(135deg, #60a5fa, #a78bfa, #06b6d4);
    -webkit-background-clip: text; background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 16px;
    letter-spacing: -0.02em;
  }
  .hero p {
    color: var(--muted);
    font-size: 1.15rem;
    max-width: 680px;
    margin: 0 auto;
  }
  .hero .equation-hero {
    font-size: clamp(1.4rem, 3vw, 2.2rem);
    margin: 20px 0 0;
    font-family: 'Georgia', serif;
    font-style: italic;
    color: var(--accent3);
    text-shadow: 0 0 30px rgba(6,182,212,0.3);
  }

  /* Sections */
  section {
    max-width: 1100px;
    margin: 0 auto;
    padding: 40px 20px;
  }
  section h2 {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 8px;
    color: #f1f5f9;
  }
  section h2 .num {
    color: var(--accent);
    font-size: 0.9em;
    margin-right: 6px;
  }
  section > .subtitle {
    color: var(--muted);
    margin-bottom: 30px;
    font-size: 1.05rem;
  }

  /* Cards */
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 30px;
    margin-bottom: 24px;
  }
  .card h3 {
    font-size: 1.15rem;
    margin-bottom: 12px;
    color: #f1f5f9;
  }

  /* Canvas containers */
  .canvas-wrap {
    background: #080c16;
    border-radius: 12px;
    overflow: hidden;
    margin: 16px 0;
    position: relative;
  }
  .canvas-wrap canvas {
    display: block;
    width: 100%;
    height: auto;
  }

  /* Sliders */
  .slider-group {
    margin: 20px 0;
  }
  .slider-group label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 0.95rem;
  }
  .slider-group label .val {
    color: var(--accent3);
    font-family: 'Courier New', monospace;
    font-weight: 700;
  }
  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--border);
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px; height: 20px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(59,130,246,0.5);
    transition: transform 0.15s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  /* Readouts */
  .readouts {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin: 20px 0;
  }
  .readout {
    background: rgba(59,130,246,0.06);
    border: 1px solid rgba(59,130,246,0.15);
    border-radius: 10px;
    padding: 14px 16px;
    text-align: center;
  }
  .readout .label {
    font-size: 0.78rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 4px;
  }
  .readout .value {
    font-size: 1.4rem;
    font-weight: 700;
    font-family: 'Courier New', monospace;
  }
  .readout .value.blue { color: var(--accent); }
  .readout .value.cyan { color: var(--accent3); }
  .readout .value.purple { color: var(--accent2); }
  .readout .value.yellow { color: var(--warn); }
  .readout .value.red { color: var(--danger); }

  /* Derivation */
  .derivation {
    background: rgba(139,92,246,0.06);
    border: 1px solid rgba(139,92,246,0.15);
    border-radius: 12px;
    padding: 24px;
    margin: 20px 0;
  }
  .derivation h4 {
    color: var(--accent2);
    margin-bottom: 12px;
    font-size: 1rem;
  }
  .deriv-step {
    font-family: 'Georgia', serif;
    font-style: italic;
    font-size: 1.15rem;
    color: var(--text);
    padding: 8px 0;
    border-bottom: 1px solid rgba(139,92,246,0.1);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .deriv-step:last-child { border-bottom: none; }
  .deriv-step .step-num {
    font-family: system-ui; font-style: normal;
    background: var(--accent2);
    color: #fff;
    width: 26px; height: 26px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.75rem; font-weight: 700;
    flex-shrink: 0;
  }
  .deriv-step .annotation {
    font-family: system-ui; font-style: normal;
    font-size: 0.82rem;
    color: var(--muted);
    margin-left: auto;
  }

  /* Examples grid */
  .examples-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 16px;
  }
  .example-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 24px;
    transition: transform 0.2s, border-color 0.2s;
  }
  .example-card:hover {
    transform: translateY(-3px);
    border-color: var(--accent);
  }
  .example-card .icon {
    font-size: 2rem;
    margin-bottom: 10px;
  }
  .example-card h4 {
    font-size: 1.05rem;
    margin-bottom: 8px;
    color: #f1f5f9;
  }
  .example-card p {
    font-size: 0.9rem;
    color: var(--muted);
    line-height: 1.5;
  }
  .example-card .stat {
    margin-top: 12px;
    padding: 8px 12px;
    background: rgba(59,130,246,0.08);
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
    color: var(--accent3);
  }

  /* Tabs */
  .tab-bar {
    display: flex;
    gap: 4px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .tab-btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 8px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s;
  }
  .tab-btn:hover { border-color: var(--accent); color: var(--text); }
  .tab-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* Footer */
  footer {
    text-align: center;
    padding: 40px 20px 60px;
    color: var(--dim);
    font-size: 0.9rem;
  }

  /* Divider */
  .section-divider {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 20px;
  }
  .section-divider hr {
    border: none;
    border-top: 1px solid var(--border);
  }

  /* Clock comparison layout */
  .clock-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
  @media (max-width: 700px) {
    .clock-row { grid-template-columns: 1fr; }
  }
  .clock-label {
    text-align: center;
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 6px;
    color: var(--muted);
  }

  /* Explanation text */
  .explain {
    color: var(--muted);
    font-size: 0.92rem;
    line-height: 1.7;
    margin: 12px 0;
  }
  .explain strong { color: var(--text); }

  /* Spacetime diagram region labels */
  .st-legend {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin: 14px 0 6px;
  }
  .st-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
    color: var(--muted);
  }
  .st-legend-item .swatch {
    width: 14px; height: 14px;
    border-radius: 3px;
    flex-shrink: 0;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  /* Curvature section */
  #curvature-container canvas { display: block; border-radius: 12px; }
  #sec-curvature input[type="checkbox"] { accent-color: var(--accent); width: 16px; height: 16px; cursor: pointer; }
  #curv-tooltip { z-index: 10; backdrop-filter: blur(8px); }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>
</head>
<body>

<canvas id="starfield"></canvas>

<div class="content-wrap">

<!-- Hero -->
<header class="hero">
  <h1>Why Faster-Than-Light Travel Is Impossible</h1>
  <p>An interactive exploration of Einstein's Special Relativity, time dilation, and the cosmic speed limit.</p>
  <div class="equation-hero">E = mc&sup2;</div>
</header>

<!-- Section 1: Twin Paradox -->
<section id="sec-twins">
  <h2><span class="num">01</span> The Twin Paradox</h2>
  <p class="subtitle">One twin stays home. The other rockets to a star and back. When they reunite, the traveler is younger. This is real.</p>

  <div class="card">
    <p class="explain">
      The <strong>twin paradox</strong> is the most famous consequence of time dilation. Twin A stays on Earth.
      Twin B travels to a distant star at high speed, turns around, and returns. Because Twin B's clock
      runs slower during the trip, <strong>Twin B ages less</strong>. This isn't symmetric &mdash; Twin B
      <em>accelerated</em> (changed direction), breaking the symmetry between the two frames.
    </p>

    <div class="slider-group">
      <label>Travel velocity <span class="val" id="twin-vel-label">0.50c</span></label>
      <input type="range" id="twin-vel" min="10" max="99" value="50" step="1">
    </div>
    <div class="slider-group">
      <label>Destination distance <span class="val" id="twin-dist-label">5.0 ly</span></label>
      <input type="range" id="twin-dist" min="1" max="50" value="10" step="1">
    </div>

    <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
      <button id="twin-play" class="tab-btn active" style="flex:1;min-width:100px;">Launch Trip</button>
      <button id="twin-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
      <button id="twin-speed" class="tab-btn" style="flex:1;min-width:100px;">Speed: 1&times;</button>
    </div>

    <div class="canvas-wrap">
      <canvas id="twin-canvas" width="800" height="750"></canvas>
    </div>

    <div class="readouts" style="margin-top:16px;">
      <div class="readout">
        <div class="label">Earth Twin Age</div>
        <div class="value yellow" id="tw-earth-age">30.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Traveler Twin Age</div>
        <div class="value cyan" id="tw-trav-age">30.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Earth Time Elapsed</div>
        <div class="value blue" id="tw-earth-time">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Traveler Time Elapsed</div>
        <div class="value purple" id="tw-trav-time">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Age Difference</div>
        <div class="value red" id="tw-diff">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Trip Phase</div>
        <div class="value" id="tw-phase" style="color:var(--muted);">Ready</div>
      </div>
    </div>

    <p class="explain" style="margin-top:16px;">
      <strong>Why isn't this a paradox?</strong> From the rocket's frame, doesn't Earth's clock run slow too?
      Yes &mdash; during each constant-velocity leg, each twin sees the other's clock running slow.
      But the traveler <em>turns around</em> (accelerates), which is <strong>not</strong> an inertial frame change.
      The turnaround breaks the symmetry. In the spacetime diagram below, the traveler's worldline
      has a <strong>kink</strong> &mdash; it's a longer path through spacetime, but a <em>shorter</em> proper time.
      The straight worldline (staying home) always accumulates the most proper time between two events.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 02: Length Contraction -->
<section id="sec-contraction">
  <h2><span class="num">02</span> Length Contraction</h2>
  <p class="subtitle">Moving objects physically shrink along their direction of motion &mdash; watch a starship compress as it accelerates toward c.</p>

  <div class="card">
    <p class="explain">
      Just as time dilates, <strong>lengths contract</strong>. An object moving at velocity v is measured by a stationary
      observer to be shorter by a factor of 1/γ: <strong>L = L₀ / γ</strong>.
      At 0.87c the ship is half its rest length. At 0.99c it's compressed to just 14%. The ship's occupants
      notice nothing different about their own ship &mdash; instead, they see the <em>universe</em> contracted ahead of them.
    </p>

    <div class="slider-group">
      <label>Velocity <span class="val" id="lc-vel-label">0.00c</span></label>
      <input type="range" id="lc-vel" min="0" max="990" value="0" step="5">
    </div>

    <div class="canvas-wrap">
      <canvas id="lc-canvas" width="800" height="480"></canvas>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Length (L₀)</div>
        <div class="value blue" id="lc-rest">100.0 m</div>
      </div>
      <div class="readout">
        <div class="label">Observed Length (L)</div>
        <div class="value cyan" id="lc-obs">100.0 m</div>
      </div>
      <div class="readout">
        <div class="label">Contraction</div>
        <div class="value yellow" id="lc-pct">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">γ (Lorentz)</div>
        <div class="value purple" id="lc-gamma">1.000</div>
      </div>
    </div>

    <div style="display:flex;gap:12px;margin-top:8px;flex-wrap:wrap;">
      <button id="lc-flyby" class="tab-btn active" style="flex:1;min-width:140px;">Launch Fly-By</button>
      <button id="lc-flyby-reset" class="tab-btn" style="flex:1;min-width:140px;">Reset</button>
    </div>

    <p class="explain" style="margin-top:16px;">
      The <strong>top view</strong> shows the ship at rest for reference. The <strong>bottom view</strong> shows how a
      stationary observer measures the same ship as it flies past. Press <em>Launch Fly-By</em> to see
      contracted ships streak past the observation platform at your chosen speed. The ruler and grid
      stay fixed &mdash; only the ship contracts.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 03: Causality Violation -->
<section id="sec-causality">
  <h2><span class="num">03</span> Causality Violation &mdash; Why FTL Breaks Reality</h2>
  <p class="subtitle">FTL doesn't just break a speed limit &mdash; it lets you receive messages before they were sent, destroying cause and effect.</p>

  <div class="card">
    <p class="explain">
      The speed of light isn't an arbitrary speed limit &mdash; it's the boundary between <strong>cause</strong> and <strong>effect</strong>.
      In special relativity, different observers moving at different velocities disagree about <em>when</em> events happen.
      For events connected by light or slower signals, everyone agrees on the order. But for faster-than-light signals,
      some observers see the reply arrive <strong>before the message was sent</strong> &mdash; creating logical paradoxes
      that make FTL communication physically impossible.
    </p>

    <div class="tab-bar" id="causality-tabs">
      <button class="tab-btn active" data-tab="causality-simul">Simultaneity &amp; Light Cones</button>
      <button class="tab-btn" data-tab="causality-paradox">The Paradox</button>
    </div>

    <!-- Tab 1: Simultaneity & Light Cones -->
    <div id="causality-simul" class="tab-content active">
      <div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:8px;">
        <div class="slider-group" style="flex:1;min-width:200px;">
          <label>Observer velocity <span class="val" id="caus-vel-label">0.00c</span></label>
          <input type="range" id="caus-vel" min="0" max="95" value="0" step="1">
        </div>
        <div class="slider-group" style="flex:1;min-width:200px;">
          <label>FTL message speed <span class="val" id="caus-ftl-label">2.0c</span></label>
          <input type="range" id="caus-ftl" min="20" max="500" value="20" step="1">
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="causality-canvas" width="800" height="650"></canvas>
      </div>

      <div class="readouts">
        <div class="readout">
          <div class="label">Observer Velocity</div>
          <div class="value blue" id="cv-vel">0.00c</div>
        </div>
        <div class="readout">
          <div class="label">FTL Message Speed</div>
          <div class="value cyan" id="cv-ftl">2.0c</div>
        </div>
        <div class="readout">
          <div class="label">Earth Frame Arrival</div>
          <div class="value yellow" id="cv-earth-t">+2.19 yr</div>
        </div>
        <div class="readout">
          <div class="label">Moving Frame Arrival</div>
          <div class="value purple" id="cv-moving-t">+2.19 yr</div>
        </div>
        <div class="readout">
          <div class="label">Time Reversal</div>
          <div class="value red" id="cv-reversal">0 days</div>
        </div>
        <div class="readout">
          <div class="label">Causality</div>
          <div class="value" id="cv-status" style="color:#22c55e;">OK</div>
        </div>
      </div>

      <p class="explain">
        The Lorentz transformation tells us: <strong>t&prime; = &gamma;(t &minus; vx/c&sup2;)</strong>.
        For an FTL message traveling distance <em>d</em> at speed <em>s&middot;c</em>, the arrival time in the
        Earth frame is t = d/s. But a moving observer sees it arrive at t&prime; = &gamma;(d/s &minus; v&middot;d/c&sup2;).
        When <strong>v &gt; c/s</strong>, this goes <em>negative</em> &mdash; the message arrives before it was sent.
      </p>
    </div>

    <!-- Tab 2: The Paradox -->
    <div id="causality-paradox" class="tab-content">
      <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
        <button id="paradox-play" class="tab-btn active" style="flex:1;min-width:100px;">Play Scenario</button>
        <button id="paradox-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
        <button id="paradox-speed" class="tab-btn" style="flex:1;min-width:100px;">Speed: 1&times;</button>
      </div>

      <div class="canvas-wrap">
        <canvas id="paradox-canvas" width="800" height="650"></canvas>
      </div>

      <div class="readouts">
        <div class="readout">
          <div class="label">Earth Clock</div>
          <div class="value yellow" id="px-earth-t">T = 0.00 yr</div>
        </div>
        <div class="readout">
          <div class="label">Alpha Centauri Clock</div>
          <div class="value cyan" id="px-ac-t">T = 0.00 yr</div>
        </div>
        <div class="readout">
          <div class="label">Moving Frame Clock</div>
          <div class="value purple" id="px-moving-t">T&prime; = 0.00 yr</div>
        </div>
        <div class="readout">
          <div class="label">Phase</div>
          <div class="value" id="px-phase" style="color:var(--muted);">Ready</div>
        </div>
        <div class="readout">
          <div class="label">Message Content</div>
          <div class="value cyan" id="px-msg" style="font-size:1rem;">&mdash;</div>
        </div>
        <div class="readout">
          <div class="label">Paradox</div>
          <div class="value" id="px-paradox" style="color:#22c55e;">None yet</div>
        </div>
      </div>

      <p class="explain">
        <strong>The causal loop:</strong> Earth sends &ldquo;HELLO&rdquo; to Alpha Centauri at 2.185c.
        It arrives in 2 years (Earth frame), but an observer moving at 0.50c sees it arrive
        <strong>78 days in the past</strong>. Alpha Centauri replies at the same FTL speed.
        The reply reaches Earth <em>before</em> the original was sent. Now imagine the reply says
        &ldquo;DON&rsquo;T SEND&rdquo; &mdash; if you obey, the warning was never triggered. If you ignore it,
        the warning <em>was</em> triggered. Either way: <strong>paradox</strong>.
      </p>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 04: Spacetime Curvature -->
<section id="sec-curvature">
  <h2><span class="num">04</span> Spacetime Curvature in 3D</h2>
  <p class="subtitle">Mass warps spacetime. Objects follow the straightest possible paths through curved geometry &mdash; what we perceive as gravity.</p>

  <div class="card">
    <p class="explain">
      Einstein's <strong>General Relativity</strong> reveals that gravity isn't a force &mdash; it's the curvature of spacetime
      caused by mass and energy. A planet orbiting a star is simply following the straightest possible path (a <strong>geodesic</strong>)
      through warped spacetime. Place masses below to watch the fabric of spacetime deform, then drop test particles
      to see them follow curved geodesics.
    </p>

    <!-- Preset buttons -->
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin:16px 0 8px;">
      <button class="tab-btn active" id="curv-preset-earth" data-preset="earth">Earth</button>
      <button class="tab-btn" id="curv-preset-sun" data-preset="sun">Sun</button>
      <button class="tab-btn" id="curv-preset-bh" data-preset="blackhole">Black Hole</button>
      <button class="tab-btn" id="curv-preset-binary" data-preset="binary">Binary Stars</button>
      <button class="tab-btn" id="curv-clear" style="margin-left:auto;">Clear All</button>
    </div>

    <!-- View mode toggle -->
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;">
      <span style="color:var(--muted);font-size:0.85rem;line-height:2.2;">View:</span>
      <button class="tab-btn active" id="curv-view-2d">2D Sheet</button>
      <button class="tab-btn" id="curv-view-3d">3D Spherical</button>
    </div>

    <!-- Mode buttons -->
    <div style="display:flex;gap:8px;flex-wrap:wrap;margin:8px 0;">
      <button class="tab-btn active" id="curv-mode-place">Place Mass</button>
      <button class="tab-btn" id="curv-mode-drop">Drop Particle</button>
      <button class="tab-btn" id="curv-mode-orbit">Launch Orbit</button>
      <button class="tab-btn" id="curv-mode-rain">Rain Particles</button>
      <button class="tab-btn" id="curv-mode-orbits">Orbital Planes</button>
    </div>

    <!-- Toggles -->
    <div style="display:flex;gap:16px;flex-wrap:wrap;margin:12px 0;align-items:center;">
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.9rem;color:var(--muted);">
        <input type="checkbox" id="curv-cross-sections" checked> Show Cross-Sections
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.9rem;color:var(--muted);">
        <input type="checkbox" id="curv-straightness"> Show Geodesic Straightness
      </label>
      <label style="display:flex;align-items:center;gap:6px;cursor:pointer;font-size:0.9rem;color:var(--muted);">
        <input type="checkbox" id="curv-show-grid" checked> Show Grid
      </label>
    </div>

    <!-- Sliders -->
    <div style="display:flex;gap:16px;flex-wrap:wrap;">
      <div class="slider-group" style="flex:1;min-width:200px;">
        <label>Mass strength <span class="val" id="curv-mass-label">1.0</span></label>
        <input type="range" id="curv-mass-slider" min="1" max="100" value="10" step="1">
      </div>
      <div class="slider-group" style="flex:1;min-width:200px;">
        <label>Launch speed <span class="val" id="curv-speed-label">0.50</span></label>
        <input type="range" id="curv-launch-speed" min="1" max="100" value="50" step="1">
      </div>
    </div>

    <!-- Inclination slider (hidden until orbit/orbits mode) -->
    <div id="curv-inclination-group" style="display:none;margin-top:8px;">
      <div class="slider-group" style="min-width:200px;">
        <label>Orbital inclination <span class="val" id="curv-incl-label">0&deg;</span></label>
        <input type="range" id="curv-inclination" min="0" max="180" value="0" step="1">
      </div>
    </div>

    <!-- Orbital plane presets (hidden until orbits mode) -->
    <div id="curv-orbit-presets" style="display:none;gap:8px;flex-wrap:wrap;margin:8px 0;">
      <span style="color:var(--muted);font-size:0.85rem;line-height:2.2;">Demos:</span>
      <button class="tab-btn" id="curv-orbpreset-3plane">3-Plane Demo</button>
      <button class="tab-btn" id="curv-orbpreset-solar">Solar System</button>
      <button class="tab-btn" id="curv-orbpreset-globular">Globular Cluster</button>
    </div>
    <div id="curv-orbit-info" style="display:none;color:var(--muted);font-size:0.85rem;padding:4px 0;line-height:1.5;font-style:italic;"></div>

    <!-- Three.js container -->
    <div id="curvature-container" style="width:100%;height:600px;border-radius:12px;overflow:hidden;background:#060a14;position:relative;margin:16px 0;cursor:crosshair;">
      <div id="curv-tooltip" style="position:absolute;top:10px;right:10px;background:rgba(17,24,39,0.85);border:1px solid var(--border);border-radius:8px;padding:8px 12px;font-size:0.8rem;color:var(--muted);pointer-events:none;display:none;">
        <div>Potential: <span id="curv-tip-potential" style="color:var(--accent3);">--</span></div>
        <div>Time dilation: <span id="curv-tip-dilation" style="color:var(--accent);">--</span></div>
      </div>
    </div>

    <!-- Readouts -->
    <div class="readouts">
      <div class="readout">
        <div class="label">Masses Placed</div>
        <div class="value blue" id="curv-mass-count">0</div>
      </div>
      <div class="readout">
        <div class="label">Active Particles</div>
        <div class="value cyan" id="curv-particle-count">0</div>
      </div>
      <div class="readout">
        <div class="label">Particle Velocity</div>
        <div class="value purple" id="curv-particle-vel">0.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation (cursor)</div>
        <div class="value yellow" id="curv-dilation">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Orbital Period</div>
        <div class="value red" id="curv-orbit-period">&mdash;</div>
      </div>
    </div>

    <p class="explain">
      <strong>Gravity isn't &ldquo;downward&rdquo; &mdash; it's inward.</strong> The 2D sheet view shows the classic &ldquo;rubber sheet&rdquo; analogy,
      but this is misleading because it only shows curvature in one direction. Switch to <strong>3D Spherical</strong> view to see
      concentric shells of spacetime compressing equally in all directions around a mass. Use <strong>Rain Particles</strong>
      to drop test objects from above, below, and all sides &mdash; they all experience identical curvature.
      An orbiting planet isn't being &ldquo;pulled&rdquo; &mdash; it's following the straightest possible path (a <strong>geodesic</strong>)
      through warped spacetime.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 05: Photon Clocks -->
<section id="sec-clocks">
  <h2><span class="num">05</span> Photon Clock &amp; Time Dilation</h2>
  <p class="subtitle">A photon bouncing between two mirrors reveals how time itself slows for moving objects.</p>

  <div class="card">
    <p class="explain">
      A <strong>photon clock</strong> bounces a photon between two mirrors. At rest, the photon travels straight up and down.
      But when the clock moves, the photon must travel a longer diagonal path. Since light speed is constant (c),
      <strong>the moving clock ticks slower</strong> &mdash; this is time dilation.
    </p>

    <div class="slider-group">
      <label>Velocity <span class="val" id="clock-vel-label">0.00c</span></label>
      <input type="range" id="clock-vel" min="0" max="99" value="0" step="1">
    </div>

    <div class="clock-row">
      <div>
        <div class="clock-label">Stationary Clock</div>
        <div class="canvas-wrap">
          <canvas id="clock-rest" width="400" height="300"></canvas>
        </div>
      </div>
      <div>
        <div class="clock-label">Moving Clock (v = <span id="clock-v-display">0.00c</span>)</div>
        <div class="canvas-wrap">
          <canvas id="clock-moving" width="400" height="300"></canvas>
        </div>
      </div>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Velocity</div>
        <div class="value cyan" id="r-vel">0.00c</div>
      </div>
      <div class="readout">
        <div class="label">Lorentz Factor (γ)</div>
        <div class="value purple" id="r-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="r-dilation">1.000×</div>
      </div>
      <div class="readout">
        <div class="label">1 Earth Hour =</div>
        <div class="value blue" id="r-traveler">60.0 min</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 05b: Spacetime Diagram -->
<section id="sec-spacetime">
  <h2><span class="num">05b</span> Minkowski Spacetime Diagram</h2>
  <p class="subtitle">The geometry of the universe &mdash; why the speed of light divides spacetime into reachable and forever-unreachable regions.</p>

  <div class="card">
    <p class="explain">
      A <strong>spacetime diagram</strong> plots space (horizontal) against time (vertical, in units of ct).
      Light always travels at 45&deg; lines, forming the <strong>light cone</strong>. Any massive object's worldline
      must stay <em>inside</em> the cone (steeper than 45&deg;). To go faster than light would mean leaving
      the cone &mdash; entering a region where cause and effect break down.
    </p>

    <div class="slider-group">
      <label>Observer velocity <span class="val" id="st-vel-label">0.00c</span></label>
      <input type="range" id="st-vel" min="0" max="990" value="0" step="10">
    </div>

    <div class="canvas-wrap">
      <canvas id="spacetime-canvas" width="800" height="600"></canvas>
    </div>

    <div class="st-legend">
      <div class="st-legend-item"><span class="swatch" style="background:rgba(250,204,21,0.4)"></span> Future light cone (reachable)</div>
      <div class="st-legend-item"><span class="swatch" style="background:rgba(96,165,250,0.25)"></span> Spacelike region (FTL needed)</div>
      <div class="st-legend-item"><span class="swatch" style="background:#f59e0b"></span> Light (45&deg;, c)</div>
      <div class="st-legend-item"><span class="swatch" style="background:#06b6d4"></span> Object worldline</div>
      <div class="st-legend-item"><span class="swatch" style="background:#a855f7"></span> Simultaneity line (moving frame)</div>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Worldline angle</div>
        <div class="value cyan" id="st-angle">90.0&deg;</div>
      </div>
      <div class="readout">
        <div class="label">Light cone angle</div>
        <div class="value yellow" id="st-cone">45.0&deg;</div>
      </div>
      <div class="readout">
        <div class="label">Proper time ratio</div>
        <div class="value purple" id="st-proper">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Simultaneity tilt</div>
        <div class="value blue" id="st-simtilt">0.0&deg;</div>
      </div>
    </div>

    <p class="explain">
      As velocity increases, the worldline tilts toward the light cone and the <strong>simultaneity line</strong>
      (what the moving observer calls "now") tilts symmetrically. At v = c, both collapse onto the light cone.
      Beyond c, the worldline would enter the <strong>spacelike region</strong> &mdash; the object would arrive
      before it left in some reference frames, violating causality.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 06: Lorentz Factor -->
<section id="sec-lorentz">
  <h2><span class="num">06</span> The Lorentz Factor</h2>
  <p class="subtitle">The mathematical heart of special relativity &mdash; and why it blows up at light speed.</p>

  <div class="card">
    <div class="canvas-wrap">
      <canvas id="lorentz-graph" width="800" height="400"></canvas>
    </div>

    <div class="slider-group">
      <label>Explore velocity <span class="val" id="lorentz-vel-label">0.00c</span></label>
      <input type="range" id="lorentz-vel" min="0" max="999" value="0" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">v / c</div>
        <div class="value cyan" id="l-v">0.000</div>
      </div>
      <div class="readout">
        <div class="label">γ (Lorentz Factor)</div>
        <div class="value purple" id="l-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Length Contraction</div>
        <div class="value blue" id="l-length">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">Relativistic Mass</div>
        <div class="value yellow" id="l-mass">1.000× m₀</div>
      </div>
    </div>

    <div class="derivation">
      <h4>Derivation from the Photon Clock</h4>
      <div class="deriv-step">
        <span class="step-num">1</span>
        <span>Light path at rest: L = c&middot;t₀</span>
        <span class="annotation">straight up-down</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">2</span>
        <span>Light path moving: D = c&middot;t</span>
        <span class="annotation">diagonal path</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">3</span>
        <span>(c&middot;t)&sup2; = (v&middot;t)&sup2; + (c&middot;t₀)&sup2;</span>
        <span class="annotation">Pythagorean theorem</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">4</span>
        <span>c&sup2;t&sup2; &minus; v&sup2;t&sup2; = c&sup2;t₀&sup2;</span>
        <span class="annotation">rearrange</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">5</span>
        <span>t&sup2;(1 &minus; v&sup2;/c&sup2;) = t₀&sup2;</span>
        <span class="annotation">factor out t&sup2;</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">6</span>
        <span>t = t₀ / &radic;(1 &minus; v&sup2;/c&sup2;) = γ&middot;t₀</span>
        <span class="annotation">time dilation!</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">7</span>
        <span>γ = 1 / &radic;(1 &minus; v&sup2;/c&sup2;)</span>
        <span class="annotation">Lorentz factor</span>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 07: Energy -->
<section id="sec-energy">
  <h2><span class="num">07</span> The Infinite Energy Barrier</h2>
  <p class="subtitle">E = mc&sup2; is only the rest energy. The full picture shows why FTL requires infinite energy.</p>

  <div class="card">
    <div class="tab-bar">
      <button class="tab-btn active" data-tab="energy-ke">Kinetic Energy</button>
      <button class="tab-btn" data-tab="energy-total">Total Energy</button>
      <button class="tab-btn" data-tab="energy-momentum">Momentum</button>
    </div>

    <div id="energy-ke" class="tab-content active">
      <div class="canvas-wrap">
        <canvas id="ke-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain">
        Relativistic kinetic energy: <strong>KE = (γ - 1)mc&sup2;</strong>. As v approaches c, γ approaches infinity,
        so the energy needed grows without bound. No finite energy source can accelerate mass to light speed.
      </p>
    </div>

    <div id="energy-total" class="tab-content">
      <div class="canvas-wrap">
        <canvas id="total-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain">
        Total relativistic energy: <strong>E = γmc&sup2;</strong>. At rest (v=0), this reduces to E = mc&sup2;.
        The rest mass energy of a 1 kg object is <strong>9 × 10&sup1;&sup6; joules</strong> &mdash; equivalent to ~21 megatons of TNT.
      </p>
    </div>

    <div id="energy-momentum" class="tab-content">
      <div class="canvas-wrap">
        <canvas id="momentum-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain">
        Relativistic momentum: <strong>p = γmv</strong>. Unlike classical p = mv, this diverges as v &rarr; c.
        The energy-momentum relation: <strong>E&sup2; = (pc)&sup2; + (mc&sup2;)&sup2;</strong> unifies energy, momentum, and mass.
      </p>
    </div>

    <div class="slider-group">
      <label>Object velocity <span class="val" id="energy-vel-label">0.00c</span></label>
      <input type="range" id="energy-vel" min="0" max="999" value="0" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Energy (mc&sup2;)</div>
        <div class="value blue" id="e-rest">1.00</div>
      </div>
      <div class="readout">
        <div class="label">Kinetic Energy</div>
        <div class="value yellow" id="e-ke">0.00</div>
      </div>
      <div class="readout">
        <div class="label">Total Energy (γmc&sup2;)</div>
        <div class="value red" id="e-total">1.00</div>
      </div>
      <div class="readout">
        <div class="label">Momentum (γmv)</div>
        <div class="value purple" id="e-mom">0.00</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 08: Real-World Examples -->
<section id="sec-examples">
  <h2><span class="num">08</span> Real-World Evidence</h2>
  <p class="subtitle">Special relativity isn't just theory &mdash; we measure its effects every day.</p>

  <div class="examples-grid">
    <div class="example-card">
      <div class="icon">&#x1F6F0;</div>
      <h4>GPS Satellites</h4>
      <p>GPS satellites move at ~3.9 km/s. Without relativistic corrections, positioning would drift by ~11 km/day. Both special and general relativity corrections are applied.</p>
      <div class="stat">v = 0.0000130c | &Delta;t = 7 &mu;s/day (SR)</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x269B;</div>
      <h4>Muon Decay</h4>
      <p>Cosmic ray muons should decay in ~2.2&mu;s and travel only ~660m. But we detect them at sea level because time dilation at 0.998c extends their lifetime by ~15x.</p>
      <div class="stat">v = 0.998c | γ &asymp; 15.8 | range: ~10 km</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x1F500;</div>
      <h4>Particle Accelerators</h4>
      <p>At the LHC, protons reach 0.999999991c. Their relativistic mass is ~7,454 times rest mass. Each proton carries energy comparable to a flying mosquito &mdash; in a single subatomic particle.</p>
      <div class="stat">v = 0.999999991c | γ &asymp; 7,454</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x2B50;</div>
      <h4>Stellar Aberration</h4>
      <p>Stars appear slightly shifted due to Earth's orbital velocity (~30 km/s). This aberration angle matches relativistic predictions exactly, not Newtonian ones.</p>
      <div class="stat">v = 0.0001c | aberration &asymp; 20.5&quot;</div>
    </div>
  </div>

  <div class="card" style="margin-top: 24px;">
    <h3>Interactive: Muon Decay Simulation</h3>
    <p class="explain">Watch muons created at 15 km altitude travel toward Earth. At rest, they'd decay after ~660m. Time dilation lets them reach the surface.</p>
    <div class="canvas-wrap">
      <canvas id="muon-canvas" width="800" height="300"></canvas>
    </div>
    <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
      <button id="muon-start" class="tab-btn active" style="flex:1;min-width:120px;">Start Simulation</button>
      <button id="muon-reset" class="tab-btn" style="flex:1;min-width:120px;">Reset</button>
    </div>
    <div class="readouts" style="margin-top:16px;">
      <div class="readout">
        <div class="label">Classical Muons Surviving</div>
        <div class="value yellow" id="muon-classical">100%</div>
      </div>
      <div class="readout">
        <div class="label">Relativistic Muons Surviving</div>
        <div class="value cyan" id="muon-relativistic">100%</div>
      </div>
      <div class="readout">
        <div class="label">Altitude</div>
        <div class="value blue" id="muon-alt">15.0 km</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 09: Relativistic Mass & E=mc² -->
<section id="sec-emc2">
  <h2><span class="num">09</span> E = mc&sup2; and Mass-Energy Equivalence</h2>
  <p class="subtitle">Mass is frozen energy. Energy has inertia. This is why the speed limit exists.</p>

  <div class="card">
    <div class="canvas-wrap">
      <canvas id="emc2-graph" width="800" height="400"></canvas>
    </div>

    <div class="slider-group">
      <label>Mass (kg) <span class="val" id="mass-label">1.00 kg</span></label>
      <input type="range" id="mass-slider" min="1" max="100" value="1" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Energy</div>
        <div class="value cyan" id="emc2-rest">9.0 &times; 10&sup1;&sup6; J</div>
      </div>
      <div class="readout">
        <div class="label">Equivalent TNT</div>
        <div class="value yellow" id="emc2-tnt">21.5 MT</div>
      </div>
      <div class="readout">
        <div class="label">Could Power</div>
        <div class="value blue" id="emc2-power">A city for 2.9 years</div>
      </div>
    </div>

    <p class="explain" style="margin-top:16px;">
      <strong>Why does E = mc&sup2; create a speed limit?</strong> When you push an object, you add energy.
      That energy increases its inertia (resistance to further acceleration). The faster it goes,
      the more energy each additional m/s requires. Approaching c, the energy requirement
      diverges to infinity. The object's inertia becomes infinite before it can reach c.
      <br><br>
      Massless particles (photons) <em>must</em> travel at exactly c &mdash; they have no rest frame.
      Anything with mass is forever trapped below c.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 10: Speed comparison -->
<section id="sec-compare">
  <h2><span class="num">10</span> Putting It All Together</h2>
  <p class="subtitle">Adjust the velocity and watch all relativistic effects simultaneously.</p>

  <div class="card">
    <div class="slider-group">
      <label>Velocity <span class="val" id="master-vel-label">0.00c</span></label>
      <input type="range" id="master-vel" min="0" max="9999" value="0" step="1">
    </div>

    <div class="canvas-wrap">
      <canvas id="combined-graph" width="800" height="400"></canvas>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">γ (Lorentz)</div>
        <div class="value purple" id="c-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="c-time">1.000&times;</div>
      </div>
      <div class="readout">
        <div class="label">Length (% of rest)</div>
        <div class="value cyan" id="c-length">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">Energy (units mc&sup2;)</div>
        <div class="value red" id="c-energy">1.000</div>
      </div>
    </div>

    <p class="explain">
      The vertical dashed line marks your chosen velocity. Notice how <strong>all quantities diverge
      simultaneously</strong> as v &rarr; c. This isn't a coincidence &mdash; it's the geometry of spacetime itself.
      The speed of light isn't just a speed limit for light; it's woven into the fabric of the universe.
    </p>
  </div>
</section>

<footer>
  Built to illuminate the beauty of Einstein's Special Relativity
</footer>

</div><!-- /content-wrap -->

<script>
// ==================== UTILITIES ====================
const c = 299792458; // m/s
const gamma = (beta) => 1 / Math.sqrt(1 - beta * beta);
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp = (a, b, t) => a + (b - a) * t;

function fmt(n, d = 3) {
  if (n >= 1e18) return (n / 1e18).toFixed(1) + ' × 10¹⁸';
  if (n >= 1e16) return (n / 1e16).toFixed(1) + ' × 10¹⁶';
  if (n >= 1e12) return (n / 1e12).toFixed(1) + ' × 10¹²';
  if (n >= 1e9) return (n / 1e9).toFixed(1) + ' × 10⁹';
  if (n >= 1e6) return (n / 1e6).toFixed(1) + ' × 10⁶';
  if (n >= 1e4) return (n / 1e4).toFixed(1) + ' × 10⁴';
  if (n >= 100) return n.toFixed(1);
  if (n >= 10) return n.toFixed(2);
  return n.toFixed(d);
}

function setupCanvas(id) {
  const canvas = document.getElementById(id);
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = canvas.getAttribute('width') | 0;
  const h = canvas.getAttribute('height') | 0;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.maxWidth = '100%';
  canvas.style.height = 'auto';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { canvas, ctx, w, h };
}

// ==================== STARFIELD ====================
(function initStarfield() {
  const canvas = document.getElementById('starfield');
  const ctx = canvas.getContext('2d');
  let stars = [];
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    stars = Array.from({ length: 200 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      r: Math.random() * 1.5 + 0.3,
      a: Math.random() * 0.6 + 0.2,
      speed: Math.random() * 0.0005 + 0.0002,
      phase: Math.random() * Math.PI * 2
    }));
  }
  resize();
  window.addEventListener('resize', resize);
  function draw(t) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    stars.forEach(s => {
      const flicker = 0.5 + 0.5 * Math.sin(t * s.speed * 1000 + s.phase);
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,220,255,${s.a * flicker})`;
      ctx.fill();
    });
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

// ==================== PHOTON CLOCKS (smooth) ====================
(function initClocks() {
  const restC = setupCanvas('clock-rest');
  const moveC = setupCanvas('clock-moving');
  const slider = document.getElementById('clock-vel');
  let beta = 0;
  const mirrorGap = 180;
  const mirrorY1 = 50;
  const mirrorY2 = mirrorY1 + mirrorGap;
  const TRAIL_LEN = 18;

  // Trail buffers
  const restTrail = [];
  const moveTrail = [];

  // Mirror flash state (0-1, decays)
  let restFlash = 0, moveFlash = 0;
  let restLastDir = true, moveLastDir = true; // true = going down

  // Proper timestamps
  let prevTs = null;
  let accumTime = 0;

  function drawMirror(ctx, x, y, halfW, flash, color) {
    // Mirror body
    const grad = ctx.createLinearGradient(x - halfW, y - 3, x + halfW, y + 3);
    grad.addColorStop(0, '#1e293b');
    grad.addColorStop(0.5, '#334155');
    grad.addColorStop(1, '#1e293b');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(x - halfW, y - 3, halfW * 2, 6, 2);
    ctx.fill();
    // Reflective highlight
    ctx.strokeStyle = `rgba(148,163,184,${0.4 + flash * 0.6})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - halfW + 4, y);
    ctx.lineTo(x + halfW - 4, y);
    ctx.stroke();
    // Flash glow
    if (flash > 0.01) {
      const fg = ctx.createRadialGradient(x, y, 0, x, y, 40 * flash);
      fg.addColorStop(0, color.replace(')', `,${flash * 0.5})`).replace('rgb', 'rgba'));
      fg.addColorStop(1, 'transparent');
      ctx.fillStyle = fg;
      ctx.fillRect(x - 50, y - 50, 100, 100);
    }
  }

  function drawPhoton(ctx, x, y, color, trail, radius) {
    // Trail
    for (let i = 0; i < trail.length; i++) {
      const a = (i / trail.length) * 0.35;
      const r = (i / trail.length) * (radius || 4) * 0.8;
      ctx.beginPath();
      ctx.arc(trail[i].x, trail[i].y, r, 0, Math.PI * 2);
      ctx.fillStyle = color.replace(')', `,${a})`).replace('rgb', 'rgba');
      ctx.fill();
    }
    // Outer glow
    const g1 = ctx.createRadialGradient(x, y, 0, x, y, 18);
    g1.addColorStop(0, color.replace(')', ',0.4)').replace('rgb', 'rgba'));
    g1.addColorStop(0.5, color.replace(')', ',0.1)').replace('rgb', 'rgba'));
    g1.addColorStop(1, 'transparent');
    ctx.fillStyle = g1;
    ctx.fillRect(x - 20, y - 20, 40, 40);
    // Inner glow
    const g2 = ctx.createRadialGradient(x, y, 0, x, y, 8);
    g2.addColorStop(0, '#ffffff');
    g2.addColorStop(0.3, color);
    g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    // Core
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
  }

  function drawTicks(ctx, w, h, count, label, color) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, w / 2, h - 8);
    // Tick counter with color
    ctx.font = 'bold 18px Courier New';
    ctx.fillStyle = color;
    ctx.fillText(count, w / 2, h - 26);
    ctx.font = '10px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.fillText('ticks', w / 2 + 28, h - 24);
  }

  function drawPythagorean(ctx, topX, botX, alpha) {
    if (alpha < 0.02) return;
    const cx = (topX + botX) / 2;
    // Vertical leg (c·t₀)
    ctx.strokeStyle = `rgba(6,182,212,${alpha * 0.7})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.moveTo(cx, mirrorY1);
    ctx.lineTo(cx, mirrorY2);
    ctx.stroke();
    // Horizontal leg (v·t)
    ctx.strokeStyle = `rgba(245,158,11,${alpha * 0.7})`;
    ctx.beginPath();
    ctx.moveTo(cx, mirrorY2);
    ctx.lineTo(botX, mirrorY2);
    ctx.stroke();
    // Hypotenuse (c·t)
    ctx.strokeStyle = `rgba(168,85,247,${alpha * 0.9})`;
    ctx.setLineDash([]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(topX, mirrorY1);
    ctx.lineTo(botX, mirrorY2);
    ctx.stroke();
    ctx.setLineDash([]);
    // Labels
    ctx.font = 'italic 11px Georgia';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(6,182,212,${alpha})`;
    ctx.fillText('c·t₀', cx - 14, (mirrorY1 + mirrorY2) / 2 + 4);
    ctx.fillStyle = `rgba(245,158,11,${alpha})`;
    ctx.fillText('v·t', (cx + botX) / 2, mirrorY2 + 15);
    ctx.fillStyle = `rgba(168,85,247,${alpha})`;
    const hx = (topX + botX) / 2 + 14;
    const hy = (mirrorY1 + mirrorY2) / 2 - 6;
    ctx.fillText('c·t', hx, hy);
    // Right angle marker
    const sz = 8;
    ctx.strokeStyle = `rgba(100,116,139,${alpha * 0.6})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx + sz, mirrorY2);
    ctx.lineTo(cx + sz, mirrorY2 - sz);
    ctx.lineTo(cx, mirrorY2 - sz);
    ctx.stroke();
  }

  function animate(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50); // cap at 50ms to handle tab-switching
    prevTs = ts;
    accumTime += dt;

    const restPeriod = 1200;
    const g = beta > 0 ? gamma(beta) : 1;
    const movePeriod = restPeriod * g;

    const restTicks = Math.floor(accumTime / restPeriod);
    const moveTicks = Math.floor(accumTime / movePeriod);

    // --- Rest clock ---
    {
      const { ctx, w, h } = restC;
      ctx.clearRect(0, 0, w, h);
      const cx = w / 2;

      const phase = (accumTime % restPeriod) / restPeriod;
      const goingDown = phase < 0.5;
      const t = goingDown ? phase * 2 : (1 - phase) * 2;
      // Ease in-out for smoother bounce
      const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      const py = goingDown ? lerp(mirrorY1, mirrorY2, et) : lerp(mirrorY2, mirrorY1, et);

      // Flash on direction change
      if (goingDown !== restLastDir) {
        restFlash = 1;
        restLastDir = goingDown;
      }
      restFlash *= 0.9;

      // Vertical guide
      ctx.strokeStyle = 'rgba(71,85,105,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.beginPath();
      ctx.moveTo(cx, mirrorY1 + 6);
      ctx.lineTo(cx, mirrorY2 - 6);
      ctx.stroke();
      ctx.setLineDash([]);

      drawMirror(ctx, cx, mirrorY1, 35, goingDown ? 0 : restFlash, 'rgb(6,182,212)');
      drawMirror(ctx, cx, mirrorY2, 35, goingDown ? restFlash : 0, 'rgb(6,182,212)');

      // Update trail
      restTrail.push({ x: cx, y: py });
      if (restTrail.length > TRAIL_LEN) restTrail.shift();

      drawPhoton(ctx, cx, py, 'rgb(6,182,212)', restTrail);
      drawTicks(ctx, w, h, restTicks, 'Stationary Observer', '#06b6d4');
    }

    // --- Moving clock ---
    {
      const { ctx, w, h } = moveC;
      ctx.clearRect(0, 0, w, h);

      const phase = (accumTime % movePeriod) / movePeriod;
      const goingDown = phase < 0.5;
      const t = goingDown ? phase * 2 : (1 - phase) * 2;
      const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

      const drift = beta * 120;
      const cx = w / 2;
      const topX = cx - drift;
      const botX = cx + drift;
      const px = goingDown ? lerp(topX, botX, et) : lerp(botX, topX, et);
      const py = goingDown ? lerp(mirrorY1, mirrorY2, et) : lerp(mirrorY2, mirrorY1, et);

      if (goingDown !== moveLastDir) {
        moveFlash = 1;
        moveLastDir = goingDown;
      }
      moveFlash *= 0.9;

      // Pythagorean triangle (more visible at higher speeds)
      drawPythagorean(ctx, topX, botX, Math.min(beta * 2, 1));

      // Diagonal guide path
      ctx.strokeStyle = 'rgba(168,85,247,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.beginPath();
      ctx.moveTo(topX, mirrorY1);
      ctx.lineTo(botX, mirrorY2);
      ctx.moveTo(botX, mirrorY2);
      ctx.lineTo(topX, mirrorY1);
      ctx.stroke();
      ctx.setLineDash([]);

      drawMirror(ctx, topX, mirrorY1, 35, goingDown ? 0 : moveFlash, 'rgb(168,85,247)');
      drawMirror(ctx, botX, mirrorY2, 35, goingDown ? moveFlash : 0, 'rgb(168,85,247)');

      moveTrail.push({ x: px, y: py });
      if (moveTrail.length > TRAIL_LEN) moveTrail.shift();

      drawPhoton(ctx, px, py, 'rgb(168,85,247)', moveTrail);
      drawTicks(ctx, w, h, moveTicks, 'Moving Observer', '#a855f7');

      // Velocity arrow
      if (beta > 0.01) {
        const arrowY = mirrorY2 + 30;
        ctx.strokeStyle = 'rgba(245,158,11,0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx - 50, arrowY);
        ctx.lineTo(cx + 50, arrowY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + 50, arrowY);
        ctx.lineTo(cx + 42, arrowY - 4);
        ctx.moveTo(cx + 50, arrowY);
        ctx.lineTo(cx + 42, arrowY + 4);
        ctx.stroke();
        ctx.fillStyle = 'rgba(245,158,11,0.7)';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('v = ' + beta.toFixed(2) + 'c →', cx, arrowY - 8);
      }
    }

    requestAnimationFrame(animate);
  }

  slider.addEventListener('input', () => {
    beta = slider.value / 100;
    const g = beta > 0 ? gamma(beta) : 1;
    document.getElementById('clock-vel-label').textContent = beta.toFixed(2) + 'c';
    document.getElementById('clock-v-display').textContent = beta.toFixed(2) + 'c';
    document.getElementById('r-vel').textContent = beta.toFixed(2) + 'c';
    document.getElementById('r-gamma').textContent = fmt(g);
    document.getElementById('r-dilation').textContent = fmt(g) + '×';
    const travMinutes = 60 / g;
    document.getElementById('r-traveler').textContent = travMinutes.toFixed(1) + ' min';
  });

  requestAnimationFrame(animate);
})();

// ==================== SPACETIME DIAGRAM ====================
(function initSpacetime() {
  const { ctx, w, h } = setupCanvas('spacetime-canvas');
  const slider = document.getElementById('st-vel');
  let beta = 0;
  let animBeta = 0; // smoothly interpolated
  let animTime = 0;
  let prevTs = null;

  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;
    animTime += dt;

    // Smooth interpolation toward target beta
    animBeta += (beta - animBeta) * Math.min(1, dt * 0.008);

    ctx.clearRect(0, 0, w, h);
    const ox = w / 2;    // origin x
    const oy = h * 0.75; // origin y (lower part so more future visible)
    const scale = Math.min(w, h) * 0.33;

    // --- Background regions ---
    // Future light cone fill (timelike)
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(ox, oy - scale * 2.5);
    ctx.lineTo(ox + scale * 1.8, oy - scale * 1.8);
    ctx.closePath();
    ctx.fillStyle = 'rgba(250,204,21,0.06)';
    ctx.fill();

    // Past light cone fill
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.2, oy + scale * 1.2);
    ctx.lineTo(ox, oy + scale * 1.6);
    ctx.lineTo(ox + scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(250,204,21,0.03)';
    ctx.fill();

    // Spacelike regions (left and right of cone)
    ctx.fillStyle = 'rgba(96,165,250,0.03)';
    // Left spacelike
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(0, oy);
    ctx.lineTo(ox - scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fill();
    // Right spacelike
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox + scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(w, oy);
    ctx.lineTo(ox + scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fill();

    // --- Grid ---
    ctx.strokeStyle = 'rgba(30,41,59,0.6)';
    ctx.lineWidth = 0.5;
    for (let i = -5; i <= 5; i++) {
      // Vertical grid (space)
      const gx = ox + i * scale * 0.4;
      ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
      // Horizontal grid (time)
      const gy = oy + i * scale * 0.4;
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }

    // --- Axes ---
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    // Space axis (x)
    ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(w, oy); ctx.stroke();
    // Time axis (ct)
    ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, h); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('x (space)', w - 10, oy - 10);
    ctx.textAlign = 'center';
    ctx.fillText('ct (time)', ox + 28, 18);

    // Axis arrows
    ctx.fillStyle = '#475569';
    ctx.beginPath();
    ctx.moveTo(ox, 4); ctx.lineTo(ox - 5, 14); ctx.lineTo(ox + 5, 14);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(w - 4, oy); ctx.lineTo(w - 14, oy - 5); ctx.lineTo(w - 14, oy + 5);
    ctx.closePath(); ctx.fill();

    // --- Light cone lines (45°) ---
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    // Future
    ctx.beginPath();
    ctx.moveTo(ox - scale * 2, oy - scale * 2);
    ctx.lineTo(ox, oy);
    ctx.lineTo(ox + scale * 2, oy - scale * 2);
    ctx.stroke();
    // Past
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.moveTo(ox - scale * 1.5, oy + scale * 1.5);
    ctx.lineTo(ox, oy);
    ctx.lineTo(ox + scale * 1.5, oy + scale * 1.5);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Light cone label
    ctx.fillStyle = '#f59e0b';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('v = c', ox + scale * 0.9 + 4, oy - scale * 0.9 - 4);
    ctx.textAlign = 'right';
    ctx.fillText('v = c', ox - scale * 0.9 - 4, oy - scale * 0.9 - 4);

    // --- Region labels ---
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(250,204,21,0.4)';
    ctx.fillText('FUTURE', ox, oy - scale * 1.1);
    ctx.fillText('(timelike)', ox, oy - scale * 1.1 + 15);
    ctx.fillStyle = 'rgba(250,204,21,0.25)';
    ctx.fillText('PAST', ox, oy + scale * 0.55);
    ctx.fillStyle = 'rgba(96,165,250,0.35)';
    ctx.fillText('SPACELIKE', ox + scale * 1.1, oy - scale * 0.15);
    ctx.font = '10px system-ui';
    ctx.fillText('(FTL needed)', ox + scale * 1.1, oy);
    ctx.fillStyle = 'rgba(96,165,250,0.35)';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('SPACELIKE', ox - scale * 1.1, oy - scale * 0.15);
    ctx.font = '10px system-ui';
    ctx.fillText('(FTL needed)', ox - scale * 1.1, oy);

    // --- Object worldline ---
    const b = animBeta;
    const wlLen = scale * 2;
    // Worldline: dx/d(ct) = v/c = beta, so for ct units up, x = beta * ct
    const wlEndX = ox + b * wlLen;
    const wlEndY = oy - wlLen;

    // Worldline glow
    ctx.strokeStyle = 'rgba(6,182,212,0.15)';
    ctx.lineWidth = 8;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();
    ctx.strokeStyle = 'rgba(6,182,212,0.3)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();
    // Worldline core
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();

    // Arrowhead on worldline
    const wlAngle = Math.atan2(wlEndY - oy, wlEndX - ox);
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.moveTo(wlEndX, wlEndY);
    ctx.lineTo(wlEndX - 10 * Math.cos(wlAngle - 0.3), wlEndY - 10 * Math.sin(wlAngle - 0.3));
    ctx.lineTo(wlEndX - 10 * Math.cos(wlAngle + 0.3), wlEndY - 10 * Math.sin(wlAngle + 0.3));
    ctx.closePath(); ctx.fill();

    // Worldline label
    ctx.fillStyle = '#06b6d4';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    const lblOff = b > 0.3 ? -16 : 8;
    ctx.fillText('worldline', wlEndX + 8, wlEndY + lblOff);
    ctx.font = '11px system-ui';
    ctx.fillText('v = ' + b.toFixed(2) + 'c', wlEndX + 8, wlEndY + lblOff + 15);

    // --- Simultaneity line (tilted "now" for moving observer) ---
    // In Minkowski diagram, the simultaneity line tilts at angle arctan(v/c) from x-axis
    if (b > 0.01) {
      const simLen = scale * 1.5;
      const simEndX = ox + simLen;
      const simEndY = oy - b * simLen;
      const simStartX = ox - simLen;
      const simStartY = oy + b * simLen;

      ctx.strokeStyle = 'rgba(168,85,247,0.2)';
      ctx.lineWidth = 6;
      ctx.beginPath(); ctx.moveTo(simStartX, simStartY); ctx.lineTo(simEndX, simEndY); ctx.stroke();
      ctx.strokeStyle = '#a855f7';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath(); ctx.moveTo(simStartX, simStartY); ctx.lineTo(simEndX, simEndY); ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#a855f7';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('"now" (moving frame)', simEndX + 6, simEndY - 4);
    }

    // --- Animated photon on the light cone ---
    const photonPhase = (animTime % 3000) / 3000;
    const photonDist = photonPhase * scale * 1.5;
    const ppx = ox + photonDist;
    const ppy = oy - photonDist;
    // Right-going photon
    const pg = ctx.createRadialGradient(ppx, ppy, 0, ppx, ppy, 6);
    pg.addColorStop(0, '#fbbf24');
    pg.addColorStop(1, 'transparent');
    ctx.fillStyle = pg;
    ctx.fillRect(ppx - 8, ppy - 8, 16, 16);
    ctx.beginPath(); ctx.arc(ppx, ppy, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fef3c7'; ctx.fill();
    // Left-going photon
    const ppx2 = ox - photonDist;
    const ppy2 = oy - photonDist;
    const pg2 = ctx.createRadialGradient(ppx2, ppy2, 0, ppx2, ppy2, 6);
    pg2.addColorStop(0, '#fbbf24');
    pg2.addColorStop(1, 'transparent');
    ctx.fillStyle = pg2;
    ctx.fillRect(ppx2 - 8, ppy2 - 8, 16, 16);
    ctx.beginPath(); ctx.arc(ppx2, ppy2, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fef3c7'; ctx.fill();

    // --- Proper time tick marks along worldline ---
    if (b > 0.01) {
      const g = gamma(Math.min(b, 0.999));
      const tickSpacing = scale * 0.3;
      const numTicks = Math.floor(wlLen / tickSpacing);
      const perpAngle = wlAngle + Math.PI / 2;
      ctx.strokeStyle = 'rgba(6,182,212,0.5)';
      ctx.lineWidth = 1;
      for (let i = 1; i <= numTicks; i++) {
        const frac = (i * tickSpacing) / wlLen;
        const tx = lerp(ox, wlEndX, frac);
        const ty = lerp(oy, wlEndY, frac);
        ctx.beginPath();
        ctx.moveTo(tx - 5 * Math.cos(perpAngle), ty - 5 * Math.sin(perpAngle));
        ctx.lineTo(tx + 5 * Math.cos(perpAngle), ty + 5 * Math.sin(perpAngle));
        ctx.stroke();
      }
      // Corresponding coordinate-time ticks on ct axis
      ctx.strokeStyle = 'rgba(148,163,184,0.3)';
      for (let i = 1; i <= numTicks; i++) {
        const frac = (i * tickSpacing) / wlLen;
        const ty = oy - frac * wlLen;
        ctx.beginPath();
        ctx.moveTo(ox - 5, ty);
        ctx.lineTo(ox + 5, ty);
        ctx.stroke();
      }
    }

    // --- Origin event dot ---
    ctx.beginPath();
    ctx.arc(ox, oy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#f1f5f9';
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('event (here, now)', ox - 10, oy + 4);

    requestAnimationFrame(draw);
  }

  slider.addEventListener('input', () => {
    beta = slider.value / 1000;
    const b = Math.min(beta, 0.999);
    document.getElementById('st-vel-label').textContent = beta.toFixed(2) + 'c';

    // Worldline angle from space axis: angle = arctan(ct / x) = arctan(1/beta)
    // From vertical (ct axis): theta = arctan(beta)
    const wlAngleDeg = beta > 0.001 ? Math.atan(1 / beta) * 180 / Math.PI : 90;
    document.getElementById('st-angle').innerHTML = wlAngleDeg.toFixed(1) + '&deg;';
    document.getElementById('st-cone').innerHTML = '45.0&deg;';

    const g = beta > 0.001 ? gamma(b) : 1;
    document.getElementById('st-proper').textContent = (1 / g).toFixed(3);

    const simTilt = Math.atan(beta) * 180 / Math.PI;
    document.getElementById('st-simtilt').innerHTML = simTilt.toFixed(1) + '&deg;';
  });

  requestAnimationFrame(draw);
})();

// ==================== LORENTZ GRAPH ====================
(function initLorentz() {
  const { ctx, w, h } = setupCanvas('lorentz-graph');
  const slider = document.getElementById('lorentz-vel');
  let currentBeta = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);
    ctx.save();
    ctx.translate(16, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('γ (Lorentz Factor)', 0, 0);
    ctx.restore();

    // Grid + tick marks
    const maxGamma = 20;
    for (let g = 0; g <= maxGamma; g += 5) {
      const y = pad.t + gh - (g / maxGamma) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(g.toString(), pad.l - 8, y + 4);
    }
    for (let v = 0; v <= 1; v += 0.2) {
      const x = pad.l + v * gw;
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      ctx.fillText(v.toFixed(1) + 'c', x, pad.t + gh + 20);
    }

    // Curve
    ctx.beginPath();
    ctx.strokeStyle = '#a855f7';
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 500; i++) {
      const b = (i / 500) * 0.999;
      const g = gamma(b);
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(g, maxGamma) / maxGamma) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Asymptote at v=c
    ctx.strokeStyle = 'rgba(239,68,68,0.5)';
    ctx.setLineDash([6, 4]);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pad.l + gw, pad.t);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('v = c (impossible for mass)', pad.l + gw - 6, pad.t + 16);

    // Current point
    if (currentBeta > 0) {
      const g = gamma(Math.min(currentBeta, 0.9999));
      const x = pad.l + currentBeta * gw;
      const y = pad.t + gh - (Math.min(g, maxGamma) / maxGamma) * gh;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(6,182,212,0.4)';
      ctx.beginPath();
      ctx.moveTo(x, pad.t + gh);
      ctx.lineTo(x, y);
      ctx.lineTo(pad.l, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.fillStyle = '#06b6d4';
      ctx.fill();
      ctx.strokeStyle = '#0e7490';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 1000;
    const g = currentBeta > 0 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    document.getElementById('lorentz-vel-label').textContent = currentBeta.toFixed(3) + 'c';
    document.getElementById('l-v').textContent = currentBeta.toFixed(3);
    document.getElementById('l-gamma').textContent = fmt(g);
    document.getElementById('l-length').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('l-mass').textContent = fmt(g) + '× m₀';
    draw();
  });

  draw();
})();

// ==================== LENGTH CONTRACTION ====================
(function initContraction() {
  const { ctx, w, h } = setupCanvas('lc-canvas');
  const slider = document.getElementById('lc-vel');
  const flybyBtn = document.getElementById('lc-flyby');
  const flybyResetBtn = document.getElementById('lc-flyby-reset');

  let beta = 0;
  let prevTs = null;

  // Fly-by state
  let flybyActive = false;
  let flybyShips = []; // {x, beta, color}

  const REST_LEN = 100; // meters (conceptual)
  const SHIP_PX_REST = 280; // pixels at rest
  const topY = 10;       // top view area
  const midY = h / 2 - 10;  // divider
  const botY = h / 2 + 10;  // bottom view area
  const viewH = h / 2 - 20;

  // --- Ship drawing ---
  function drawShip(ctx, cx, cy, lengthPx, heightPx, color, label, faded) {
    const hw = lengthPx / 2;
    const hh = heightPx / 2;
    const alpha = faded ? 0.25 : 1;

    ctx.globalAlpha = alpha;

    // Engine glow (rear)
    if (!faded && beta > 0.01) {
      const eg = ctx.createRadialGradient(cx - hw - 4, cy, 0, cx - hw - 4, cy, hh * 1.8);
      eg.addColorStop(0, 'rgba(6,182,212,0.25)');
      eg.addColorStop(1, 'transparent');
      ctx.fillStyle = eg;
      ctx.fillRect(cx - hw - hh * 2, cy - hh * 2, hh * 4, hh * 4);
    }

    // Hull body
    ctx.beginPath();
    ctx.moveTo(cx + hw, cy);                          // nose tip
    ctx.lineTo(cx + hw * 0.65, cy - hh);              // top front
    ctx.lineTo(cx - hw * 0.6, cy - hh);               // top rear
    ctx.lineTo(cx - hw, cy - hh * 0.5);               // engine top
    ctx.lineTo(cx - hw, cy + hh * 0.5);               // engine bottom
    ctx.lineTo(cx - hw * 0.6, cy + hh);               // bottom rear
    ctx.lineTo(cx + hw * 0.65, cy + hh);              // bottom front
    ctx.closePath();

    const hGrad = ctx.createLinearGradient(cx, cy - hh, cx, cy + hh);
    hGrad.addColorStop(0, color);
    hGrad.addColorStop(0.4, lightenColor(color, 40));
    hGrad.addColorStop(1, darkenColor(color, 40));
    ctx.fillStyle = hGrad;
    ctx.fill();
    ctx.strokeStyle = lightenColor(color, 60);
    ctx.lineWidth = 1;
    ctx.stroke();

    // Cockpit window
    const winW = Math.max(lengthPx * 0.12, 6);
    const winH = Math.max(heightPx * 0.35, 4);
    ctx.beginPath();
    ctx.ellipse(cx + hw * 0.4, cy, winW / 2, winH / 2, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(6,182,212,0.6)';
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.beginPath();
    ctx.ellipse(cx + hw * 0.4 - 1, cy - 1, winW * 0.25, winH * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Engine nozzles
    const nozW = Math.max(lengthPx * 0.04, 3);
    ctx.fillStyle = '#475569';
    for (let n = -1; n <= 1; n += 2) {
      ctx.fillRect(cx - hw - nozW, cy + n * hh * 0.25 - nozW / 2, nozW, nozW);
    }

    // Hull detail lines
    ctx.strokeStyle = lightenColor(color, 30) + '66';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
      const lx = cx - hw * 0.6 + (i / 4) * lengthPx * 0.8;
      ctx.beginPath();
      ctx.moveTo(lx, cy - hh + 2);
      ctx.lineTo(lx, cy + hh - 2);
      ctx.stroke();
    }

    // Nacelles / wings
    const wingSpan = hh * 1.5;
    ctx.fillStyle = darkenColor(color, 20);
    // Top wing
    ctx.beginPath();
    ctx.moveTo(cx - hw * 0.2, cy - hh);
    ctx.lineTo(cx - hw * 0.5, cy - wingSpan);
    ctx.lineTo(cx - hw * 0.7, cy - wingSpan);
    ctx.lineTo(cx - hw * 0.5, cy - hh);
    ctx.closePath();
    ctx.fill();
    // Bottom wing
    ctx.beginPath();
    ctx.moveTo(cx - hw * 0.2, cy + hh);
    ctx.lineTo(cx - hw * 0.5, cy + wingSpan);
    ctx.lineTo(cx - hw * 0.7, cy + wingSpan);
    ctx.lineTo(cx - hw * 0.5, cy + hh);
    ctx.closePath();
    ctx.fill();

    // Wing-tip engines
    if (lengthPx > 40) {
      ctx.fillStyle = '#94a3b8';
      ctx.beginPath();
      ctx.ellipse(cx - hw * 0.6, cy - wingSpan, nozW * 1.2, nozW * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - hw * 0.6, cy + wingSpan, nozW * 1.2, nozW * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;

    // Label
    if (label) {
      ctx.fillStyle = faded ? '#475569' : '#e2e8f0';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, cy + hh * 1.5 + 22);
    }
  }

  function lightenColor(hex, amount) {
    const r = Math.min(255, parseInt(hex.slice(1,3), 16) + amount);
    const g = Math.min(255, parseInt(hex.slice(3,5), 16) + amount);
    const b = Math.min(255, parseInt(hex.slice(5,7), 16) + amount);
    return `rgb(${r},${g},${b})`;
  }
  function darkenColor(hex, amount) {
    const r = Math.max(0, parseInt(hex.slice(1,3), 16) - amount);
    const g = Math.max(0, parseInt(hex.slice(3,5), 16) - amount);
    const b = Math.max(0, parseInt(hex.slice(5,7), 16) - amount);
    return `rgb(${r},${g},${b})`;
  }

  // --- Ruler ---
  function drawRuler(ctx, x, y, totalPx, label, segments) {
    const segW = totalPx / segments;
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.fillStyle = '#64748b';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    // Main line
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + totalPx, y);
    ctx.stroke();
    // Ticks
    for (let i = 0; i <= segments; i++) {
      const tx = x + i * segW;
      const major = i % 2 === 0;
      ctx.beginPath();
      ctx.moveTo(tx, y - (major ? 6 : 3));
      ctx.lineTo(tx, y + (major ? 6 : 3));
      ctx.stroke();
      if (major) {
        ctx.fillText(Math.round(i * REST_LEN / segments) + '', tx, y + 16);
      }
    }
    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.fillText(label, x + totalPx / 2, y - 12);
  }

  // --- Dimension bracket ---
  function drawBracket(ctx, x1, x2, y, label, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    const bh = 6;
    ctx.beginPath();
    ctx.moveTo(x1, y - bh); ctx.lineTo(x1, y); ctx.lineTo(x2, y); ctx.lineTo(x2, y - bh);
    ctx.stroke();
    // Arrow heads
    ctx.beginPath();
    ctx.moveTo(x1 + 5, y - 2); ctx.lineTo(x1, y); ctx.lineTo(x1 + 5, y + 2);
    ctx.moveTo(x2 - 5, y - 2); ctx.lineTo(x2, y); ctx.lineTo(x2 - 5, y + 2);
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, (x1 + x2) / 2, y + 15);
  }

  // --- Grid ---
  function drawGrid(ctx, x, y, gw, gh, cellSize) {
    ctx.strokeStyle = 'rgba(30,41,59,0.5)';
    ctx.lineWidth = 0.5;
    for (let gx = 0; gx <= gw; gx += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x + gx, y);
      ctx.lineTo(x + gx, y + gh);
      ctx.stroke();
    }
    for (let gy = 0; gy <= gh; gy += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x, y + gy);
      ctx.lineTo(x + gw, y + gy);
      ctx.stroke();
    }
  }

  // --- Main animation ---
  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;

    const g = beta > 0.001 ? gamma(Math.min(beta, 0.999)) : 1;
    const contractedPx = SHIP_PX_REST / g;
    const contractedM = REST_LEN / g;

    ctx.clearRect(0, 0, w, h);

    const cx = w / 2;

    // ===== TOP: Rest frame =====
    const topCenterY = topY + viewH / 2;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, topY, w, viewH);

    // Grid
    drawGrid(ctx, cx - SHIP_PX_REST / 2 - 40, topY + 10, SHIP_PX_REST + 80, viewH - 20, 28);

    // Section label
    ctx.fillStyle = 'rgba(148,163,184,0.3)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('REST FRAME (v = 0)', 14, topY + 22);

    // Rest ship
    drawShip(ctx, cx, topCenterY, SHIP_PX_REST, 50, '#3b82f6', null, false);

    // Ruler above
    drawRuler(ctx, cx - SHIP_PX_REST / 2, topY + 24, SHIP_PX_REST, 'Rest length (m)', 10);

    // Bracket below
    drawBracket(ctx, cx - SHIP_PX_REST / 2, cx + SHIP_PX_REST / 2, topCenterY + 46,
      'L₀ = ' + REST_LEN.toFixed(0) + ' m', '#3b82f6');

    // ===== DIVIDER =====
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, midY);
    ctx.lineTo(w - 20, midY);
    ctx.stroke();
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('— as seen by stationary observer —', cx, midY + 4);

    // ===== BOTTOM: Observer's frame =====
    const botCenterY = botY + viewH / 2;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, botY + 8, w, viewH);

    // Grid (same spacing as top — shows contraction against fixed reference)
    drawGrid(ctx, cx - SHIP_PX_REST / 2 - 40, botY + 18, SHIP_PX_REST + 80, viewH - 20, 28);

    // Section label
    ctx.fillStyle = 'rgba(148,163,184,0.3)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('OBSERVER FRAME (v = ' + beta.toFixed(2) + 'c)', 14, botY + 30);

    // Ghost rest-length outline (faded)
    if (beta > 0.01) {
      drawShip(ctx, cx, botCenterY, SHIP_PX_REST, 50, '#3b82f6', null, true);
    }

    // Contracted ship
    const shipH = 50;
    drawShip(ctx, cx, botCenterY, contractedPx, shipH, '#06b6d4', null, false);

    // Ruler (same total width as rest ruler for comparison)
    drawRuler(ctx, cx - SHIP_PX_REST / 2, botY + 32, SHIP_PX_REST, 'Observer\'s ruler (m)', 10);

    // Bracket below contracted ship
    drawBracket(ctx, cx - contractedPx / 2, cx + contractedPx / 2, botCenterY + 46,
      'L = ' + contractedM.toFixed(1) + ' m (' + (100 / g).toFixed(1) + '%)', '#06b6d4');

    // Contraction arrows (showing squeeze)
    if (beta > 0.05) {
      const restHalf = SHIP_PX_REST / 2;
      const conHalf = contractedPx / 2;
      ctx.strokeStyle = 'rgba(239,68,68,0.5)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([3, 3]);
      // Left
      ctx.beginPath();
      ctx.moveTo(cx - restHalf, botCenterY - shipH * 0.8);
      ctx.lineTo(cx - conHalf, botCenterY - shipH * 0.3);
      ctx.stroke();
      // Right
      ctx.beginPath();
      ctx.moveTo(cx + restHalf, botCenterY - shipH * 0.8);
      ctx.lineTo(cx + conHalf, botCenterY - shipH * 0.3);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ===== FLY-BY ANIMATION =====
    if (flybyActive) {
      flybyShips.forEach(ship => {
        ship.x += ship.speed * dt;
      });
      // Remove off-screen ships
      flybyShips = flybyShips.filter(s => s.x < w + 200);

      // Draw fly-by ships in a strip between sections
      flybyShips.forEach(ship => {
        const sg = ship.beta > 0.001 ? gamma(Math.min(ship.beta, 0.999)) : 1;
        const sLen = 120 / sg;
        const sH = 22;
        const sy = midY;

        // Motion blur trail
        const trailLen = ship.beta * 80;
        const tGrad = ctx.createLinearGradient(ship.x - sLen / 2 - trailLen, sy, ship.x - sLen / 2, sy);
        tGrad.addColorStop(0, 'transparent');
        tGrad.addColorStop(1, ship.color + '44');
        ctx.fillStyle = tGrad;
        ctx.fillRect(ship.x - sLen / 2 - trailLen, sy - sH, trailLen, sH * 2);

        drawShip(ctx, ship.x, sy, sLen, sH, ship.color, null, false);

        // Velocity label
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(ship.beta.toFixed(2) + 'c', ship.x, sy - sH - 6);
      });

      // Spawn new ships periodically
      if (flybyShips.length === 0 || (flybyShips.length < 4 && flybyShips[flybyShips.length - 1].x > 80)) {
        const speeds = [0.1, 0.5, 0.8, 0.95];
        const colors = ['#22c55e', '#3b82f6', '#a855f7', '#ef4444'];
        if (flybyShips.length < speeds.length) {
          const idx = flybyShips.length;
          flybyShips.push({
            x: -180,
            beta: speeds[idx],
            speed: (0.15 + speeds[idx] * 0.35),
            color: colors[idx]
          });
        }
      }
    }

    // Formula overlay
    ctx.fillStyle = 'rgba(17,24,39,0.7)';
    ctx.beginPath();
    ctx.roundRect(w - 200, h - 40, 190, 30, 6);
    ctx.fill();
    ctx.fillStyle = '#a855f7';
    ctx.font = 'italic 14px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('L = L₀ / γ = L₀ √(1 − v²/c²)', w - 105, h - 20);

    requestAnimationFrame(draw);
  }

  // --- Slider ---
  slider.addEventListener('input', () => {
    beta = slider.value / 1000;
    const g = beta > 0.001 ? gamma(Math.min(beta, 0.999)) : 1;
    const contractedM = REST_LEN / g;
    document.getElementById('lc-vel-label').textContent = beta.toFixed(2) + 'c';
    document.getElementById('lc-rest').textContent = REST_LEN.toFixed(1) + ' m';
    document.getElementById('lc-obs').textContent = contractedM.toFixed(1) + ' m';
    document.getElementById('lc-pct').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('lc-gamma').textContent = fmt(g);
  });

  // --- Fly-by controls ---
  flybyBtn.addEventListener('click', () => {
    flybyActive = !flybyActive;
    flybyBtn.textContent = flybyActive ? 'Stop Fly-By' : 'Launch Fly-By';
    if (flybyActive) flybyShips = [];
  });
  flybyResetBtn.addEventListener('click', () => {
    flybyActive = false;
    flybyShips = [];
    flybyBtn.textContent = 'Launch Fly-By';
  });

  requestAnimationFrame(draw);
})();

// ==================== ENERGY GRAPHS ====================
(function initEnergy() {
  const keC = setupCanvas('ke-graph');
  const totC = setupCanvas('total-graph');
  const momC = setupCanvas('momentum-graph');
  const slider = document.getElementById('energy-vel');
  let currentBeta = 0;

  function drawGraph(setup, fn, label, color, maxY, yLabel) {
    const { ctx, w, h } = setup;
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 70, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);
    ctx.save();
    ctx.translate(14, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    // Grid
    for (let i = 0; i <= 4; i++) {
      const val = (maxY / 4) * i;
      const y = pad.t + gh - (i / 4) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(fmt(val, 1), pad.l - 8, y + 4);
    }

    // Classical comparison (dashed)
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(100,116,139,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 1.5;
    for (let i = 0; i <= 400; i++) {
      const b = (i / 400) * 0.999;
      let classicalVal;
      if (label === 'KE') classicalVal = 0.5 * b * b;
      else if (label === 'Total') classicalVal = 1 + 0.5 * b * b;
      else classicalVal = b;
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(classicalVal, maxY) / maxY) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Relativistic curve
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 500; i++) {
      const b = (i / 500) * 0.999;
      const val = fn(b);
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Legend
    ctx.fillStyle = color;
    ctx.fillRect(pad.l + 10, pad.t + 8, 20, 3);
    ctx.fillStyle = '#e2e8f0';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Relativistic', pad.l + 36, pad.t + 13);
    ctx.fillStyle = '#64748b';
    ctx.fillRect(pad.l + 10, pad.t + 24, 20, 3);
    ctx.fillText('Classical (Newtonian)', pad.l + 36, pad.t + 29);

    // Current point
    if (currentBeta > 0.001) {
      const val = fn(Math.min(currentBeta, 0.9999));
      const x = pad.l + currentBeta * gw;
      const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(6,182,212,0.4)';
      ctx.beginPath();
      ctx.moveTo(x, pad.t + gh);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#06b6d4';
      ctx.fill();
    }
  }

  function update() {
    const keFunc = (b) => gamma(b) - 1;
    const totFunc = (b) => gamma(b);
    const momFunc = (b) => gamma(b) * b;

    drawGraph(keC, keFunc, 'KE', '#f59e0b', 20, 'KE / mc²');
    drawGraph(totC, totFunc, 'Total', '#ef4444', 20, 'E / mc²');
    drawGraph(momC, momFunc, 'p', '#a855f7', 20, 'p / mc');
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 1000;
    const g = currentBeta > 0.001 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    const ke = g - 1;
    const mom = g * currentBeta;
    document.getElementById('energy-vel-label').textContent = currentBeta.toFixed(3) + 'c';
    document.getElementById('e-rest').textContent = '1.00 mc²';
    document.getElementById('e-ke').textContent = fmt(ke) + ' mc²';
    document.getElementById('e-total').textContent = fmt(g) + ' mc²';
    document.getElementById('e-mom').textContent = fmt(mom) + ' mc';
    update();
  });

  // Tabs
  document.querySelectorAll('#sec-energy .tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#sec-energy .tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('#sec-energy .tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab).classList.add('active');
      update();
    });
  });

  update();
})();

// ==================== MUON SIMULATION ====================
(function initMuon() {
  const { ctx, w, h } = setupCanvas('muon-canvas');
  const startBtn = document.getElementById('muon-start');
  const resetBtn = document.getElementById('muon-reset');
  let running = false;
  let altitude = 15000; // meters
  const totalAlt = 15000;
  const muonHalfLife = 1.56e-6; // seconds (half-life)
  const muonSpeed = 0.998; // fraction of c
  const gMuon = gamma(muonSpeed);
  let classicalSurvival = 1;
  let relativisticSurvival = 1;
  let animId = null;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 60, t: 20, b: 40 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Background gradient (sky to ground)
    const skyGrad = ctx.createLinearGradient(0, pad.t, 0, pad.t + gh);
    skyGrad.addColorStop(0, '#0c1445');
    skyGrad.addColorStop(0.85, '#1a2744');
    skyGrad.addColorStop(1, '#2d4a2d');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(pad.l, pad.t, gw, gh);

    // Altitude marks
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'right';
    for (let a = 0; a <= 15; a += 3) {
      const y = pad.t + gh - (a / 15) * gh;
      ctx.fillText(a + ' km', pad.l - 8, y + 4);
      ctx.strokeStyle = 'rgba(100,116,139,0.2)';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
    }

    // Ground
    ctx.fillStyle = '#3d5a3d';
    ctx.fillRect(pad.l, pad.t + gh - 2, gw, 4);
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.fillText('Sea Level', pad.l + gw / 2, pad.t + gh + 16);

    // Muon positions
    const progress = 1 - altitude / totalAlt;
    const currentY = pad.t + progress * gh;

    // Classical decay line (660m ~ 4.4% of 15km)
    const classicalRange = 660;
    const classicalY = pad.t + (classicalRange / totalAlt) * gh;
    ctx.strokeStyle = 'rgba(245,158,11,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t + gh - classicalY + pad.t);
    ctx.lineTo(pad.l + gw, pad.t + gh - classicalY + pad.t);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'left';
    ctx.fillText('Classical decay range (~660m)', pad.l + gw + 6, pad.t + gh - classicalY + pad.t + 4);

    // Draw muon particles - Classical (left half)
    const numMuons = 30;
    const leftX = pad.l + gw * 0.25;
    const rightX = pad.l + gw * 0.75;

    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Classical', leftX, pad.t + gh + 30);
    ctx.fillStyle = '#06b6d4';
    ctx.fillText('Relativistic', rightX, pad.t + gh + 30);

    for (let i = 0; i < numMuons; i++) {
      const angle = (i / numMuons) * Math.PI * 2;
      const spread = 40;

      // Classical
      const cx = leftX + Math.cos(angle + i) * spread * (i % 3 + 1) / 3;
      const cy = currentY + Math.sin(angle) * 8;
      const classAlpha = classicalSurvival > (i / numMuons) ? 0.8 : 0.08;
      ctx.beginPath();
      ctx.arc(cx, cy, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(245,158,11,${classAlpha})`;
      ctx.fill();

      // Relativistic
      const rx = rightX + Math.cos(angle + i) * spread * (i % 3 + 1) / 3;
      const ry = currentY + Math.sin(angle) * 8;
      const relAlpha = relativisticSurvival > (i / numMuons) ? 0.8 : 0.08;
      ctx.beginPath();
      ctx.arc(rx, ry, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(6,182,212,${relAlpha})`;
      ctx.fill();
    }
  }

  function step() {
    if (!running) return;
    const speed = muonSpeed * c; // m/s
    const dt = 0.016; // 16ms frame
    const simSpeed = 500; // speed up simulation
    const distStep = speed * dt * simSpeed / c * 150;

    altitude -= distStep;
    if (altitude < 0) altitude = 0;

    const distTraveled = totalAlt - altitude;
    const timeClassical = distTraveled / (muonSpeed * c);
    const timeRelativistic = timeClassical / gMuon;

    classicalSurvival = Math.pow(0.5, timeClassical / muonHalfLife);
    relativisticSurvival = Math.pow(0.5, timeRelativistic / muonHalfLife);

    document.getElementById('muon-classical').textContent = (classicalSurvival * 100).toFixed(1) + '%';
    document.getElementById('muon-relativistic').textContent = (relativisticSurvival * 100).toFixed(1) + '%';
    document.getElementById('muon-alt').textContent = (altitude / 1000).toFixed(1) + ' km';

    draw();

    if (altitude > 0) {
      animId = requestAnimationFrame(step);
    } else {
      running = false;
      startBtn.textContent = 'Start Simulation';
    }
  }

  startBtn.addEventListener('click', () => {
    if (running) {
      running = false;
      startBtn.textContent = 'Resume';
    } else {
      running = true;
      startBtn.textContent = 'Pause';
      step();
    }
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    if (animId) cancelAnimationFrame(animId);
    altitude = totalAlt;
    classicalSurvival = 1;
    relativisticSurvival = 1;
    startBtn.textContent = 'Start Simulation';
    document.getElementById('muon-classical').textContent = '100%';
    document.getElementById('muon-relativistic').textContent = '100%';
    document.getElementById('muon-alt').textContent = '15.0 km';
    draw();
  });

  draw();
})();

// ==================== E=mc² SECTION ====================
(function initEmc2() {
  const { ctx, w, h } = setupCanvas('emc2-graph');
  const slider = document.getElementById('mass-slider');

  function draw(mass) {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 70, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Bar chart comparison
    const items = [
      { label: `${mass} kg at rest\n(E=mc²)`, energy: mass * c * c, color: '#06b6d4' },
      { label: 'Hiroshima\n(~6.3×10¹³ J)', energy: 6.3e13, color: '#f59e0b' },
      { label: 'US daily energy\n(~2.7×10¹⁶ J)', energy: 2.7e16, color: '#a855f7' },
      { label: `${mass} kg at 0.9c\n(γmc²)`, energy: gamma(0.9) * mass * c * c, color: '#ef4444' },
    ];

    const maxE = Math.max(...items.map(i => i.energy));
    const barW = gw / items.length - 20;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.save();
    ctx.translate(14, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Energy (log scale)', 0, 0);
    ctx.restore();

    // Use log scale
    const logMax = Math.log10(maxE);
    const logMin = 10;

    items.forEach((item, i) => {
      const x = pad.l + (i + 0.5) * (gw / items.length) - barW / 2;
      const logE = Math.log10(Math.max(item.energy, 1));
      const barH = ((logE - logMin) / (logMax - logMin + 2)) * gh;

      // Bar
      const grad = ctx.createLinearGradient(x, pad.t + gh - barH, x, pad.t + gh);
      grad.addColorStop(0, item.color);
      grad.addColorStop(1, item.color + '44');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(x, pad.t + gh - barH, barW, barH, [4, 4, 0, 0]);
      ctx.fill();

      // Value on bar
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center';
      const eStr = item.energy.toExponential(1);
      ctx.fillText(eStr + ' J', x + barW / 2, pad.t + gh - barH - 8);

      // Label below
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px system-ui';
      const lines = item.label.split('\n');
      lines.forEach((line, li) => {
        ctx.fillText(line, x + barW / 2, pad.t + gh + 14 + li * 13);
      });
    });
  }

  slider.addEventListener('input', () => {
    const mass = parseFloat(slider.value);
    document.getElementById('mass-label').textContent = mass.toFixed(0) + ' kg';

    const energy = mass * c * c;
    const tntMegatons = energy / 4.184e15;
    const cityYears = energy / (1e9 * 3.15e7);

    document.getElementById('emc2-rest').innerHTML = (energy / 1e16).toFixed(1) + ' &times; 10&sup1;&sup6; J';
    document.getElementById('emc2-tnt').textContent = tntMegatons.toFixed(1) + ' MT';
    document.getElementById('emc2-power').textContent = `A city for ${cityYears.toFixed(1)} years`;
    draw(mass);
  });

  draw(1);
})();

// ==================== TWIN PARADOX ====================
(function initTwins() {
  const { ctx, w, h } = setupCanvas('twin-canvas');
  const velSlider = document.getElementById('twin-vel');
  const distSlider = document.getElementById('twin-dist');
  const playBtn = document.getElementById('twin-play');
  const resetBtn = document.getElementById('twin-reset');
  const speedBtn = document.getElementById('twin-speed');

  let beta = 0.5;
  let distLY = 5.0; // light-years one way
  let running = false;
  let finished = false;
  let simTime = 0; // Earth elapsed time in years
  let simSpeed = 1; // multiplier
  let prevTs = null;
  let animId = null;

  // Derived quantities
  function getTripStats() {
    const g = gamma(beta);
    const tOneWayEarth = distLY / beta;      // years (Earth frame)
    const tTotalEarth = 2 * tOneWayEarth;     // round trip, Earth
    const tTotalTraveler = tTotalEarth / g;    // round trip, traveler
    return { g, tOneWayEarth, tTotalEarth, tTotalTraveler };
  }

  function getPhase(earthTime) {
    const { tOneWayEarth, tTotalEarth } = getTripStats();
    if (earthTime <= 0) return { phase: 'ready', frac: 0, leg: 0 };
    if (earthTime >= tTotalEarth) return { phase: 'reunited', frac: 1, leg: 2 };
    if (earthTime < tOneWayEarth) return { phase: 'outbound', frac: earthTime / tOneWayEarth, leg: 0 };
    if (earthTime < tOneWayEarth * 1.0001) return { phase: 'turnaround', frac: 0.5, leg: 1 };
    return { phase: 'return', frac: (earthTime - tOneWayEarth) / tOneWayEarth, leg: 2 };
  }

  // ---- Drawing helpers ----
  function drawStar(ctx, x, y, r, spikes, color) {
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
      const angle = (i * Math.PI) / spikes - Math.PI / 2;
      const rad = i % 2 === 0 ? r : r * 0.4;
      const px = x + Math.cos(angle) * rad;
      const py = y + Math.sin(angle) * rad;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  function drawPerson(ctx, x, y, scale, faceColor, bodyColor, age) {
    const s = scale;
    // Body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.roundRect(x - 8 * s, y - 2 * s, 16 * s, 22 * s, 4 * s);
    ctx.fill();
    // Head
    ctx.fillStyle = faceColor;
    ctx.beginPath();
    ctx.arc(x, y - 12 * s, 10 * s, 0, Math.PI * 2);
    ctx.fill();
    // Eyes
    ctx.fillStyle = '#1e293b';
    ctx.beginPath();
    ctx.arc(x - 3.5 * s, y - 14 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.arc(x + 3.5 * s, y - 14 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.fill();
    // Mouth
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y - 9 * s, 3 * s, 0.1, Math.PI - 0.1);
    ctx.stroke();
    // Hair (grays with age)
    const grayAmount = Math.min(1, Math.max(0, (age - 40) / 40));
    const hairR = Math.round(lerp(60, 180, grayAmount));
    const hairG = Math.round(lerp(40, 180, grayAmount));
    const hairB = Math.round(lerp(30, 180, grayAmount));
    ctx.fillStyle = `rgb(${hairR},${hairG},${hairB})`;
    ctx.beginPath();
    ctx.ellipse(x, y - 20 * s, 10 * s, 5 * s, 0, Math.PI, 0);
    ctx.fill();
    // Age label
    ctx.fillStyle = '#e2e8f0';
    ctx.font = `bold ${11 * s}px system-ui`;
    ctx.textAlign = 'center';
    ctx.fillText(age.toFixed(1) + ' yr', x, y + 30 * s);
  }

  function drawRocket(ctx, x, y, scale, angle, flameOn) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    const s = scale;
    // Flame
    if (flameOn) {
      const flicker = 0.7 + Math.random() * 0.3;
      const fGrad = ctx.createLinearGradient(0, 12 * s, 0, 12 * s + 18 * s * flicker);
      fGrad.addColorStop(0, '#f59e0b');
      fGrad.addColorStop(0.4, '#ef4444');
      fGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = fGrad;
      ctx.beginPath();
      ctx.moveTo(-5 * s, 12 * s);
      ctx.lineTo(5 * s, 12 * s);
      ctx.lineTo(1 * s, 12 * s + 16 * s * flicker);
      ctx.lineTo(-1 * s, 12 * s + 16 * s * flicker);
      ctx.closePath();
      ctx.fill();
    }
    // Body
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath();
    ctx.moveTo(0, -14 * s);
    ctx.lineTo(-6 * s, 6 * s);
    ctx.lineTo(-8 * s, 12 * s);
    ctx.lineTo(8 * s, 12 * s);
    ctx.lineTo(6 * s, 6 * s);
    ctx.closePath();
    ctx.fill();
    // Nose cone
    const nGrad = ctx.createLinearGradient(0, -14 * s, 0, -4 * s);
    nGrad.addColorStop(0, '#ef4444');
    nGrad.addColorStop(1, '#b91c1c');
    ctx.fillStyle = nGrad;
    ctx.beginPath();
    ctx.moveTo(0, -14 * s);
    ctx.lineTo(-4 * s, -4 * s);
    ctx.lineTo(4 * s, -4 * s);
    ctx.closePath();
    ctx.fill();
    // Window
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.arc(0, -1 * s, 3 * s, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(-1 * s, -2 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.fill();
    // Fins
    ctx.fillStyle = '#64748b';
    ctx.beginPath();
    ctx.moveTo(-6 * s, 6 * s);
    ctx.lineTo(-12 * s, 14 * s);
    ctx.lineTo(-8 * s, 12 * s);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(6 * s, 6 * s);
    ctx.lineTo(12 * s, 14 * s);
    ctx.lineTo(8 * s, 12 * s);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;

    const { g, tOneWayEarth, tTotalEarth, tTotalTraveler } = getTripStats();

    if (running && !finished) {
      const realSecsForTrip = Math.max(6, Math.min(20, tTotalEarth * 2));
      const yearsPerMs = tTotalEarth / (realSecsForTrip * 1000) * simSpeed;
      simTime += dt * yearsPerMs;
      if (simTime >= tTotalEarth) {
        simTime = tTotalEarth;
        finished = true;
        running = false;
        playBtn.textContent = 'Trip Complete';
      }
    }

    const { phase, frac, leg } = getPhase(simTime);

    // Traveler proper time
    let travelerTime = 0;
    if (simTime <= tOneWayEarth) {
      travelerTime = simTime / g;
    } else {
      travelerTime = tOneWayEarth / g + (simTime - tOneWayEarth) / g;
    }
    if (simTime >= tTotalEarth) travelerTime = tTotalTraveler;

    const earthAge = 30 + simTime;
    const travAge = 30 + travelerTime;

    // Update readouts
    document.getElementById('tw-earth-age').textContent = earthAge.toFixed(1) + ' yr';
    document.getElementById('tw-trav-age').textContent = travAge.toFixed(1) + ' yr';
    document.getElementById('tw-earth-time').textContent = simTime.toFixed(1) + ' yr';
    document.getElementById('tw-trav-time').textContent = travelerTime.toFixed(1) + ' yr';
    document.getElementById('tw-diff').textContent = (simTime - travelerTime).toFixed(1) + ' yr';
    const phaseNames = { ready: 'Ready', outbound: 'Outbound →', turnaround: 'Turnaround ↩', return: '← Return', reunited: 'Reunited!' };
    document.getElementById('tw-phase').textContent = phaseNames[phase] || phase;

    // ---- Canvas drawing ----
    ctx.clearRect(0, 0, w, h);

    // STACKED LAYOUT: top = trip animation, bottom = full-width spacetime diagram
    const tripH = h * 0.34;
    const dividerY = tripH;
    const stTop = tripH + 16;

    // ========= TOP: Trip Animation (full width) =========
    const earthX = 100;
    const starX = w - 100;
    const groundY = tripH * 0.62;

    // Background: space gradient
    const spGrad = ctx.createLinearGradient(0, 0, 0, tripH);
    spGrad.addColorStop(0, '#05081a');
    spGrad.addColorStop(0.7, '#0a1030');
    spGrad.addColorStop(1, '#0c1225');
    ctx.fillStyle = spGrad;
    ctx.fillRect(0, 0, w, tripH);

    // Decorative stars
    const starSeed = [0.05,0.12,0.22,0.35,0.43,0.58,0.67,0.78,0.88,0.95,0.15,0.31,0.52,0.71,0.84];
    for (let i = 0; i < starSeed.length; i++) {
      const sx = starSeed[i] * w;
      const sy = starSeed[(i+5)%starSeed.length] * groundY * 0.6 + 8;
      const sr = 0.5 + starSeed[(i+3)%starSeed.length] * 1.3;
      ctx.beginPath();
      ctx.arc(sx, sy, sr, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,210,255,${0.15 + starSeed[(i+7)%starSeed.length] * 0.3})`;
      ctx.fill();
    }

    // Earth
    const earthR = 28;
    ctx.beginPath();
    ctx.arc(earthX, groundY, earthR, 0, Math.PI * 2);
    const eGrad = ctx.createRadialGradient(earthX - 6, groundY - 6, 3, earthX, groundY, earthR);
    eGrad.addColorStop(0, '#3b82f6');
    eGrad.addColorStop(0.5, '#2563eb');
    eGrad.addColorStop(1, '#1e3a5f');
    ctx.fillStyle = eGrad;
    ctx.fill();
    ctx.fillStyle = 'rgba(34,197,94,0.4)';
    ctx.beginPath();
    ctx.ellipse(earthX - 5, groundY - 4, 7, 10, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(earthX + 9, groundY + 5, 6, 5, 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Earth', earthX, groundY + earthR + 16);

    // Destination star
    drawStar(ctx, starX, groundY - 4, 20, 5, '#fbbf24');
    const sgGrad = ctx.createRadialGradient(starX, groundY - 4, 5, starX, groundY - 4, 36);
    sgGrad.addColorStop(0, 'rgba(251,191,36,0.3)');
    sgGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sgGrad;
    ctx.fillRect(starX - 40, groundY - 44, 80, 80);
    ctx.fillStyle = '#f59e0b';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(distLY.toFixed(1) + ' ly', starX, groundY + earthR + 16);

    // Distance line
    ctx.strokeStyle = 'rgba(100,116,139,0.3)';
    ctx.setLineDash([5, 8]);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(earthX + earthR + 6, groundY);
    ctx.lineTo(starX - 24, groundY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Rocket position
    let rocketX, rocketY, rocketAngle, flameOn = false;
    const rocketScale = 1.5;
    if (phase === 'ready') {
      rocketX = earthX + earthR + 30;
      rocketY = groundY;
      rocketAngle = Math.PI / 2;
    } else if (phase === 'outbound') {
      rocketX = lerp(earthX + earthR + 30, starX - 35, frac);
      rocketY = groundY - Math.sin(frac * Math.PI) * 40;
      rocketAngle = Math.PI / 2;
      flameOn = true;
    } else if (phase === 'turnaround') {
      rocketX = starX - 35;
      rocketY = groundY - 40;
      rocketAngle = Math.PI / 2;
      flameOn = true;
    } else if (phase === 'return') {
      rocketX = lerp(starX - 35, earthX + earthR + 30, frac);
      rocketY = groundY - Math.sin(frac * Math.PI) * 40;
      rocketAngle = -Math.PI / 2;
      flameOn = true;
    } else {
      rocketX = earthX + earthR + 30;
      rocketY = groundY;
      rocketAngle = Math.PI / 2;
    }

    drawRocket(ctx, rocketX, rocketY, rocketScale, rocketAngle, flameOn);

    // Twin figures at bottom of trip area
    const twinBaseY = tripH - 8;
    const twinEarthX = earthX + 60;
    const twinTravX = earthX + 120;

    drawPerson(ctx, twinEarthX, twinBaseY - 40, 1.15, '#fcd6a8', '#3b82f6', earthAge);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Earth Twin', twinEarthX, twinBaseY + 2);

    if (phase === 'ready' || phase === 'reunited') {
      // Traveler standing next to Earth twin
      drawPerson(ctx, twinTravX, twinBaseY - 40, 1.15, '#fcd6a8', '#a855f7', travAge);
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Traveler', twinTravX, twinBaseY + 2);
    } else {
      // Traveler riding above the rocket during flight
      const travRocketY = rocketY - 34 * rocketScale;
      drawPerson(ctx, rocketX, travRocketY, 0.75, '#fcd6a8', '#a855f7', travAge);
      ctx.fillStyle = '#a855f7';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Traveler', rocketX, travRocketY - 26);
    }

    // Age difference highlight on reunion
    if (phase === 'reunited') {
      const diff = (simTime - travelerTime).toFixed(1);
      ctx.fillStyle = 'rgba(239,68,68,0.15)';
      ctx.beginPath();
      ctx.roundRect(twinEarthX - 10, twinBaseY - 86, twinTravX - twinEarthX + 20, 22, 6);
      ctx.fill();
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Δ ' + diff + ' years younger!', (twinEarthX + twinTravX) / 2, twinBaseY - 70);
    }

    // ========= DIVIDER =========
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, dividerY + 6);
    ctx.lineTo(w - 20, dividerY + 6);
    ctx.stroke();

    // ========= BOTTOM: Full-width Spacetime Diagram =========
    const stPad = { l: 70, r: 40, t: 14, b: 40 };
    const stW = w - stPad.l - stPad.r;
    const stH = h - stTop - stPad.t - stPad.b;
    const stOx = stPad.l;
    const stOy = stTop + stPad.t + stH;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, stTop, w, h - stTop);

    // Title
    ctx.fillStyle = '#64748b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('SPACETIME DIAGRAM', stPad.l, stTop + 10);

    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx, stTop + stPad.t);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx + stW, stOy);
    ctx.stroke();

    // Arrow on time axis
    ctx.fillStyle = '#475569';
    ctx.beginPath();
    ctx.moveTo(stOx, stTop + stPad.t);
    ctx.lineTo(stOx - 5, stTop + stPad.t + 12);
    ctx.lineTo(stOx + 5, stTop + stPad.t + 12);
    ctx.closePath();
    ctx.fill();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '13px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('x  (light-years)', stOx + stW / 2, stOy + 32);
    ctx.save();
    ctx.translate(stOx - 50, stTop + stPad.t + stH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('t  (years)', 0, 0);
    ctx.restore();

    // Scale: map distLY -> 60% of stW, tTotalEarth -> 85% of stH
    const xScale = (stW * 0.6) / Math.max(distLY, 0.1);
    const tScale = (stH * 0.85) / Math.max(tTotalEarth, 0.1);

    // Grid
    ctx.strokeStyle = 'rgba(30,41,59,0.4)';
    ctx.lineWidth = 0.5;
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    const tStep = Math.max(1, Math.ceil(tTotalEarth / 10));
    for (let t = tStep; t <= tTotalEarth * 1.1; t += tStep) {
      const y = stOy - t * tScale;
      if (y < stTop + stPad.t) break;
      ctx.beginPath();
      ctx.moveTo(stOx, y);
      ctx.lineTo(stOx + stW, y);
      ctx.stroke();
      ctx.textAlign = 'right';
      ctx.fillText(t.toFixed(0), stOx - 8, y + 4);
    }
    const xStep = Math.max(1, Math.ceil(distLY / 6));
    for (let x = xStep; x <= distLY * 1.15; x += xStep) {
      const px = stOx + x * xScale;
      if (px > stOx + stW) break;
      ctx.beginPath();
      ctx.moveTo(px, stOy);
      ctx.lineTo(px, stTop + stPad.t);
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.fillText(x.toFixed(0), px, stOy + 16);
    }

    // Light cone from origin
    ctx.strokeStyle = 'rgba(245,158,11,0.3)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1.5;
    const lcLen = Math.min(stW, stH);
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx + lcLen, stOy - lcLen);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx - Math.min(stPad.l - 14, lcLen), stOy - Math.min(stPad.l - 14, lcLen));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(245,158,11,0.4)';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('light (c)', stOx + lcLen * 0.35 + 6, stOy - lcLen * 0.35 - 6);

    // Earth worldline (vertical, stationary)
    ctx.strokeStyle = 'rgba(245,158,11,0.6)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx, stOy - tTotalEarth * tScale);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('Earth twin', stOx - 10, stOy - tTotalEarth * tScale + 16);

    // Traveler worldline (kinked V shape)
    const midX = stOx + distLY * xScale;
    const midY = stOy - tOneWayEarth * tScale;
    const endY = stOy - tTotalEarth * tScale;

    // Wide glow
    ctx.strokeStyle = 'rgba(6,182,212,0.1)';
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();
    // Narrow glow
    ctx.strokeStyle = 'rgba(6,182,212,0.25)';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();
    // Core
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();

    // Turnaround kink
    ctx.beginPath();
    ctx.arc(midX, midY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#a855f7';
    ctx.fill();
    ctx.strokeStyle = '#c084fc';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = '#a855f7';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('turnaround', midX + 12, midY + 5);

    // Outbound / return labels
    ctx.fillStyle = '#06b6d4';
    ctx.font = '12px system-ui';
    const outLblX = (stOx + midX) / 2 + 10;
    const outLblY = (stOy + midY) / 2;
    ctx.textAlign = 'left';
    ctx.fillText('outbound →', outLblX, outLblY);
    const retLblX = (stOx + midX) / 2 + 10;
    const retLblY = (midY + endY) / 2;
    ctx.fillText('← return', retLblX, retLblY);

    // Animated position dots
    if (simTime > 0 && simTime <= tTotalEarth) {
      let dotX, dotY;
      if (simTime <= tOneWayEarth) {
        const f = simTime / tOneWayEarth;
        dotX = lerp(stOx, midX, f);
        dotY = lerp(stOy, midY, f);
      } else {
        const f = (simTime - tOneWayEarth) / tOneWayEarth;
        dotX = lerp(midX, stOx, f);
        dotY = lerp(midY, endY, f);
      }
      // Traveler dot glow
      const dg = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, 16);
      dg.addColorStop(0, 'rgba(6,182,212,0.7)');
      dg.addColorStop(1, 'transparent');
      ctx.fillStyle = dg;
      ctx.fillRect(dotX - 18, dotY - 18, 36, 36);
      ctx.beginPath();
      ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();

      // Earth dot
      const eDotY = stOy - simTime * tScale;
      const edg = ctx.createRadialGradient(stOx, eDotY, 0, stOx, eDotY, 14);
      edg.addColorStop(0, 'rgba(245,158,11,0.7)');
      edg.addColorStop(1, 'transparent');
      ctx.fillStyle = edg;
      ctx.fillRect(stOx - 16, eDotY - 16, 32, 32);
      ctx.beginPath();
      ctx.arc(stOx, eDotY, 4.5, 0, Math.PI * 2);
      ctx.fillStyle = '#fef3c7';
      ctx.fill();

      // Connecting dashed line
      ctx.strokeStyle = 'rgba(148,163,184,0.3)';
      ctx.setLineDash([4, 5]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(stOx, eDotY);
      ctx.lineTo(dotX, dotY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Proper time annotations at endpoints
    if (simTime >= tTotalEarth) {
      // Background pill for Earth
      ctx.fillStyle = 'rgba(245,158,11,0.12)';
      ctx.beginPath();
      ctx.roundRect(stOx - 80, endY - 18, 74, 22, 4);
      ctx.fill();
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'right';
      ctx.fillText('τ = ' + tTotalEarth.toFixed(1) + ' yr', stOx - 10, endY - 2);
      // Background pill for Traveler
      ctx.fillStyle = 'rgba(6,182,212,0.12)';
      ctx.beginPath();
      ctx.roundRect(stOx + 6, endY - 18, 82, 22, 4);
      ctx.fill();
      ctx.fillStyle = '#06b6d4';
      ctx.textAlign = 'left';
      ctx.fillText('τ = ' + tTotalTraveler.toFixed(1) + ' yr', stOx + 10, endY - 2);
    }

    // Departure & arrival dots
    ctx.beginPath();
    ctx.arc(stOx, stOy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#e2e8f0';
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('departure', stOx + 10, stOy - 2);

    if (simTime >= tTotalEarth) {
      ctx.beginPath();
      ctx.arc(stOx, endY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#e2e8f0';
      ctx.fill();
      ctx.fillStyle = '#94a3b8';
      ctx.textAlign = 'left';
      ctx.fillText('reunion', stOx + 10, endY + 14);
    }

    animId = requestAnimationFrame(draw);
  }

  // ---- Slider events ----
  velSlider.addEventListener('input', () => {
    beta = velSlider.value / 100;
    document.getElementById('twin-vel-label').textContent = beta.toFixed(2) + 'c';
    if (!running && !finished) updatePreview();
  });
  distSlider.addEventListener('input', () => {
    distLY = distSlider.value / 2;
    document.getElementById('twin-dist-label').textContent = distLY.toFixed(1) + ' ly';
    if (!running && !finished) updatePreview();
  });

  function updatePreview() {
    const { tTotalEarth, tTotalTraveler } = getTripStats();
    document.getElementById('tw-earth-time').textContent = tTotalEarth.toFixed(1) + ' yr (total)';
    document.getElementById('tw-trav-time').textContent = tTotalTraveler.toFixed(1) + ' yr (total)';
    document.getElementById('tw-diff').textContent = (tTotalEarth - tTotalTraveler).toFixed(1) + ' yr';
  }

  // ---- Controls ----
  playBtn.addEventListener('click', () => {
    if (finished) return;
    if (running) {
      running = false;
      playBtn.textContent = 'Resume';
    } else {
      running = true;
      playBtn.textContent = 'Pause';
    }
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    finished = false;
    simTime = 0;
    prevTs = null;
    playBtn.textContent = 'Launch Trip';
    document.getElementById('tw-earth-age').textContent = '30.0 yr';
    document.getElementById('tw-trav-age').textContent = '30.0 yr';
    document.getElementById('tw-earth-time').textContent = '0.0 yr';
    document.getElementById('tw-trav-time').textContent = '0.0 yr';
    document.getElementById('tw-diff').textContent = '0.0 yr';
    document.getElementById('tw-phase').textContent = 'Ready';
    updatePreview();
  });

  const speeds = [1, 2, 5, 10];
  let speedIdx = 0;
  speedBtn.addEventListener('click', () => {
    speedIdx = (speedIdx + 1) % speeds.length;
    simSpeed = speeds[speedIdx];
    speedBtn.innerHTML = 'Speed: ' + simSpeed + '&times;';
  });

  // Initialize
  updatePreview();
  requestAnimationFrame(draw);
})();

// ==================== COMBINED GRAPH ====================
(function initCombined() {
  const { ctx, w, h } = setupCanvas('combined-graph');
  const slider = document.getElementById('master-vel');
  let currentBeta = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);

    // Grid
    const maxY = 15;
    for (let i = 0; i <= maxY; i += 5) {
      const y = pad.t + gh - (i / maxY) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(i.toString(), pad.l - 8, y + 4);
    }
    for (let v = 0; v <= 1; v += 0.2) {
      const x = pad.l + v * gw;
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      ctx.fillText(v.toFixed(1) + 'c', x, pad.t + gh + 20);
    }

    // Curves
    const curves = [
      { fn: (b) => gamma(b), color: '#a855f7', label: 'γ (Lorentz)' },
      { fn: (b) => gamma(b), color: '#f59e0b', label: 'Time Dilation' },
      { fn: (b) => 1 / gamma(b), color: '#06b6d4', label: 'Length (1/γ)', maxVal: 1 },
      { fn: (b) => gamma(b), color: '#ef4444', label: 'Energy (γmc²)' },
    ];

    // Length contraction uses different scale (0-1 mapped to 0-1 on graph)
    curves.forEach((curve, ci) => {
      ctx.beginPath();
      ctx.strokeStyle = curve.color;
      ctx.lineWidth = 2;
      for (let i = 0; i <= 500; i++) {
        const b = (i / 500) * 0.999;
        let val = curve.fn(b);
        if (ci === 2) val = val * maxY; // scale length to fill graph
        const x = pad.l + b * gw;
        const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();
    });

    // Legend
    curves.forEach((curve, i) => {
      const lx = pad.l + 12;
      const ly = pad.t + 14 + i * 18;
      ctx.fillStyle = curve.color;
      ctx.fillRect(lx, ly - 4, 16, 3);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(curve.label, lx + 22, ly);
    });

    // Current velocity line
    if (currentBeta > 0) {
      const x = pad.l + currentBeta * gw;
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x, pad.t);
      ctx.lineTo(x, pad.t + gh);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 10000;
    const g = currentBeta > 0.001 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    document.getElementById('master-vel-label').textContent = currentBeta.toFixed(4) + 'c';
    document.getElementById('c-gamma').textContent = fmt(g);
    document.getElementById('c-time').innerHTML = fmt(g) + '&times;';
    document.getElementById('c-length').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('c-energy').textContent = fmt(g);
    draw();
  });

  draw();
})();

// ==================== CAUSALITY VIOLATION ====================
(function initCausality() {
  // ---- Tab switching ----
  const tabBar = document.getElementById('causality-tabs');
  if (!tabBar) return;
  tabBar.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      tabBar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const tgt = btn.getAttribute('data-tab');
      btn.closest('.card').querySelectorAll('.tab-content').forEach(tc => {
        tc.classList.toggle('active', tc.id === tgt);
      });
    });
  });

  // ---- Constants ----
  const ALPHA_CENTAURI = 4.37; // light-years

  // ================================================================
  //  TAB 1: Simultaneity & Light Cones
  // ================================================================
  (function initSimultaneity() {
    const { ctx, w, h } = setupCanvas('causality-canvas');
    const velSlider = document.getElementById('caus-vel');
    const ftlSlider = document.getElementById('caus-ftl');
    let beta = 0;
    let ftlSpeed = 2.0; // multiples of c
    let animBeta = 0;
    let animFtl = 2.0;
    let animTime = 0;
    let prevTs = null;
    let violationFlash = 0;

    function updateReadouts(b, s) {
      const g = b > 0.001 ? gamma(Math.min(b, 0.999)) : 1;
      const tEarth = ALPHA_CENTAURI / s;
      const tMoving = g * (tEarth - b * ALPHA_CENTAURI);
      document.getElementById('cv-vel').textContent = b.toFixed(2) + 'c';
      document.getElementById('cv-ftl').textContent = s.toFixed(1) + 'c';
      document.getElementById('cv-earth-t').textContent = '+' + tEarth.toFixed(2) + ' yr';
      const movSign = tMoving >= 0 ? '+' : '';
      const movEl = document.getElementById('cv-moving-t');
      movEl.textContent = movSign + tMoving.toFixed(2) + ' yr';
      movEl.className = 'value ' + (tMoving < 0 ? 'red' : 'purple');
      const reversalDays = tMoving < 0 ? Math.abs(tMoving * 365.25) : 0;
      document.getElementById('cv-reversal').textContent = reversalDays > 0 ? reversalDays.toFixed(0) + ' days' : 'None';
      const statusEl = document.getElementById('cv-status');
      if (tMoving < 0) {
        statusEl.textContent = 'VIOLATION';
        statusEl.style.color = '#ef4444';
      } else {
        statusEl.textContent = 'OK';
        statusEl.style.color = '#22c55e';
      }
      return tMoving;
    }

    velSlider.addEventListener('input', () => {
      beta = velSlider.value / 100;
      document.getElementById('caus-vel-label').textContent = beta.toFixed(2) + 'c';
      updateReadouts(beta, ftlSpeed);
    });
    ftlSlider.addEventListener('input', () => {
      ftlSpeed = ftlSlider.value / 10;
      document.getElementById('caus-ftl-label').textContent = ftlSpeed.toFixed(1) + 'c';
      updateReadouts(beta, ftlSpeed);
    });

    function draw(ts) {
      if (prevTs === null) prevTs = ts;
      const dt = Math.min(ts - prevTs, 50);
      prevTs = ts;
      animTime += dt;
      animBeta += (beta - animBeta) * Math.min(1, dt * 0.008);
      animFtl += (ftlSpeed - animFtl) * Math.min(1, dt * 0.008);

      const b = animBeta;
      const s = animFtl;
      const g = b > 0.001 ? gamma(Math.min(b, 0.999)) : 1;
      const tEarth = ALPHA_CENTAURI / s;
      const tMoving = g * (tEarth - b * ALPHA_CENTAURI);

      // Violation flash
      if (tMoving < 0) {
        violationFlash = Math.min(1, violationFlash + dt * 0.004);
      } else {
        violationFlash = Math.max(0, violationFlash - dt * 0.004);
      }

      ctx.clearRect(0, 0, w, h);

      // --- Coordinate system ---
      const margin = { left: 80, right: 40, top: 50, bottom: 60 };
      const plotW = w - margin.left - margin.right;
      const plotH = h - margin.top - margin.bottom;
      const ox = margin.left; // origin x (Earth, x=0)
      const oy = margin.top + plotH * 0.65; // origin y (t=0) — shifted down so we see negative time
      const maxX = 8; // light-years
      const maxTup = 6; // years up (future)
      const maxTdown = 3; // years down (past)
      const xScale = plotW / maxX;
      const tScale = plotH / (maxTup + maxTdown);
      const tToY = (t) => oy - t * tScale;
      const xToX = (x) => ox + x * xScale;

      // --- Grid ---
      ctx.strokeStyle = 'rgba(30,41,59,0.5)';
      ctx.lineWidth = 0.5;
      for (let i = -Math.floor(maxTdown); i <= maxTup; i++) {
        const gy = tToY(i);
        ctx.beginPath(); ctx.moveTo(ox, gy); ctx.lineTo(ox + plotW, gy); ctx.stroke();
      }
      for (let i = 0; i <= maxX; i++) {
        const gx = xToX(i);
        ctx.beginPath(); ctx.moveTo(gx, tToY(-maxTdown)); ctx.lineTo(gx, tToY(maxTup)); ctx.stroke();
      }

      // --- Axes ---
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 1.5;
      // Time axis (vertical at x=0)
      ctx.beginPath(); ctx.moveTo(ox, tToY(-maxTdown)); ctx.lineTo(ox, tToY(maxTup)); ctx.stroke();
      // Space axis (horizontal at t=0)
      ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(ox + plotW, oy); ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (light-years)', ox + plotW / 2, h - 12);
      ctx.save();
      ctx.translate(18, oy);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Time (years)', 0, 0);
      ctx.restore();

      // Tick labels
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      for (let i = 0; i <= maxX; i += 2) {
        ctx.fillText(i + '', xToX(i), oy + 18);
      }
      ctx.textAlign = 'right';
      for (let i = -Math.floor(maxTdown); i <= maxTup; i++) {
        if (i === 0) continue;
        ctx.fillText((i > 0 ? '+' : '') + i, ox - 8, tToY(i) + 4);
      }
      ctx.fillText('0', ox - 8, oy + 4);

      // --- Light cone (from origin) ---
      // Future cone shading
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(maxTup), tToY(maxTup));
      ctx.lineTo(ox, tToY(maxTup));
      ctx.closePath();
      ctx.fillStyle = 'rgba(250,204,21,0.05)';
      ctx.fill();

      // Past cone shading
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(maxTdown), tToY(-maxTdown));
      ctx.lineTo(ox, tToY(-maxTdown));
      ctx.closePath();
      ctx.fillStyle = 'rgba(250,204,21,0.04)';
      ctx.fill();

      // Spacelike region shading (FTL zone) - right side
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(maxTup), tToY(maxTup));
      ctx.lineTo(ox + plotW, tToY(maxTup));
      ctx.lineTo(ox + plotW, tToY(-maxTdown));
      ctx.lineTo(xToX(maxTdown), tToY(-maxTdown));
      ctx.closePath();
      ctx.fillStyle = 'rgba(96,165,250,0.04)';
      ctx.fill();
      // Violation flash overlay
      if (violationFlash > 0) {
        ctx.fillStyle = `rgba(239,68,68,${0.06 * violationFlash * (0.5 + 0.5 * Math.sin(animTime * 0.006))})`;
        ctx.fillRect(ox, tToY(maxTup), plotW, plotH);
      }

      // Light cone lines (45°: 1 ly per year)
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      // Future right
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(Math.min(maxX, maxTup)), tToY(Math.min(maxX, maxTup)));
      ctx.stroke();
      // Past right
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(Math.min(maxX, maxTdown)), tToY(-Math.min(maxX, maxTdown)));
      ctx.stroke();

      // Light cone label
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'italic 11px system-ui';
      ctx.textAlign = 'left';
      const lcLabelX = xToX(3.5);
      const lcLabelY = tToY(3.5);
      ctx.save();
      ctx.translate(lcLabelX, lcLabelY);
      ctx.rotate(-Math.PI / 4);
      ctx.fillText('Light (c)', 0, -8);
      ctx.restore();

      // FTL zone label
      ctx.fillStyle = 'rgba(96,165,250,0.5)';
      ctx.font = 'bold 14px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('FTL ZONE', xToX(6), oy - 6);
      ctx.font = '11px system-ui';
      ctx.fillStyle = 'rgba(96,165,250,0.35)';
      ctx.fillText('(spacelike region)', xToX(6), oy + 12);

      // --- Earth worldline (vertical at x=0) ---
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(ox, tToY(-maxTdown));
      ctx.lineTo(ox, tToY(maxTup));
      ctx.stroke();
      // Earth label
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Earth', ox, tToY(maxTup) - 8);

      // --- Alpha Centauri worldline (vertical at x=4.37) ---
      const acX = xToX(ALPHA_CENTAURI);
      ctx.strokeStyle = '#06b6d4';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(acX, tToY(-maxTdown));
      ctx.lineTo(acX, tToY(maxTup));
      ctx.stroke();
      // AC label
      ctx.fillStyle = '#06b6d4';
      ctx.font = 'bold 12px system-ui';
      ctx.fillText('Alpha Centauri', acX, tToY(maxTup) - 8);
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#06b6d4';
      ctx.fillText('4.37 ly', acX, tToY(maxTup) - 22);

      // --- FTL message line (Earth → AC) ---
      const msgArrT = ALPHA_CENTAURI / s; // arrival time in Earth frame
      const msgStartX = ox;
      const msgStartY = oy; // T=0
      const msgEndX = acX;
      const msgEndY = tToY(msgArrT);

      // Glow
      ctx.strokeStyle = 'rgba(239,68,68,0.2)';
      ctx.lineWidth = 8;
      ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(msgStartX, msgStartY); ctx.lineTo(msgEndX, msgEndY); ctx.stroke();
      // Core
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([8, 6]);
      ctx.beginPath(); ctx.moveTo(msgStartX, msgStartY); ctx.lineTo(msgEndX, msgEndY); ctx.stroke();
      ctx.setLineDash([]);

      // FTL message label
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      const fmlX = (msgStartX + msgEndX) / 2;
      const fmlY = (msgStartY + msgEndY) / 2;
      ctx.fillText('FTL Message (' + s.toFixed(1) + 'c)', fmlX, fmlY - 12);

      // Arrival event marker
      ctx.beginPath();
      ctx.arc(msgEndX, msgEndY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#ef4444';
      ctx.fill();
      // Send event marker
      ctx.beginPath();
      ctx.arc(msgStartX, msgStartY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#22c55e';
      ctx.fill();
      // Event labels
      ctx.font = '10px system-ui';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#22c55e';
      ctx.fillText('SEND (T=0)', msgStartX + 10, msgStartY + 4);
      ctx.fillStyle = '#ef4444';
      ctx.textAlign = 'right';
      ctx.fillText('ARRIVE (T=' + msgArrT.toFixed(2) + 'yr)', msgEndX - 10, msgEndY - 8);

      // --- Simultaneity line (moving observer's "now") ---
      if (b > 0.005) {
        // The simultaneity line through the origin: t = (v/c²)·x → t = b·x (in natural units)
        const simSlope = b; // dt/dx in light-year/year units
        const simX1 = 0;
        const simT1 = 0;
        const simX2 = maxX;
        const simT2 = simSlope * maxX;

        // Wide glow
        ctx.strokeStyle = 'rgba(168,85,247,0.15)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(xToX(simX1), tToY(simT1));
        ctx.lineTo(xToX(simX2), tToY(simT2));
        ctx.stroke();

        // Dashed line
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(xToX(simX1), tToY(simT1));
        ctx.lineTo(xToX(simX2), tToY(simT2));
        ctx.stroke();
        ctx.setLineDash([]);

        // "Now" labels
        ctx.fillStyle = '#a855f7';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('"Now" for moving observer', xToX(simX2) - 160, tToY(simT2) - 10);

        // Horizontal "now" for Earth (reference)
        ctx.strokeStyle = 'rgba(148,163,184,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(ox, oy);
        ctx.lineTo(ox + plotW, oy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText('"Now" for Earth observer', ox + plotW, oy - 6);

        // Show where the simultaneity line crosses Alpha Centauri
        const simCrossT = simSlope * ALPHA_CENTAURI;
        const simCrossY = tToY(simCrossT);
        ctx.beginPath();
        ctx.arc(acX, simCrossY, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#a855f7';
        ctx.fill();

        // Dashed vertical showing the time difference at AC
        ctx.strokeStyle = 'rgba(168,85,247,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(acX, oy);
        ctx.lineTo(acX, simCrossY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Label the time offset at AC
        ctx.fillStyle = '#a855f7';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        const offsetLabel = simCrossT > 0 ? '+' + simCrossT.toFixed(2) + 'yr' : simCrossT.toFixed(2) + 'yr';
        ctx.fillText('Δt = ' + offsetLabel, acX + 8, (oy + simCrossY) / 2 + 4);
      }

      // --- Moving frame arrival time annotation ---
      if (b > 0.005 && tMoving < tEarth) {
        const movArrY = tToY(tMoving);
        // Dashed line from arrival point to the time axis
        ctx.strokeStyle = tMoving < 0 ? 'rgba(239,68,68,0.5)' : 'rgba(168,85,247,0.3)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(acX, movArrY);
        ctx.lineTo(ox, movArrY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Label on time axis
        ctx.fillStyle = tMoving < 0 ? '#ef4444' : '#a855f7';
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'right';
        const mtLabel = (tMoving >= 0 ? '+' : '') + tMoving.toFixed(2) + 'yr';
        // Background pill
        const mtText = "T'=" + mtLabel;
        const mtMeasure = ctx.measureText(mtText);
        const pillX = ox - 4 - mtMeasure.width - 8;
        const pillY = movArrY - 8;
        ctx.fillStyle = tMoving < 0 ? 'rgba(239,68,68,0.15)' : 'rgba(168,85,247,0.1)';
        ctx.beginPath();
        ctx.roundRect(pillX, pillY, mtMeasure.width + 12, 18, 4);
        ctx.fill();
        ctx.fillStyle = tMoving < 0 ? '#ef4444' : '#a855f7';
        ctx.fillText(mtText, ox - 6, movArrY + 4);

        // If violation, show a prominent marker
        if (tMoving < 0) {
          // Red zone highlight below T=0
          ctx.fillStyle = `rgba(239,68,68,${0.08 * (0.6 + 0.4 * Math.sin(animTime * 0.005))})`;
          ctx.fillRect(ox, oy, plotW, tToY(Math.max(tMoving, -maxTdown)) - oy);

          // CAUSALITY VIOLATION label
          const flashAlpha = 0.7 + 0.3 * Math.sin(animTime * 0.006);
          ctx.fillStyle = `rgba(239,68,68,${flashAlpha})`;
          ctx.font = 'bold 18px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('CAUSALITY VIOLATION', w / 2, tToY(maxTup) + 30);
          ctx.font = '12px system-ui';
          ctx.fillText('Message arrives ' + Math.abs(tMoving * 365.25).toFixed(0) + ' days BEFORE it was sent', w / 2, tToY(maxTup) + 50);
        }
      }

      // --- Animated photons on light cone ---
      const photonPhase = (animTime % 4000) / 4000;
      const photonDist = photonPhase * Math.min(maxX, maxTup);
      const ppx = xToX(photonDist);
      const ppy = tToY(photonDist);
      if (ppy > tToY(maxTup)) {
        const pg = ctx.createRadialGradient(ppx, ppy, 0, ppx, ppy, 6);
        pg.addColorStop(0, 'rgba(251,191,36,0.6)');
        pg.addColorStop(1, 'transparent');
        ctx.fillStyle = pg;
        ctx.fillRect(ppx - 8, ppy - 8, 16, 16);
        ctx.beginPath(); ctx.arc(ppx, ppy, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#fef3c7'; ctx.fill();
      }

      requestAnimationFrame(draw);
    }
    updateReadouts(0, 2.0);
    requestAnimationFrame(draw);
  })();

  // ================================================================
  //  TAB 2: The Paradox Animation
  // ================================================================
  (function initParadox() {
    const { ctx, w, h } = setupCanvas('paradox-canvas');
    const playBtn = document.getElementById('paradox-play');
    const resetBtn = document.getElementById('paradox-reset');
    const speedBtn = document.getElementById('paradox-speed');

    // Physics constants for the scenario
    const dist = ALPHA_CENTAURI; // 4.37 ly
    const ftlS = 2.185; // FTL speed in c — arrives in ~2 years
    const obsV = 0.50; // moving observer velocity
    const obsG = gamma(obsV); // 1.1547
    const tArriveEarth = dist / ftlS; // ~2.0 years
    const tArriveMoving = obsG * (tArriveEarth - obsV * dist); // ~ -0.214 yr
    const replyArriveEarth = tArriveEarth + tArriveMoving; // arrives before T=0

    // Animation state
    let running = false;
    let finished = false;
    let simTime = 0; // simulation time in "phase units" (0 to totalDuration)
    let simSpeed = 1;
    let prevTs = null;

    // Phases with durations (in seconds of real time at 1x)
    const phases = [
      { name: 'send',      duration: 2.5, label: 'Sending FTL Message...' },
      { name: 'arrive',    duration: 1.5, label: 'Message Received!' },
      { name: 'reframe',   duration: 2.5, label: 'Switching to Moving Frame...' },
      { name: 'reply',     duration: 2.5, label: 'Sending FTL Reply...' },
      { name: 'paradox',   duration: 2.0, label: 'Reply Arrives Before Sending!' },
      { name: 'loop',      duration: 4.0, label: 'PARADOX: Causal Loop!' },
    ];
    const totalDuration = phases.reduce((s, p) => s + p.duration, 0);

    function getPhase(t) {
      let acc = 0;
      for (let i = 0; i < phases.length; i++) {
        if (t < acc + phases[i].duration) {
          return { idx: i, phase: phases[i].name, frac: (t - acc) / phases[i].duration, label: phases[i].label };
        }
        acc += phases[i].duration;
      }
      return { idx: phases.length - 1, phase: 'loop', frac: 1, label: phases[phases.length - 1].label };
    }

    // Controls
    playBtn.addEventListener('click', () => {
      if (finished) return;
      if (running) {
        running = false;
        playBtn.textContent = 'Resume';
      } else {
        running = true;
        playBtn.textContent = 'Pause';
      }
    });
    resetBtn.addEventListener('click', () => {
      running = false; finished = false; simTime = 0; prevTs = null;
      playBtn.textContent = 'Play Scenario';
      document.getElementById('px-earth-t').textContent = 'T = 0.00 yr';
      document.getElementById('px-ac-t').textContent = 'T = 0.00 yr';
      document.getElementById('px-moving-t').textContent = "T\u2032 = 0.00 yr";
      document.getElementById('px-phase').textContent = 'Ready';
      document.getElementById('px-phase').style.color = 'var(--muted)';
      document.getElementById('px-msg').textContent = '\u2014';
      document.getElementById('px-msg').className = 'value cyan';
      document.getElementById('px-paradox').textContent = 'None yet';
      document.getElementById('px-paradox').style.color = '#22c55e';
    });
    const speeds = [1, 2, 5, 10];
    let speedIdx = 0;
    speedBtn.addEventListener('click', () => {
      speedIdx = (speedIdx + 1) % speeds.length;
      simSpeed = speeds[speedIdx];
      speedBtn.innerHTML = 'Speed: ' + simSpeed + '&times;';
    });

    function draw(ts) {
      if (prevTs === null) prevTs = ts;
      const dt = Math.min(ts - prevTs, 50);
      prevTs = ts;

      if (running && !finished) {
        simTime += (dt / 1000) * simSpeed;
        if (simTime >= totalDuration) {
          simTime = totalDuration;
          finished = true;
          running = false;
          playBtn.textContent = 'Scenario Complete';
        }
      }

      const { idx, phase, frac, label } = running || finished || simTime > 0
        ? getPhase(simTime) : { idx: -1, phase: 'ready', frac: 0, label: 'Ready' };

      ctx.clearRect(0, 0, w, h);

      // ---- Layout ----
      const sceneH = h * 0.35;
      const stH = h * 0.65;
      const stTop = sceneH;

      // ==============================
      //  SCENE VIEW (top 35%)
      // ==============================
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, w, sceneH);
      ctx.clip();

      // Background
      ctx.fillStyle = '#060a14';
      ctx.fillRect(0, 0, w, sceneH);

      // Some stars
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 50) % w);
        const sy = ((i * 97 + 30) % sceneH);
        ctx.fillRect(sx, sy, 1, 1);
      }

      const earthX = 80;
      const acX_scene = w - 80;
      const midY = sceneH / 2;

      // Earth
      ctx.beginPath();
      ctx.arc(earthX, midY, 22, 0, Math.PI * 2);
      const earthGrad = ctx.createRadialGradient(earthX - 5, midY - 5, 2, earthX, midY, 22);
      earthGrad.addColorStop(0, '#60a5fa');
      earthGrad.addColorStop(0.5, '#2563eb');
      earthGrad.addColorStop(1, '#1e3a5f');
      ctx.fillStyle = earthGrad;
      ctx.fill();
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Earth', earthX, midY + 38);

      // Alpha Centauri (star)
      const starPulse = 0.85 + 0.15 * Math.sin(ts * 0.003);
      ctx.beginPath();
      ctx.arc(acX_scene, midY, 14 * starPulse, 0, Math.PI * 2);
      const starGrad = ctx.createRadialGradient(acX_scene, midY, 0, acX_scene, midY, 14);
      starGrad.addColorStop(0, '#fff');
      starGrad.addColorStop(0.3, '#fbbf24');
      starGrad.addColorStop(1, 'rgba(251,191,36,0)');
      ctx.fillStyle = starGrad;
      ctx.fill();
      // Star glow
      ctx.beginPath();
      ctx.arc(acX_scene, midY, 28, 0, Math.PI * 2);
      const glowGrad = ctx.createRadialGradient(acX_scene, midY, 8, acX_scene, midY, 28);
      glowGrad.addColorStop(0, 'rgba(251,191,36,0.15)');
      glowGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = glowGrad;
      ctx.fill();
      ctx.fillStyle = '#fbbf24';
      ctx.font = 'bold 12px system-ui';
      ctx.fillText('\u03B1 Centauri', acX_scene, midY + 38);

      // Distance label
      ctx.fillStyle = '#64748b';
      ctx.font = '10px system-ui';
      ctx.fillText('4.37 light-years', (earthX + acX_scene) / 2, sceneH - 12);
      // Dashed distance line
      ctx.strokeStyle = 'rgba(100,116,139,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(earthX + 30, sceneH - 16);
      ctx.lineTo(acX_scene - 24, sceneH - 16);
      ctx.stroke();
      ctx.setLineDash([]);

      // ---- Animated signals in scene ----
      const sigRange = acX_scene - earthX - 60;
      const sigStartX = earthX + 30;

      // Phase: send — FTL message travels Earth → AC
      if (phase === 'send') {
        const px = sigStartX + frac * sigRange;
        // Trail
        const trailLen = 80;
        ctx.strokeStyle = 'rgba(6,182,212,0.3)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(Math.max(sigStartX, px - trailLen), midY);
        ctx.lineTo(px, midY);
        ctx.stroke();
        // Pulse
        const pg = ctx.createRadialGradient(px, midY, 0, px, midY, 10);
        pg.addColorStop(0, '#fff');
        pg.addColorStop(0.3, '#06b6d4');
        pg.addColorStop(1, 'transparent');
        ctx.fillStyle = pg;
        ctx.fillRect(px - 12, midY - 12, 24, 24);
        // Label
        ctx.fillStyle = '#06b6d4';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('"HELLO" @ 2.185c', px, midY - 18);
      }

      // Phase: arrive — flash at AC
      if (phase === 'arrive') {
        const flashR = 20 + 15 * (1 - frac);
        const flashA = 0.4 * (1 - frac);
        ctx.beginPath();
        ctx.arc(acX_scene, midY, flashR, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(6,182,212,${flashA})`;
        ctx.fill();
        ctx.fillStyle = '#06b6d4';
        ctx.font = 'bold 12px system-ui';
        ctx.fillText('RECEIVED "HELLO"', (earthX + acX_scene) / 2, midY - 30);
        ctx.font = '11px system-ui';
        ctx.fillText('T = 2.00 yr (Earth frame)', (earthX + acX_scene) / 2, midY - 14);
      }

      // Phase: reframe — visual transition
      if (phase === 'reframe') {
        const flashAlpha = 0.5 + 0.5 * Math.sin(frac * Math.PI * 4);
        ctx.fillStyle = `rgba(168,85,247,${flashAlpha * 0.15})`;
        ctx.fillRect(0, 0, w, sceneH);
        ctx.fillStyle = '#a855f7';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Moving observer (v=0.50c) sees arrival at', w / 2, midY - 24);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 20px Courier New';
        ctx.fillText("T' = -0.21 yr = -78 days", w / 2, midY + 8);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px system-ui';
        ctx.fillText('The message arrived BEFORE it was sent!', w / 2, midY + 32);
      }

      // Phase: reply — FTL reply travels AC → Earth
      if (phase === 'reply') {
        const px = sigStartX + sigRange - frac * sigRange;
        // Trail
        const trailLen = 80;
        ctx.strokeStyle = 'rgba(239,68,68,0.3)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(Math.min(sigStartX + sigRange, px + trailLen), midY);
        ctx.lineTo(px, midY);
        ctx.stroke();
        // Pulse
        const pg = ctx.createRadialGradient(px, midY, 0, px, midY, 10);
        pg.addColorStop(0, '#fff');
        pg.addColorStop(0.3, '#ef4444');
        pg.addColorStop(1, 'transparent');
        ctx.fillStyle = pg;
        ctx.fillRect(px - 12, midY - 12, 24, 24);
        // Label
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('"DON\'T SEND" @ 2.185c', px, midY - 18);
      }

      // Phase: paradox — flash at Earth
      if (phase === 'paradox') {
        const flashR = 25 + 20 * (1 - frac);
        const flashA = 0.5 * (1 - frac * 0.5);
        ctx.beginPath();
        ctx.arc(earthX, midY, flashR, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(239,68,68,${flashA})`;
        ctx.fill();
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Reply arrives BEFORE original was sent!', w / 2, midY - 28);
        ctx.font = 'bold 16px Courier New';
        ctx.fillText('T(reply) < T(send) = 0', w / 2, midY + 4);
      }

      // Phase: loop — the paradox revealed
      if (phase === 'loop') {
        const pulse = 0.5 + 0.5 * Math.sin(ts * 0.005);
        ctx.fillStyle = `rgba(239,68,68,${0.08 * pulse})`;
        ctx.fillRect(0, 0, w, sceneH);

        // Circular arrow showing the loop
        ctx.strokeStyle = `rgba(239,68,68,${0.6 + 0.4 * pulse})`;
        ctx.lineWidth = 3;
        const cx = w / 2, cy = midY;
        const rr = 50;
        ctx.beginPath();
        ctx.arc(cx, cy, rr, -Math.PI * 0.8, Math.PI * 0.6);
        ctx.stroke();
        // Arrowhead
        const aAngle = Math.PI * 0.6;
        const ax = cx + rr * Math.cos(aAngle);
        const ay = cy + rr * Math.sin(aAngle);
        ctx.fillStyle = `rgba(239,68,68,${0.6 + 0.4 * pulse})`;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + 10, ay - 6);
        ctx.lineTo(ax + 4, ay + 8);
        ctx.closePath();
        ctx.fill();

        ctx.textAlign = 'center';
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 13px system-ui';
        ctx.fillText('CAUSAL LOOP PARADOX', cx, cy - 8);
        ctx.font = '11px system-ui';
        ctx.fillStyle = '#f87171';
        ctx.fillText('If you receive "DON\'T SEND" before sending...', cx, cy + 8);
        ctx.fillText('do you send? Either answer = contradiction', cx, cy + 24);
      }

      ctx.restore(); // end scene clip

      // Divider line
      ctx.strokeStyle = '#1e293b';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, sceneH); ctx.lineTo(w, sceneH); ctx.stroke();

      // ==============================
      //  SPACETIME DIAGRAM (bottom 65%)
      // ==============================
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, stTop, w, stH);
      ctx.clip();

      // Background
      ctx.fillStyle = '#080c16';
      ctx.fillRect(0, stTop, w, stH);

      const stMargin = { left: 80, right: 40, top: 30, bottom: 40 };
      const stPlotW = w - stMargin.left - stMargin.right;
      const stPlotH = stH - stMargin.top - stMargin.bottom;
      const stOx = stMargin.left;
      const stOy = stTop + stMargin.top + stPlotH * 0.7; // origin shifted down
      const stMaxX = 8;
      const stMaxTup = 5;
      const stMaxTdown = 2;
      const stXScale = stPlotW / stMaxX;
      const stTScale = stPlotH / (stMaxTup + stMaxTdown);
      const stTtoY = (t) => stOy - t * stTScale;
      const stXtoX = (x) => stOx + x * stXScale;

      // Grid
      ctx.strokeStyle = 'rgba(30,41,59,0.4)';
      ctx.lineWidth = 0.5;
      for (let i = -Math.floor(stMaxTdown); i <= stMaxTup; i++) {
        const gy = stTtoY(i);
        ctx.beginPath(); ctx.moveTo(stOx, gy); ctx.lineTo(stOx + stPlotW, gy); ctx.stroke();
      }
      for (let i = 0; i <= stMaxX; i += 2) {
        const gx = stXtoX(i);
        ctx.beginPath(); ctx.moveTo(gx, stTtoY(-stMaxTdown)); ctx.lineTo(gx, stTtoY(stMaxTup)); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(stOx, stTtoY(-stMaxTdown)); ctx.lineTo(stOx, stTtoY(stMaxTup)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(stOx, stOy); ctx.lineTo(stOx + stPlotW, stOy); ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      for (let i = 0; i <= stMaxX; i += 2) ctx.fillText(i + ' ly', stXtoX(i), stOy + 16);
      ctx.textAlign = 'right';
      for (let i = -Math.floor(stMaxTdown); i <= stMaxTup; i++) {
        ctx.fillText((i >= 0 ? '+' : '') + i + 'yr', stOx - 6, stTtoY(i) + 4);
      }

      // Light cone from origin
      ctx.strokeStyle = 'rgba(245,158,11,0.4)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(stOx, stOy);
      ctx.lineTo(stXtoX(Math.min(stMaxX, stMaxTup)), stTtoY(Math.min(stMaxX, stMaxTup)));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(stOx, stOy);
      ctx.lineTo(stXtoX(Math.min(stMaxX, stMaxTdown)), stTtoY(-Math.min(stMaxX, stMaxTdown)));
      ctx.stroke();
      ctx.fillStyle = 'rgba(245,158,11,0.35)';
      ctx.font = 'italic 10px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('c', stXtoX(2.5), stTtoY(2.5) - 6);

      // Earth worldline
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(stOx, stTtoY(-stMaxTdown));
      ctx.lineTo(stOx, stTtoY(stMaxTup));
      ctx.stroke();
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Earth', stOx, stTtoY(stMaxTup) - 6);

      // Alpha Centauri worldline
      const stAcX = stXtoX(dist);
      ctx.strokeStyle = '#06b6d4';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(stAcX, stTtoY(-stMaxTdown));
      ctx.lineTo(stAcX, stTtoY(stMaxTup));
      ctx.stroke();
      ctx.fillStyle = '#06b6d4';
      ctx.font = 'bold 10px system-ui';
      ctx.fillText('\u03B1 Cen', stAcX, stTtoY(stMaxTup) - 6);

      // ---- Animated events based on phase ----
      // Event A: Send at (x=0, t=0)
      const evSendX = stOx;
      const evSendY = stOy;

      // Event B: Arrive at (x=4.37, t=2.0)
      const evArrX = stAcX;
      const evArrY = stTtoY(tArriveEarth);

      // Event C: Reply arrives at Earth at negative time
      const replyArrT = tArriveEarth + tArriveMoving; // ~1.79 yr but via moving frame perspective
      // For the paradox, the reply arrives BEFORE T=0
      const evReplyX = stOx;
      const evReplyY = stTtoY(tArriveMoving); // at the negative time

      // Compute animation progress for each element
      const showSendLine = phase !== 'ready';
      const showArrival = idx >= 1; // arrive phase or later
      const showReframe = idx >= 2; // reframe or later
      const showReplyLine = idx >= 3; // reply or later
      const showParadox = idx >= 4; // paradox or later
      const showLoop = idx >= 5;

      // Send event marker (always visible once started)
      if (showSendLine) {
        ctx.beginPath();
        ctx.arc(evSendX, evSendY, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('SEND (T=0)', evSendX + 8, evSendY - 6);
      }

      // FTL message line (Earth → AC)
      if (showSendLine) {
        const msgFrac = phase === 'send' ? frac : 1;
        const curX = lerp(evSendX, evArrX, msgFrac);
        const curY = lerp(evSendY, evArrY, msgFrac);
        // Glow
        ctx.strokeStyle = 'rgba(6,182,212,0.2)';
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(evSendX, evSendY); ctx.lineTo(curX, curY); ctx.stroke();
        // Dashed core
        ctx.strokeStyle = '#06b6d4';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(evSendX, evSendY); ctx.lineTo(curX, curY); ctx.stroke();
        ctx.setLineDash([]);
        // Traveling pulse
        if (phase === 'send') {
          const pg = ctx.createRadialGradient(curX, curY, 0, curX, curY, 8);
          pg.addColorStop(0, '#fff');
          pg.addColorStop(0.4, '#06b6d4');
          pg.addColorStop(1, 'transparent');
          ctx.fillStyle = pg;
          ctx.fillRect(curX - 10, curY - 10, 20, 20);
        }
        // Label
        ctx.fillStyle = '#06b6d4';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'center';
        const mlx = (evSendX + evArrX) / 2;
        const mly = (evSendY + evArrY) / 2;
        if (msgFrac > 0.3) {
          ctx.fillText('"HELLO" (2.185c)', mlx + 40, mly + 5);
        }
      }

      // Arrival marker
      if (showArrival) {
        ctx.beginPath();
        ctx.arc(evArrX, evArrY, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#06b6d4';
        ctx.fill();
        ctx.fillStyle = '#06b6d4';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText('ARRIVE (T=+2.0yr)', evArrX - 8, evArrY - 6);
      }

      // Moving observer's simultaneity line
      if (showReframe) {
        const simSlope = obsV;
        const simX2 = stMaxX;
        const simT2 = simSlope * simX2;
        ctx.strokeStyle = 'rgba(168,85,247,0.15)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(stOx, stOy);
        ctx.lineTo(stXtoX(simX2), stTtoY(simT2));
        ctx.stroke();
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(stOx, stOy);
        ctx.lineTo(stXtoX(simX2), stTtoY(simT2));
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#a855f7';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText("Moving observer's \"now\"", stXtoX(simX2) - 130, stTtoY(simT2) - 8);

        // Show the T' arrival time annotation
        const movArrY = stTtoY(tArriveMoving);
        ctx.strokeStyle = 'rgba(239,68,68,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(evArrX, movArrY);
        ctx.lineTo(stOx, movArrY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText("T'=-0.21yr (-78 days)", stOx - 4, movArrY + 4);
      }

      // Reply line (AC → Earth, arriving at negative time)
      if (showReplyLine) {
        const replyFrac = phase === 'reply' ? frac : 1;
        const rStartX = evArrX;
        const rStartY = evArrY;
        const rEndX = evReplyX;
        const rEndY = evReplyY;
        const curX = lerp(rStartX, rEndX, replyFrac);
        const curY = lerp(rStartY, rEndY, replyFrac);
        // Glow
        ctx.strokeStyle = 'rgba(239,68,68,0.2)';
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(rStartX, rStartY); ctx.lineTo(curX, curY); ctx.stroke();
        // Dashed core
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(rStartX, rStartY); ctx.lineTo(curX, curY); ctx.stroke();
        ctx.setLineDash([]);
        // Pulse
        if (phase === 'reply') {
          const pg = ctx.createRadialGradient(curX, curY, 0, curX, curY, 8);
          pg.addColorStop(0, '#fff');
          pg.addColorStop(0.4, '#ef4444');
          pg.addColorStop(1, 'transparent');
          ctx.fillStyle = pg;
          ctx.fillRect(curX - 10, curY - 10, 20, 20);
        }
        // Label
        if (replyFrac > 0.3) {
          ctx.fillStyle = '#ef4444';
          ctx.font = '9px system-ui';
          ctx.textAlign = 'center';
          const rlx = (rStartX + rEndX) / 2;
          const rly = (rStartY + rEndY) / 2;
          ctx.fillText('"DON\'T SEND" (2.185c)', rlx - 40, rly - 5);
        }
      }

      // Reply arrival marker (below T=0!)
      if (showParadox) {
        ctx.beginPath();
        ctx.arc(evReplyX, evReplyY, 6, 0, Math.PI * 2);
        ctx.fillStyle = '#ef4444';
        ctx.fill();
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('REPLY ARRIVES', evReplyX + 10, evReplyY - 8);
        ctx.fillText('BEFORE SEND!', evReplyX + 10, evReplyY + 6);

        // Red zone below T=0
        const zoneAlpha = 0.08 * (0.6 + 0.4 * Math.sin(ts * 0.004));
        ctx.fillStyle = `rgba(239,68,68,${zoneAlpha})`;
        ctx.fillRect(stOx, stOy, stPlotW, stTtoY(Math.max(tArriveMoving, -stMaxTdown)) - stOy);
      }

      // Causal loop highlight
      if (showLoop) {
        const loopPulse = 0.5 + 0.5 * Math.sin(ts * 0.005);
        // Highlight the triangle formed by send→arrive→reply-arrive
        ctx.strokeStyle = `rgba(239,68,68,${0.4 + 0.3 * loopPulse})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(evSendX, evSendY);
        ctx.lineTo(evArrX, evArrY);
        ctx.lineTo(evReplyX, evReplyY);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = `rgba(239,68,68,${0.04 + 0.03 * loopPulse})`;
        ctx.fill();

        // PARADOX label
        ctx.fillStyle = `rgba(239,68,68,${0.7 + 0.3 * loopPulse})`;
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('CAUSAL LOOP', (evSendX + evArrX) / 2, (evSendY + evArrY + evReplyY) / 3 + 4);
      }

      ctx.restore(); // end spacetime clip

      // ---- Update readouts ----
      if (running || finished || simTime > 0) {
        const phaseEl = document.getElementById('px-phase');
        phaseEl.textContent = label;
        phaseEl.style.color = showParadox ? '#ef4444' : showReframe ? '#a855f7' : '#06b6d4';

        // Earth clock shows simulation progress through Earth time
        let earthT = 0;
        if (phase === 'send') earthT = frac * tArriveEarth;
        else if (idx >= 1 && idx < 3) earthT = tArriveEarth;
        else if (phase === 'reply') earthT = tArriveEarth + frac * tArriveMoving;
        else if (idx >= 4) earthT = tArriveEarth + tArriveMoving;
        document.getElementById('px-earth-t').textContent = 'T = ' + earthT.toFixed(2) + ' yr';

        // AC clock
        let acT = 0;
        if (idx >= 1) acT = tArriveEarth;
        document.getElementById('px-ac-t').textContent = 'T = ' + acT.toFixed(2) + ' yr';

        // Moving frame
        let movT = 0;
        if (idx >= 2) movT = tArriveMoving;
        const movTEl = document.getElementById('px-moving-t');
        movTEl.textContent = "T\u2032 = " + movT.toFixed(2) + ' yr';
        movTEl.className = 'value ' + (movT < 0 ? 'red' : 'purple');

        // Message content
        const msgEl = document.getElementById('px-msg');
        if (phase === 'send') { msgEl.textContent = '"HELLO"'; msgEl.className = 'value cyan'; msgEl.style.fontSize = '1rem'; }
        else if (phase === 'arrive') { msgEl.textContent = '"HELLO" received'; msgEl.className = 'value cyan'; msgEl.style.fontSize = '1rem'; }
        else if (phase === 'reframe') { msgEl.textContent = 'Frame shift...'; msgEl.className = 'value purple'; msgEl.style.fontSize = '1rem'; }
        else if (phase === 'reply') { msgEl.textContent = '"DON\'T SEND"'; msgEl.className = 'value red'; msgEl.style.fontSize = '1rem'; }
        else if (showParadox) { msgEl.textContent = '"DON\'T SEND"'; msgEl.className = 'value red'; msgEl.style.fontSize = '1rem'; }

        // Paradox
        const pxEl = document.getElementById('px-paradox');
        if (showLoop) {
          const pPulse = Math.sin(ts * 0.004) > 0;
          pxEl.textContent = pPulse ? 'PARADOX!' : 'CAUSAL LOOP';
          pxEl.style.color = '#ef4444';
        } else if (showParadox) {
          pxEl.textContent = 'Time reversed!';
          pxEl.style.color = '#ef4444';
        } else if (showReframe) {
          pxEl.textContent = 'Negative time...';
          pxEl.style.color = '#f59e0b';
        } else {
          pxEl.textContent = 'None yet';
          pxEl.style.color = '#22c55e';
        }
      }

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  })();
})();

// ==================== SPACETIME CURVATURE 3D ====================
(function initCurvature() {
  if (typeof THREE === 'undefined') {
    // Three.js might not have loaded yet (defer). Wait for it.
    if (document.readyState === 'complete') return;
    window.addEventListener('load', function() {
      if (typeof THREE !== 'undefined') initCurvatureScene();
    });
    return;
  }
  initCurvatureScene();

  function initCurvatureScene() {
    const container = document.getElementById('curvature-container');
    if (!container) return;

    // ---- Scene setup ----
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x060a14, 0.012);

    const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 28, 38);
    camera.lookAt(0, -3, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x060a14);
    container.appendChild(renderer.domElement);

    // OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 10;
    controls.maxDistance = 80;
    controls.maxPolarAngle = Math.PI * 0.85;
    controls.target.set(0, -3, 0);

    // Lighting
    scene.add(new THREE.AmbientLight(0x334466, 0.6));
    const dirLight = new THREE.DirectionalLight(0xaabbff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    const pointLight = new THREE.PointLight(0x3b82f6, 0.4, 60);
    pointLight.position.set(0, 15, 0);
    scene.add(pointLight);

    // Resize
    const onResize = () => {
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    };
    window.addEventListener('resize', onResize);

    // ---- Grid (spacetime fabric) ----
    const GRID_SIZE = 40;
    const GRID_SEG = 60;
    const gridGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEG, GRID_SEG);
    gridGeo.rotateX(-Math.PI / 2);

    const origPos = new Float32Array(gridGeo.attributes.position.array);
    const vertCount = gridGeo.attributes.position.count;
    const colors = new Float32Array(vertCount * 3);
    // Init colors to blue (flat space)
    for (let i = 0; i < vertCount; i++) {
      colors[i * 3] = 0.2; colors[i * 3 + 1] = 0.4; colors[i * 3 + 2] = 1.0;
    }
    gridGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const gridMat = new THREE.MeshPhongMaterial({
      vertexColors: true, transparent: true, opacity: 0.7,
      side: THREE.DoubleSide, shininess: 30, specular: new THREE.Color(0x112244)
    });
    const gridMesh = new THREE.Mesh(gridGeo, gridMat);
    scene.add(gridMesh);

    // Wireframe sharing same position buffer
    const n = GRID_SEG + 1;
    const wireIndices = [];
    for (let j = 0; j < n; j++) {
      for (let i = 0; i < GRID_SEG; i++) {
        wireIndices.push(j * n + i, j * n + i + 1);
        wireIndices.push(i * n + j, (i + 1) * n + j);
      }
    }
    const wireGeo = new THREE.BufferGeometry();
    wireGeo.setAttribute('position', gridGeo.attributes.position);
    wireGeo.setIndex(wireIndices);
    const wireMat = new THREE.LineBasicMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.18 });
    const wireframe = new THREE.LineSegments(wireGeo, wireMat);
    scene.add(wireframe);

    // ---- State ----
    const masses = [];
    const particles = [];
    const MAX_MASSES = 5;
    const MAX_PARTICLES = 12;
    const TRAIL_LEN = 300;
    const massGroup = new THREE.Group();
    const particleGroup = new THREE.Group();
    const straightGroup = new THREE.Group();
    scene.add(massGroup);
    scene.add(particleGroup);
    scene.add(straightGroup);

    let currentMode = 'place';
    let crossSectionMode = false;
    let showStraightness = false;
    let showCrossSections = true;
    let view3D = false;
    let mouseDownPos = null;

    // ---- 3D Spherical shells ----
    const sphereGroup = new THREE.Group();
    sphereGroup.visible = false;
    scene.add(sphereGroup);
    const shellRadii = [8, 14, 20];
    const shellDetail = 3;
    const shells = [];
    const shellOrigPositions = [];

    for (let si = 0; si < shellRadii.length; si++) {
      const r = shellRadii[si];
      const geo = new THREE.IcosahedronGeometry(r, shellDetail);
      const vc = geo.attributes.position.count;
      const cols = new Float32Array(vc * 3);
      for (let i = 0; i < vc; i++) { cols[i*3]=0.2; cols[i*3+1]=0.4; cols[i*3+2]=1.0; }
      geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
      const mat = new THREE.MeshPhongMaterial({
        vertexColors: true, transparent: true, opacity: 0.15 + si * 0.05,
        side: THREE.DoubleSide, shininess: 20, depthWrite: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      const wGeo = new THREE.WireframeGeometry(geo);
      const wMat = new THREE.LineBasicMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.22 - si * 0.04 });
      const wire = new THREE.LineSegments(wGeo, wMat);
      sphereGroup.add(mesh);
      sphereGroup.add(wire);
      shells.push({ geo, mesh, wire, wGeo, radius: r });
      shellOrigPositions.push(new Float32Array(geo.attributes.position.array));
    }

    function updateSphereShells() {
      for (let si = 0; si < shells.length; si++) {
        const sh = shells[si];
        const pos = sh.geo.attributes.position.array;
        const orig = shellOrigPositions[si];
        const col = sh.geo.attributes.color.array;
        const vc = sh.geo.attributes.position.count;
        for (let i = 0; i < vc; i++) {
          const ix = i * 3;
          let ox = orig[ix], oy = orig[ix+1], oz = orig[ix+2];
          let totalPull = 0;
          let px = ox, py = oy, pz = oz;
          for (const m of masses) {
            const dx = ox - m.x, dy = oy, dz = oz - m.z;
            const r = Math.max(Math.sqrt(dx*dx + dy*dy + dz*dz), 0.5);
            const pull = m.strength / (r * r) * 2.5;
            totalPull += m.strength / r;
            px -= (dx / r) * pull;
            py -= (dy / r) * pull;
            pz -= (dz / r) * pull;
          }
          pos[ix] = px; pos[ix+1] = py; pos[ix+2] = pz;
          const phi = Math.min(totalPull * 0.08, 0.499);
          const tau = Math.sqrt(1 - 2 * phi);
          col[ix]   = lerp(1.0, 0.15, tau);
          col[ix+1] = lerp(0.12, 0.35, tau);
          col[ix+2] = lerp(0.05, 1.0, tau);
        }
        sh.geo.attributes.position.needsUpdate = true;
        sh.geo.attributes.color.needsUpdate = true;
        sh.geo.computeVertexNormals();
        // Rebuild wireframe
        sh.wire.geometry.dispose();
        sh.wire.geometry = new THREE.WireframeGeometry(sh.geo);
      }
    }

    // ---- Cross-section rings (3 orthogonal planes) ----
    const crossRingsGroup = new THREE.Group();
    crossRingsGroup.visible = false;
    scene.add(crossRingsGroup);
    const RING_PTS = 120;
    const RING_R = 16;
    const ringColors = [0xf59e0b, 0x06b6d4, 0xa855f7]; // XZ, XY, YZ
    const ringLabels = ['XZ (horizontal)', 'XY (vertical)', 'YZ (vertical)'];
    const crossRings = [];

    for (let ri = 0; ri < 3; ri++) {
      const pts = new Float32Array((RING_PTS + 1) * 3);
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
      const mat = new THREE.LineBasicMaterial({ color: ringColors[ri], transparent: true, opacity: 0.6, linewidth: 2 });
      const line = new THREE.LineLoop(geo, mat);
      crossRingsGroup.add(line);
      crossRings.push({ geo, pts, line });
    }

    function updateCrossRings() {
      if (!showCrossSections || !view3D) { crossRingsGroup.visible = false; return; }
      crossRingsGroup.visible = true;
      for (let ri = 0; ri < 3; ri++) {
        const ring = crossRings[ri];
        const pts = ring.pts;
        for (let i = 0; i <= RING_PTS; i++) {
          const angle = (i / RING_PTS) * Math.PI * 2;
          let x, y, z;
          if (ri === 0) { x = RING_R * Math.cos(angle); y = 0; z = RING_R * Math.sin(angle); }
          else if (ri === 1) { x = RING_R * Math.cos(angle); y = RING_R * Math.sin(angle); z = 0; }
          else { x = 0; y = RING_R * Math.sin(angle); z = RING_R * Math.cos(angle); }
          // Pull toward masses
          for (const m of masses) {
            const dx = x - m.x, dy2 = y, dz = z - m.z;
            const r = Math.max(Math.sqrt(dx*dx + dy2*dy2 + dz*dz), 0.5);
            const pull = m.strength / (r * r) * 2.5;
            x -= (dx / r) * pull;
            y -= (dy2 / r) * pull;
            z -= (dz / r) * pull;
          }
          const ix = i * 3;
          pts[ix] = x; pts[ix+1] = y; pts[ix+2] = z;
        }
        ring.geo.attributes.position.needsUpdate = true;
      }
    }

    // ---- Grid deformation ----
    function updateGrid() {
      const pos = gridGeo.attributes.position.array;
      const col = gridGeo.attributes.color.array;
      for (let i = 0; i < vertCount; i++) {
        const ix = i * 3;
        const vx = origPos[ix], vz = origPos[ix + 2];
        let dy = 0, totalPot = 0;
        for (const m of masses) {
          const dx = vx - m.x, dz = vz - m.z;
          const r = Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
          dy -= m.strength / r;
          totalPot += m.strength / r;
        }
        dy = Math.max(dy, -18);
        pos[ix + 1] = dy;
        // Color: time dilation τ = sqrt(1 - 2Φ), Φ normalized
        const phi = Math.min(totalPot * 0.08, 0.499);
        const tau = Math.sqrt(1 - 2 * phi);
        col[ix]     = lerp(1.0, 0.15, tau);
        col[ix + 1] = lerp(0.12, 0.35, tau);
        col[ix + 2] = lerp(0.05, 1.0, tau);
      }
      gridGeo.attributes.position.needsUpdate = true;
      gridGeo.attributes.color.needsUpdate = true;
      gridGeo.computeVertexNormals();
    }

    // ---- Mass management ----
    function addMass(x, z, strength, isBlackHole) {
      if (masses.length >= MAX_MASSES) return;
      const radius = 0.4 + strength * 0.06;
      const sGeo = new THREE.SphereGeometry(radius, 20, 20);
      const sMat = new THREE.MeshPhongMaterial({
        color: isBlackHole ? 0x000000 : 0xf59e0b,
        emissive: isBlackHole ? 0x110000 : 0xf59e0b,
        emissiveIntensity: isBlackHole ? 0.1 : 0.35,
        transparent: true, opacity: 0.9
      });
      const sphere = new THREE.Mesh(sGeo, sMat);
      // Glow
      const gGeo = new THREE.SphereGeometry(radius * 2.2, 16, 16);
      const gMat = new THREE.MeshBasicMaterial({
        color: isBlackHole ? 0xef4444 : 0xf59e0b,
        transparent: true, opacity: 0.12
      });
      const glow = new THREE.Mesh(gGeo, gMat);
      const mass = { x, z, strength, mesh: sphere, glowMesh: glow, extras: [] };
      // Black hole accretion ring
      if (isBlackHole) {
        const ringGeo = new THREE.TorusGeometry(radius * 2.5, 0.2, 8, 32);
        ringGeo.rotateX(Math.PI / 2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.5 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        mass.extras.push(ring);
        massGroup.add(ring);
      }
      masses.push(mass);
      massGroup.add(sphere);
      massGroup.add(glow);
      updateGrid();
      updateMassPositions();
      updateReadouts();
    }

    function updateMassPositions() {
      for (const mass of masses) {
        let dy = 0;
        for (const m of masses) {
          const dx = mass.x - m.x, dz = mass.z - m.z;
          const r = Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
          dy -= m.strength / r;
        }
        dy = Math.max(dy, -18);
        mass.mesh.position.set(mass.x, dy, mass.z);
        mass.glowMesh.position.set(mass.x, dy, mass.z);
        for (const e of mass.extras) e.position.set(mass.x, dy, mass.z);
      }
    }

    function clearMasses() {
      for (const m of masses) {
        massGroup.remove(m.mesh); massGroup.remove(m.glowMesh);
        m.mesh.geometry.dispose(); m.mesh.material.dispose();
        m.glowMesh.geometry.dispose(); m.glowMesh.material.dispose();
        for (const e of m.extras) {
          massGroup.remove(e); e.geometry.dispose(); e.material.dispose();
        }
      }
      masses.length = 0;
      updateGrid();
      updateReadouts();
    }

    // ---- Helpers ----
    function potentialAt(x, z) {
      let pot = 0;
      for (const m of masses) {
        const dx = x - m.x, dz = z - m.z;
        pot += m.strength / Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
      }
      return pot;
    }

    function nearestMass(x, z) {
      let best = null, bd = Infinity;
      for (const m of masses) {
        const d = Math.sqrt((x - m.x) ** 2 + (z - m.z) ** 2);
        if (d < bd) { bd = d; best = m; }
      }
      return best;
    }

    function gridYAt(x, z) {
      let dy = 0;
      for (const m of masses) {
        const dx = x - m.x, dz = z - m.z;
        dy -= m.strength / Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
      }
      return Math.max(dy, -18);
    }

    // ---- Particle system ----
    function addParticle(px, py_in, pz, vx, vy_in, vz, color) {
      if (particles.length >= MAX_PARTICLES) removeParticle(0);
      const c = color || 0x06b6d4;
      const geo = new THREE.SphereGeometry(0.3, 10, 10);
      const mat = new THREE.MeshBasicMaterial({ color: c });
      const mesh = new THREE.Mesh(geo, mat);
      const gGeo = new THREE.SphereGeometry(0.6, 8, 8);
      const gMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.2 });
      const glowMesh = new THREE.Mesh(gGeo, gMat);
      const trailPos = new Float32Array(TRAIL_LEN * 3);
      const py = view3D ? (py_in || 0) : gridYAt(px, pz) + 0.35;
      const vy = view3D ? (vy_in || 0) : 0;
      for (let i = 0; i < TRAIL_LEN; i++) {
        trailPos[i*3] = px; trailPos[i*3+1] = py; trailPos[i*3+2] = pz;
      }
      const tGeo = new THREE.BufferGeometry();
      tGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
      const tMat = new THREE.LineBasicMaterial({ color: c, transparent: true, opacity: 0.35 });
      const trail = new THREE.Line(tGeo, tMat);
      const p = {
        x: px, y: py, z: pz, vx, vy, vz,
        prevX: px - vx * 0.016, prevY: py - vy * 0.016, prevZ: pz - vz * 0.016,
        mesh, glowMesh, trail, trailGeo: tGeo, trailPos,
        trailIdx: 0, totalAngle: 0, lastAngle: null,
        orbitTimer: 0, alive: true, startX: px, startY: py, startZ: pz
      };
      particles.push(p);
      particleGroup.add(mesh); particleGroup.add(glowMesh); particleGroup.add(trail);
      updateReadouts();
    }

    function rainParticles() {
      clearParticles();
      if (masses.length === 0) return;
      const m = masses[0];
      const dist = 12;
      const dirs = [
        [dist,0,0], [-dist,0,0], [0,dist,0], [0,-dist,0], [0,0,dist], [0,0,-dist]
      ];
      const rainColors = [0xef4444, 0x3b82f6, 0x22c55e, 0xf59e0b, 0xa855f7, 0x06b6d4];
      dirs.forEach((d, i) => {
        addParticle(m.x + d[0], d[1], m.z + d[2], 0, 0, 0, rainColors[i]);
      });
    }

    function removeParticle(i) {
      const p = particles[i];
      particleGroup.remove(p.mesh); particleGroup.remove(p.glowMesh); particleGroup.remove(p.trail);
      p.mesh.geometry.dispose(); p.mesh.material.dispose();
      p.glowMesh.geometry.dispose(); p.glowMesh.material.dispose();
      p.trailGeo.dispose(); p.trail.material.dispose();
      particles.splice(i, 1);
    }

    function clearParticles() {
      while (particles.length > 0) removeParticle(0);
      updateReadouts();
    }

    function stepParticles(dt) {
      const STEP = 0.012;
      const steps = Math.max(1, Math.ceil(dt / STEP));
      const sDt = dt / steps;
      for (const p of particles) {
        if (!p.alive) continue;
        for (let s = 0; s < steps; s++) {
          let ax = 0, ay = 0, az = 0;
          for (const m of masses) {
            const dx = p.x - m.x;
            const dy = view3D ? p.y : 0;
            const dz = p.z - m.z;
            const r2 = dx*dx + dy*dy + dz*dz;
            const r = Math.max(Math.sqrt(r2), 0.4);
            const r3 = r * r * r;
            ax -= m.strength * dx / r3;
            if (view3D) ay -= m.strength * dy / r3;
            az -= m.strength * dz / r3;
          }
          const nx = 2 * p.x - p.prevX + ax * sDt * sDt;
          const nz = 2 * p.z - p.prevZ + az * sDt * sDt;
          p.prevX = p.x; p.prevZ = p.z;
          p.x = nx; p.z = nz;
          if (view3D) {
            const ny = 2 * p.y - p.prevY + ay * sDt * sDt;
            p.prevY = p.y; p.y = ny;
          }
        }
        p.vx = (p.x - p.prevX) / sDt;
        p.vz = (p.z - p.prevZ) / sDt;
        p.vy = view3D ? (p.y - p.prevY) / sDt : 0;
        const py = view3D ? p.y : gridYAt(p.x, p.z) + 0.35;
        if (!view3D) p.y = py;
        p.mesh.position.set(p.x, py, p.z);
        p.glowMesh.position.set(p.x, py, p.z);
        // Trail
        p.trailIdx = (p.trailIdx + 1) % TRAIL_LEN;
        const ti = p.trailIdx * 3;
        p.trailPos[ti] = p.x; p.trailPos[ti+1] = py; p.trailPos[ti+2] = p.z;
        p.trailGeo.attributes.position.needsUpdate = true;
        // Orbital angle tracking
        const nm = nearestMass(p.x, p.z);
        if (nm) {
          const angle = Math.atan2(p.z - nm.z, p.x - nm.x);
          if (p.lastAngle !== null) {
            let da = angle - p.lastAngle;
            if (da > Math.PI) da -= 2 * Math.PI;
            if (da < -Math.PI) da += 2 * Math.PI;
            p.totalAngle += Math.abs(da);
          }
          p.lastAngle = angle;
          p.orbitTimer += dt;
        }
        // Kill if out of bounds
        const hg = GRID_SIZE / 2 + 5;
        if (Math.abs(p.x) > hg || Math.abs(p.z) > hg) p.alive = false;
        if (view3D && Math.abs(p.y) > hg) p.alive = false;
        // Kill if absorbed
        for (const m of masses) {
          const dy2 = view3D ? p.y * p.y : 0;
          const dr = Math.sqrt((p.x - m.x) ** 2 + dy2 + (p.z - m.z) ** 2);
          if (dr < 0.25) p.alive = false;
        }
      }
      for (let i = particles.length - 1; i >= 0; i--) {
        if (!particles[i].alive) removeParticle(i);
      }
    }

    // ---- Presets ----
    const PRESETS = {
      earth:     [{ x: 0, z: 0, strength: 1.5, bh: false }],
      sun:       [{ x: 0, z: 0, strength: 5.0, bh: false }],
      blackhole: [{ x: 0, z: 0, strength: 15.0, bh: true }],
      binary:    [{ x: -5, z: 0, strength: 4.0, bh: false }, { x: 5, z: 0, strength: 4.0, bh: false }]
    };

    function loadPreset(name) {
      clearMasses(); clearParticles();
      const preset = PRESETS[name];
      if (!preset) return;
      for (const p of preset) addMass(p.x, p.z, p.strength, p.bh);
      document.getElementById('curv-mass-slider').value = preset[0].strength * 10;
      document.getElementById('curv-mass-label').textContent = preset[0].strength.toFixed(1);
    }

    // ---- Cross-section ----
    const csPoints = [];
    for (let i = 0; i < n; i++) csPoints.push(new THREE.Vector3(0, 0, 0));
    const csGeo = new THREE.BufferGeometry().setFromPoints(csPoints);
    const csLine = new THREE.Line(csGeo, new THREE.LineBasicMaterial({ color: 0xf59e0b, linewidth: 2 }));
    csLine.visible = false;
    scene.add(csLine);

    function updateCrossSection() {
      if (!crossSectionMode) { csLine.visible = false; return; }
      csLine.visible = true;
      const pos = gridGeo.attributes.position.array;
      const lp = csGeo.attributes.position.array;
      const mid = Math.floor(n / 2);
      for (let i = 0; i < n; i++) {
        const idx = (mid * n + i) * 3;
        lp[i * 3] = pos[idx]; lp[i * 3 + 1] = pos[idx + 1]; lp[i * 3 + 2] = pos[idx + 2];
      }
      csGeo.attributes.position.needsUpdate = true;
    }

    // ---- Geodesic straightness ----
    function updateStraightnessVis() {
      while (straightGroup.children.length > 0) {
        const ch = straightGroup.children[0];
        straightGroup.remove(ch);
        if (ch.geometry) ch.geometry.dispose();
        if (ch.material) ch.material.dispose();
      }
      if (!showStraightness || particles.length === 0) return;
      for (const p of particles) {
        // Flat-space straight line
        const sy = view3D ? (p.startY || 0) : 0.15;
        const ey = view3D ? p.y : 0.15;
        const flatGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(p.startX, sy, p.startZ),
          new THREE.Vector3(p.x, ey, p.z)
        ]);
        const flatMat = new THREE.LineDashedMaterial({
          color: 0xef4444, dashSize: 0.5, gapSize: 0.3, transparent: true, opacity: 0.6
        });
        const flatLine = new THREE.Line(flatGeo, flatMat);
        flatLine.computeLineDistances();
        straightGroup.add(flatLine);
        // Geodesic highlight (trail on curved surface)
        const geoPoints = [];
        for (let i = 0; i < TRAIL_LEN; i++) {
          const idx = ((p.trailIdx + 1 + i) % TRAIL_LEN) * 3;
          geoPoints.push(new THREE.Vector3(
            p.trailPos[idx], p.trailPos[idx + 1] + 0.15, p.trailPos[idx + 2]
          ));
        }
        const geodGeo = new THREE.BufferGeometry().setFromPoints(geoPoints);
        const geodMat = new THREE.LineBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.6 });
        straightGroup.add(new THREE.Line(geodGeo, geodMat));
      }
    }

    // ---- Raycasting ----
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const gridPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

    container.addEventListener('mousedown', (e) => {
      mouseDownPos = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('click', (e) => {
      if (currentMode === 'rain') { rainParticles(); return; }
      // Ignore drags (OrbitControls)
      if (mouseDownPos) {
        const dx = e.clientX - mouseDownPos.x, dy = e.clientY - mouseDownPos.y;
        if (dx * dx + dy * dy > 25) return;
      }
      const rect = container.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = new THREE.Vector3();
      if (!raycaster.ray.intersectPlane(gridPlane, hit)) return;
      const hg = GRID_SIZE / 2;
      const ix = clamp(hit.x, -hg, hg), iz = clamp(hit.z, -hg, hg);

      if (currentMode === 'place') {
        const str = parseFloat(document.getElementById('curv-mass-slider').value) / 10;
        addMass(ix, iz, str, false);
        if (view3D) { updateSphereShells(); updateCrossRings(); }
      } else if (currentMode === 'drop') {
        const py = view3D ? 12 : 0;
        addParticle(ix, py, iz, 0, 0, 0);
      } else if (currentMode === 'orbit' || currentMode === 'orbits') {
        const speed = parseFloat(document.getElementById('curv-launch-speed').value) / 100;
        const inclDeg = parseFloat(document.getElementById('curv-inclination').value);
        const incl = inclDeg * Math.PI / 180;
        const nm = nearestMass(ix, iz);
        if (nm) {
          const dx = ix - nm.x, dz = iz - nm.z;
          const d = Math.max(Math.sqrt(dx * dx + dz * dz), 0.1);
          const spd = speed * 8;
          const ci = Math.cos(incl), si = Math.sin(incl);
          const hx = -dz / d, hz = dx / d;
          addParticle(ix, 0, iz, hx * spd * ci, spd * si, hz * spd * ci);
        } else {
          addParticle(ix, 0, iz, speed * 8, 0, 0);
        }
      }
    });

    // Tooltip on hover
    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(gridPlane, hit)) {
        const pot = potentialAt(hit.x, hit.z);
        const phi = Math.min(pot * 0.08, 0.499);
        const tau = Math.sqrt(Math.max(0, 1 - 2 * phi));
        const tip = document.getElementById('curv-tooltip');
        if (masses.length > 0) {
          tip.style.display = 'block';
          document.getElementById('curv-tip-potential').textContent = pot.toFixed(3);
          document.getElementById('curv-tip-dilation').textContent = tau.toFixed(4);
          document.getElementById('curv-dilation').textContent = tau.toFixed(4);
        } else {
          tip.style.display = 'none';
        }
      }
    });
    container.addEventListener('mouseleave', () => {
      document.getElementById('curv-tooltip').style.display = 'none';
    });

    // ---- Controls wiring ----
    // ---- Mode buttons ----
    const modeMap = { 'curv-mode-place': 'place', 'curv-mode-drop': 'drop', 'curv-mode-orbit': 'orbit', 'curv-mode-rain': 'rain', 'curv-mode-orbits': 'orbits' };
    const modeIds = Object.keys(modeMap);
    Object.entries(modeMap).forEach(([id, mode]) => {
      document.getElementById(id).addEventListener('click', () => {
        currentMode = mode;
        modeIds.forEach(bid => document.getElementById(bid).classList.toggle('active', bid === id));
        // Show inclination slider for orbit modes
        document.getElementById('curv-inclination-group').style.display = (mode === 'orbit' || mode === 'orbits') ? 'block' : 'none';
        // Show orbital presets for orbits mode
        document.getElementById('curv-orbit-presets').style.display = mode === 'orbits' ? 'flex' : 'none';
        if (mode !== 'orbits') {
          document.getElementById('curv-orbit-info').style.display = 'none';
          document.getElementById('curv-orbit-info').textContent = '';
        }
        if (mode === 'rain') {
          rainParticles();
          container.style.cursor = 'default';
        } else {
          container.style.cursor = mode === 'place' ? 'crosshair' : mode === 'drop' ? 'pointer' : 'cell';
        }
      });
    });

    // ---- Presets ----
    ['earth', 'sun', 'blackhole', 'binary'].forEach(name => {
      const btn = document.getElementById('curv-preset-' + (name === 'blackhole' ? 'bh' : name));
      if (btn) btn.addEventListener('click', () => {
        document.querySelectorAll('#sec-curvature [data-preset]').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        loadPreset(name);
        if (view3D) { updateSphereShells(); updateCrossRings(); }
      });
    });

    document.getElementById('curv-clear').addEventListener('click', () => {
      clearMasses(); clearParticles();
      document.querySelectorAll('#sec-curvature [data-preset]').forEach(b => b.classList.remove('active'));
      if (view3D) { updateSphereShells(); updateCrossRings(); }
    });

    // ---- Sliders ----
    document.getElementById('curv-mass-slider').addEventListener('input', (e) => {
      document.getElementById('curv-mass-label').textContent = (e.target.value / 10).toFixed(1);
    });
    document.getElementById('curv-launch-speed').addEventListener('input', (e) => {
      document.getElementById('curv-speed-label').textContent = (e.target.value / 100).toFixed(2);
    });
    document.getElementById('curv-inclination').addEventListener('input', (e) => {
      document.getElementById('curv-incl-label').textContent = e.target.value + '\u00B0';
    });

    // ---- 2D / 3D view toggle ----
    function switchView(to3D) {
      view3D = to3D;
      document.getElementById('curv-view-2d').classList.toggle('active', !to3D);
      document.getElementById('curv-view-3d').classList.toggle('active', to3D);
      // 2D elements
      gridMesh.visible = !to3D && document.getElementById('curv-show-grid').checked;
      wireframe.visible = !to3D && document.getElementById('curv-show-grid').checked;
      csLine.visible = false;
      // 3D elements
      sphereGroup.visible = to3D;
      crossRingsGroup.visible = to3D && showCrossSections;
      if (to3D) {
        updateSphereShells();
        updateCrossRings();
        camera.position.set(0, 20, 45);
        controls.target.set(0, 0, 0);
      } else {
        camera.position.set(0, 28, 38);
        controls.target.set(0, -3, 0);
      }
      clearParticles();
    }
    document.getElementById('curv-view-2d').addEventListener('click', () => switchView(false));
    document.getElementById('curv-view-3d').addEventListener('click', () => switchView(true));

    // ---- Checkboxes ----
    document.getElementById('curv-cross-sections').addEventListener('change', (e) => {
      showCrossSections = e.target.checked;
      crossRingsGroup.visible = view3D && showCrossSections;
    });
    document.getElementById('curv-straightness').addEventListener('change', (e) => {
      showStraightness = e.target.checked;
      if (!showStraightness) {
        while (straightGroup.children.length > 0) {
          const ch = straightGroup.children[0];
          straightGroup.remove(ch);
          if (ch.geometry) ch.geometry.dispose();
          if (ch.material) ch.material.dispose();
        }
      }
    });
    document.getElementById('curv-show-grid').addEventListener('change', (e) => {
      gridMesh.visible = !view3D && e.target.checked;
      wireframe.visible = !view3D && e.target.checked;
    });

    // ---- Readouts ----
    function updateReadouts() {
      document.getElementById('curv-mass-count').textContent = masses.length;
      document.getElementById('curv-particle-count').textContent = particles.length;
      if (particles.length > 0) {
        const p = particles[particles.length - 1];
        const spd = Math.sqrt(p.vx * p.vx + (p.vy || 0) * (p.vy || 0) + p.vz * p.vz);
        document.getElementById('curv-particle-vel').textContent = spd.toFixed(3);
        if (p.totalAngle > 2 * Math.PI && p.orbitTimer > 0) {
          const period = p.orbitTimer * (2 * Math.PI) / p.totalAngle;
          document.getElementById('curv-orbit-period').textContent = period.toFixed(2) + 's';
        } else {
          document.getElementById('curv-orbit-period').innerHTML = '&mdash;';
        }
      } else {
        document.getElementById('curv-particle-vel').textContent = '0.000';
        document.getElementById('curv-orbit-period').innerHTML = '&mdash;';
      }
    }

    // ---- Orbital plane presets ----
    function hslToHex(h, s, l) {
      s /= 100; l /= 100;
      const k = n => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      return (Math.round(f(0) * 255) << 16) + (Math.round(f(8) * 255) << 8) + Math.round(f(4) * 255);
    }

    const orbitalPresets = {
      '3plane': {
        massStrength: 5.0,
        info: 'Three identical orbits in perpendicular planes. Same mass, same distance, same speed \u2014 only the orientation differs. All are equally stable, proving gravity has no preferred direction.',
        orbits: [
          { distance: 8, inclination: 0,              azimuth: 0,            color: 0x06b6d4 },
          { distance: 8, inclination: Math.PI / 2,    azimuth: Math.PI / 2,  color: 0xef4444 },
          { distance: 8, inclination: Math.PI / 4,    azimuth: Math.PI,      color: 0x22c55e },
        ]
      },
      'solar': {
        massStrength: 5.0,
        info: 'Planets orbit mostly near the ecliptic plane, but Pluto\u2019s 17\u00B0 tilt and comets at extreme angles show gravity works identically in every orientation. The ecliptic is not special \u2014 it\u2019s just where the dust happened to settle.',
        orbits: [
          { distance: 6,  inclination: 7    * Math.PI / 180, azimuth: 0,               color: 0x9ca3af },
          { distance: 8,  inclination: 0,                    azimuth: Math.PI / 3,      color: 0x3b82f6 },
          { distance: 10, inclination: 1.85 * Math.PI / 180, azimuth: 2 * Math.PI / 3, color: 0xef4444 },
          { distance: 13, inclination: 17   * Math.PI / 180, azimuth: Math.PI,          color: 0xa855f7 },
          { distance: 15, inclination: 62   * Math.PI / 180, azimuth: 4 * Math.PI / 3, color: 0xf59e0b },
        ]
      },
      'globular': {
        massStrength: 8.0,
        info: 'Stars in a globular cluster orbit in every direction \u2014 no preferred plane. This is gravity\u2019s natural state: truly spherically symmetric. Every orientation is equally valid.',
        orbits: null
      }
    };

    function generateGlobularOrbits() {
      const orbits = [];
      const count = 8;
      const hueStep = 360 / count;
      for (let i = 0; i < count; i++) {
        const t = (i + 0.5) / count;
        const inclination = Math.acos(2 * t - 1);
        const azimuth = i * 2.3998;
        const distance = 7 + (i % 3) * 2.5;
        orbits.push({ distance, inclination, azimuth, color: hslToHex(i * hueStep, 80, 60) });
      }
      return orbits;
    }

    function launchOrbitalPreset(name) {
      const preset = orbitalPresets[name];
      if (!preset) return;
      clearMasses();
      clearParticles();
      addMass(0, 0, preset.massStrength, name === 'globular');
      // Switch to 3D before adding particles (switchView clears particles)
      if (!view3D) switchView(true);
      document.getElementById('curv-mass-slider').value = preset.massStrength * 10;
      document.getElementById('curv-mass-label').textContent = preset.massStrength.toFixed(1);
      document.querySelectorAll('#sec-curvature [data-preset]').forEach(b => b.classList.remove('active'));
      updateSphereShells();
      updateCrossRings();
      const orbits = name === 'globular' ? generateGlobularOrbits() : preset.orbits;
      for (const orb of orbits) {
        const px = orb.distance * Math.cos(orb.azimuth);
        const pz = orb.distance * Math.sin(orb.azimuth);
        const d = orb.distance;
        const hx = -pz / d, hz = px / d;
        const spd = Math.sqrt(preset.massStrength / d) * 5.0;
        const ci = Math.cos(orb.inclination), si = Math.sin(orb.inclination);
        addParticle(px, 0, pz, hx * spd * ci, spd * si, hz * spd * ci, orb.color);
      }
      document.getElementById('curv-orbit-info').textContent = preset.info;
      document.getElementById('curv-orbit-info').style.display = 'block';
    }

    ['3plane', 'solar', 'globular'].forEach(name => {
      document.getElementById('curv-orbpreset-' + name).addEventListener('click', () => {
        document.querySelectorAll('#curv-orbit-presets .tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('curv-orbpreset-' + name).classList.add('active');
        launchOrbitalPreset(name);
      });
    });

    // ---- Animation loop ----
    let prevTime = null;
    let frameCount = 0;

    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (prevTime === null) prevTime = timestamp;
      const dt = Math.min((timestamp - prevTime) / 1000, 0.05);
      prevTime = timestamp;
      frameCount++;

      controls.update();

      // Step particles
      if (masses.length > 0 && particles.length > 0) stepParticles(dt);

      // Update visuals
      if (view3D) {
        if (frameCount % 4 === 0 && masses.length > 0) { updateSphereShells(); updateCrossRings(); }
      } else {
        updateCrossSection();
      }
      if (showStraightness && frameCount % 3 === 0) updateStraightnessVis();

      // Animate mass glow pulse
      for (const m of masses) {
        m.glowMesh.material.opacity = 0.08 + 0.06 * Math.sin(timestamp * 0.003);
        for (const e of m.extras) {
          e.rotation.z = timestamp * 0.0005;
          e.material.opacity = 0.35 + 0.15 * Math.sin(timestamp * 0.002);
        }
      }

      // Readouts every 6 frames
      if (frameCount % 6 === 0) updateReadouts();

      renderer.render(scene, camera);
    }

    // Load default preset and start
    loadPreset('earth');
    requestAnimationFrame(animate);
  }
})();

// ==================== ROUNDRECT POLYFILL ====================
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, radii) {
    const r = Array.isArray(radii) ? radii[0] : (radii || 0);
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
  };
}
</script>

</body>
</html>
