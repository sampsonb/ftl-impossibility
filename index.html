<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Why Faster-Than-Light Travel Is Impossible</title>
<style>
  :root {
    --bg: #0a0e1a;
    --card: #111827;
    --border: #1e293b;
    --accent: #3b82f6;
    --accent2: #8b5cf6;
    --accent3: #06b6d4;
    --warn: #f59e0b;
    --danger: #ef4444;
    --text: #e2e8f0;
    --muted: #94a3b8;
    --dim: #475569;
  }

  * { margin: 0; padding: 0; box-sizing: border-box; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    line-height: 1.6;
    overflow-x: hidden;
  }

  /* Starfield background */
  #starfield {
    position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    z-index: 0; pointer-events: none;
  }

  .content-wrap {
    position: relative; z-index: 1;
  }

  /* Hero */
  .hero {
    text-align: center;
    padding: 60px 20px 20px;
    background: linear-gradient(180deg, rgba(59,130,246,0.08) 0%, transparent 100%);
  }
  .hero h1 {
    font-size: clamp(2rem, 5vw, 3.5rem);
    font-weight: 800;
    background: linear-gradient(135deg, #60a5fa, #a78bfa, #06b6d4);
    -webkit-background-clip: text; background-clip: text;
    -webkit-text-fill-color: transparent;
    margin-bottom: 16px;
    letter-spacing: -0.02em;
  }
  .hero p {
    color: var(--muted);
    font-size: 1.15rem;
    max-width: 680px;
    margin: 0 auto;
  }
  .hero .equation-hero {
    font-size: clamp(1.4rem, 3vw, 2.2rem);
    margin: 20px 0 0;
    font-family: 'Georgia', serif;
    font-style: italic;
    color: var(--accent3);
    text-shadow: 0 0 30px rgba(6,182,212,0.3);
  }

  /* Sections */
  section {
    max-width: 1100px;
    margin: 0 auto;
    padding: 40px 20px;
  }
  section h2 {
    font-size: 1.8rem;
    font-weight: 700;
    margin-bottom: 8px;
    color: #f1f5f9;
  }
  section h2 .num {
    color: var(--accent);
    font-size: 0.9em;
    margin-right: 6px;
  }
  section > .subtitle {
    color: var(--muted);
    margin-bottom: 30px;
    font-size: 1.05rem;
  }

  /* Cards */
  .card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 16px;
    padding: 30px;
    margin-bottom: 24px;
  }
  .card h3 {
    font-size: 1.15rem;
    margin-bottom: 12px;
    color: #f1f5f9;
  }

  /* Canvas containers */
  .canvas-wrap {
    background: #080c16;
    border-radius: 12px;
    overflow: hidden;
    margin: 16px 0;
    position: relative;
  }
  .canvas-wrap canvas {
    display: block;
    width: 100%;
    height: auto;
  }

  /* Sliders */
  .slider-group {
    margin: 20px 0;
  }
  .slider-group label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-weight: 600;
    font-size: 0.95rem;
  }
  .slider-group label .val {
    color: var(--accent3);
    font-family: 'Courier New', monospace;
    font-weight: 700;
  }
  input[type="range"] {
    -webkit-appearance: none;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: var(--border);
    outline: none;
  }
  input[type="range"]::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 20px; height: 20px;
    border-radius: 50%;
    background: var(--accent);
    cursor: pointer;
    box-shadow: 0 0 10px rgba(59,130,246,0.5);
    transition: transform 0.15s;
  }
  input[type="range"]::-webkit-slider-thumb:hover {
    transform: scale(1.2);
  }

  /* Readouts */
  .readouts {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
    gap: 12px;
    margin: 20px 0;
  }
  .readout {
    background: rgba(59,130,246,0.06);
    border: 1px solid rgba(59,130,246,0.15);
    border-radius: 10px;
    padding: 14px 16px;
    text-align: center;
  }
  .readout .label {
    font-size: 0.78rem;
    color: var(--muted);
    text-transform: uppercase;
    letter-spacing: 0.05em;
    margin-bottom: 4px;
  }
  .readout .value {
    font-size: 1.4rem;
    font-weight: 700;
    font-family: 'Courier New', monospace;
  }
  .readout .value.blue { color: var(--accent); }
  .readout .value.cyan { color: var(--accent3); }
  .readout .value.purple { color: var(--accent2); }
  .readout .value.yellow { color: var(--warn); }
  .readout .value.red { color: var(--danger); }

  /* Derivation */
  .derivation {
    background: rgba(139,92,246,0.06);
    border: 1px solid rgba(139,92,246,0.15);
    border-radius: 12px;
    padding: 24px;
    margin: 20px 0;
  }
  .derivation h4 {
    color: var(--accent2);
    margin-bottom: 12px;
    font-size: 1rem;
  }
  .deriv-step {
    font-family: 'Georgia', serif;
    font-style: italic;
    font-size: 1.15rem;
    color: var(--text);
    padding: 8px 0;
    border-bottom: 1px solid rgba(139,92,246,0.1);
    display: flex;
    align-items: center;
    gap: 12px;
  }
  .deriv-step:last-child { border-bottom: none; }
  .deriv-step .step-num {
    font-family: system-ui; font-style: normal;
    background: var(--accent2);
    color: #fff;
    width: 26px; height: 26px;
    border-radius: 50%;
    display: flex; align-items: center; justify-content: center;
    font-size: 0.75rem; font-weight: 700;
    flex-shrink: 0;
  }
  .deriv-step .annotation {
    font-family: system-ui; font-style: normal;
    font-size: 0.82rem;
    color: var(--muted);
    margin-left: auto;
  }

  /* Examples grid */
  .examples-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
    gap: 16px;
  }
  .example-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 14px;
    padding: 24px;
    transition: transform 0.2s, border-color 0.2s;
  }
  .example-card:hover {
    transform: translateY(-3px);
    border-color: var(--accent);
  }
  .example-card .icon {
    font-size: 2rem;
    margin-bottom: 10px;
  }
  .example-card h4 {
    font-size: 1.05rem;
    margin-bottom: 8px;
    color: #f1f5f9;
  }
  .example-card p {
    font-size: 0.9rem;
    color: var(--muted);
    line-height: 1.5;
  }
  .example-card .stat {
    margin-top: 12px;
    padding: 8px 12px;
    background: rgba(59,130,246,0.08);
    border-radius: 8px;
    font-family: 'Courier New', monospace;
    font-size: 0.85rem;
    color: var(--accent3);
  }

  /* Tabs */
  .tab-bar {
    display: flex;
    gap: 4px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  .tab-btn {
    background: transparent;
    border: 1px solid var(--border);
    color: var(--muted);
    padding: 8px 18px;
    border-radius: 8px;
    cursor: pointer;
    font-size: 0.9rem;
    font-weight: 600;
    transition: all 0.2s;
  }
  .tab-btn:hover { border-color: var(--accent); color: var(--text); }
  .tab-btn.active {
    background: var(--accent);
    border-color: var(--accent);
    color: #fff;
  }
  .tab-content { display: none; }
  .tab-content.active { display: block; }

  /* Footer */
  footer {
    text-align: center;
    padding: 40px 20px 60px;
    color: var(--dim);
    font-size: 0.9rem;
  }

  /* Divider */
  .section-divider {
    max-width: 1100px;
    margin: 0 auto;
    padding: 0 20px;
  }
  .section-divider hr {
    border: none;
    border-top: 1px solid var(--border);
  }

  /* Clock comparison layout */
  .clock-row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
  }
  @media (max-width: 700px) {
    .clock-row { grid-template-columns: 1fr; }
  }
  .clock-label {
    text-align: center;
    font-weight: 700;
    font-size: 0.9rem;
    margin-bottom: 6px;
    color: var(--muted);
  }

  /* Explanation text */
  .explain {
    color: var(--muted);
    font-size: 0.92rem;
    line-height: 1.7;
    margin: 12px 0;
  }
  .explain strong { color: var(--text); }

  /* Spacetime diagram region labels */
  .st-legend {
    display: flex;
    gap: 16px;
    flex-wrap: wrap;
    margin: 14px 0 6px;
  }
  .st-legend-item {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.85rem;
    color: var(--muted);
  }
  .st-legend-item .swatch {
    width: 14px; height: 14px;
    border-radius: 3px;
    flex-shrink: 0;
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 8px; }
  ::-webkit-scrollbar-track { background: var(--bg); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }

  /* ==================== CURVATURE SECTION LAYOUT ==================== */

  /* Card becomes flex column: container on top, controls pinned to bottom */
  #sec-curvature .card { display: flex; flex-direction: column; gap: 0; padding: 0; overflow: visible; padding-bottom: 28vh; }
  #sec-curvature .card > .explain { padding: 16px 20px 0; margin: 0; }
  #sec-curvature .card > .explain:last-of-type { padding-bottom: 8px; }

  /* 3D container fills viewport above pinned controls */
  #curvature-container { width: 100% !important; height: calc(100vh - 28vh) !important; min-height: 400px; border-radius: 0 !important; margin: 0 !important; position: relative; overflow: hidden; background: #060a14; cursor: grab; }
  #curvature-container canvas { display: block; }

  /* Info overlay (top-right of 3D view) */
  #curv-info-overlay { position: absolute; top: 10px; right: 10px; background: rgba(17,24,39,0.85); border: 1px solid var(--border); border-radius: 8px; padding: 6px 10px; font-size: 0.72rem; color: var(--muted); pointer-events: none; z-index: 6; line-height: 1.6; min-width: 140px; }
  #curv-info-overlay .curv-info-row { display: flex; justify-content: space-between; gap: 8px; }
  #curv-info-overlay .curv-info-val { color: var(--accent3); font-family: 'JetBrains Mono', monospace; }
  #curv-info-overlay .curv-info-label { color: var(--dim); }

  /* Tooltip */
  #curv-tooltip { z-index: 10; backdrop-filter: blur(8px); }

  /* Bottom panel — fixed to viewport bottom when curvature section is active */
  #curv-bottom-panel { display: none; position: fixed; bottom: 0; left: 0; right: 0; z-index: 900; background: rgba(10,14,26,0.95); backdrop-filter: blur(12px); border-top: 1px solid var(--border); max-height: 30vh; overflow-y: auto; }
  #sec-curvature.curv-section-active #curv-bottom-panel { display: block; }

  /* Control panel grid inside bottom panel */
  #curv-control-panel { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 12px; padding: 10px 16px; }

  /* Column layout */
  .curv-col { display: flex; flex-direction: column; gap: 6px; min-width: 0; }
  .curv-col-header { font-size: 0.72rem; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.06em; padding-bottom: 4px; border-bottom: 1px solid rgba(255,255,255,0.06); margin-bottom: 2px; }

  /* Button groups */
  .curv-btn-group { display: flex; gap: 4px; flex-wrap: wrap; }
  .curv-btn-group .tab-btn { font-size: 0.75rem; padding: 4px 8px; }
  .curv-btn-group-label { color: var(--dim); font-size: 0.68rem; margin-bottom: 1px; }

  /* Compact sliders in control panel */
  #curv-control-panel .slider-group { margin: 0; }
  #curv-control-panel .slider-group label { font-size: 0.75rem; }
  #curv-control-panel .slider-group input[type="range"] { height: 4px; }

  /* 2-column checkbox grid */
  .curv-check-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 1px 10px; }
  .curv-check-grid label { display: flex; align-items: center; gap: 4px; cursor: pointer; font-size: 0.73rem; color: var(--muted); white-space: nowrap; }
  #sec-curvature input[type="checkbox"] { accent-color: var(--accent); width: 13px; height: 13px; cursor: pointer; }

  /* Collapsible sections */
  .curv-collapse-header { font-size: 0.72rem; font-weight: 700; color: var(--accent); text-transform: uppercase; letter-spacing: 0.06em; padding: 4px 0; cursor: pointer; user-select: none; border-bottom: 1px solid rgba(255,255,255,0.06); margin-bottom: 2px; }
  .curv-collapse-header:hover { color: var(--accent2); }
  .curv-collapse-body { overflow: hidden; max-height: 0; transition: max-height 0.3s ease; display: flex; flex-direction: column; gap: 6px; }
  .curv-collapse-body.open { max-height: 600px; }

  /* Help section content */
  #curv-help-body { font-size: 0.72rem; color: var(--dim); line-height: 1.5; padding-top: 4px; }
  #curv-help-body p { margin: 0 0 4px; }
  #curv-help-body strong { color: var(--muted); }

  /* Context-sensitive states */
  .curv-disabled { opacity: 0.35; filter: saturate(0.3); }
  .curv-ctx-hidden { display: none !important; }

  /* Compact readout strip — sits inside the fixed control panel wrapper */
  #curv-readout-strip { padding: 4px 16px 0; }
  #curv-readout-strip.readouts { gap: 6px; grid-template-columns: repeat(auto-fit, minmax(100px, 1fr)); margin: 0; }
  #curv-readout-strip .readout { padding: 4px 8px; }
  #curv-readout-strip .readout .label { font-size: 0.65rem; }
  #curv-readout-strip .readout .value { font-size: 0.85rem; }

  /* Fullscreen */
  #curvature-container.curv-fullscreen { position: fixed !important; top: 0; left: 0; width: 100vw !important; height: 100vh !important; max-height: none !important; z-index: 9999; border-radius: 0 !important; margin: 0 !important; }
  #curvature-container.curv-fullscreen #curv-fullscreen-close { display: block !important; }
  #curvature-container.curv-fullscreen #curv-fullscreen-instructions { display: block !important; }

  /* In fullscreen, bottom panel hidden by default, H key reveals it */
  .curv-fs-active #curv-bottom-panel { display: none !important; }
  .curv-fs-active.curv-fs-controls-visible #curv-bottom-panel { display: block !important; z-index: 10000; }
  .curv-fs-active #curv-info-overlay { display: block !important; }

  /* Post-container explanations */
  #sec-curvature .card > .explain-bottom { padding: 12px 20px; margin: 0; }

  /* Responsive: stack columns on narrow screens */
  @media (max-width: 900px) {
    #curv-control-panel { grid-template-columns: 1fr; gap: 10px; padding: 10px 12px; }
    #curv-bottom-panel { max-height: 35vh; }
    #curvature-container { height: calc(100vh - 35vh) !important; min-height: 300px; }
    .curv-check-grid { grid-template-columns: 1fr 1fr; }
    #sec-curvature .card { padding-bottom: 35vh; }
  }
  @media (max-width: 600px) {
    #curvature-container { height: calc(100vh - 40vh) !important; min-height: 250px; }
    #curv-bottom-panel { max-height: 40vh; }
    .curv-btn-group .tab-btn { font-size: 0.68rem; padding: 3px 6px; }
    #curv-control-panel .slider-group label { font-size: 0.68rem; }
    .curv-check-grid label { font-size: 0.66rem; }
    #sec-curvature .card { padding-bottom: 40vh; }
  }

  /* ==================== DIFFICULTY LEVEL SYSTEM ==================== */

  /* Toggle bar in hero */
  .difficulty-toggle { display:flex; gap:8px; justify-content:center; align-items:center; margin:18px 0 4px; flex-wrap:wrap; }
  .dt-label { color:var(--muted); font-size:0.85rem; margin-right:4px; }
  .dt-btn { background:transparent; border:1px solid var(--border); color:var(--muted); padding:10px 20px; border-radius:10px; cursor:pointer; text-align:center; transition:all 0.3s; font-family:inherit; font-size:0.85rem; }
  .dt-btn:hover { border-color:var(--text); color:var(--text); }
  .dt-btn .dt-icon { font-size:1rem; }
  .dt-btn .dt-sub { display:block; font-size:0.65rem; opacity:0.6; margin-top:2px; }
  .dt-btn[data-level="beginner"].active { background:rgba(34,197,94,0.15); border-color:#22c55e; color:#22c55e; }
  .dt-btn[data-level="intermediate"].active { background:rgba(245,158,11,0.15); border-color:#f59e0b; color:#f59e0b; }
  .dt-btn[data-level="advanced"].active { background:rgba(239,68,68,0.15); border-color:#ef4444; color:#ef4444; }

  /* Level-based content visibility — default hidden */
  .level-beg, .level-int, .level-adv { display: none; }
  .level-beg-inline, .level-int-inline, .level-adv-inline { display: none; }

  /* Show content matching current level */
  body.level-beginner .level-beg { display: block; }
  body.level-beginner .level-beg-inline { display: inline; }
  body.level-intermediate .level-int { display: block; }
  body.level-intermediate .level-int-inline { display: inline; }
  body.level-advanced .level-adv { display: block; }
  body.level-advanced .level-adv-inline { display: inline; }

  /* Equation blocks: hidden in beginner */
  body.level-beginner .eq-only { display: none !important; }

  /* Derivation blocks: only in advanced */
  .deriv-only { display: none; }
  body.level-advanced .deriv-only { display: block; }

  /* Hide complex readouts in beginner */
  body.level-beginner .readout-adv { display: none; }

  /* Section difficulty badges */
  .section-badge { display:inline-block; font-size:0.65rem; padding:2px 8px; border-radius:4px; margin-left:8px; vertical-align:middle; font-weight:600; letter-spacing:0.03em; text-transform:uppercase; }
  .badge-beginner { background:rgba(34,197,94,0.15); color:#22c55e; }
  .badge-intermediate { background:rgba(245,158,11,0.15); color:#f59e0b; }
  .badge-advanced { background:rgba(239,68,68,0.15); color:#ef4444; }

  /* Technical term tooltips */
  .term { border-bottom:1px dotted var(--muted); cursor:help; position:relative; }
  body.level-advanced .term { border-bottom:none; cursor:default; }
  .term-tip { display:none; position:absolute; bottom:calc(100% + 4px); left:50%; transform:translateX(-50%); background:var(--card); border:1px solid var(--border); border-radius:8px; padding:8px 12px; font-size:0.78rem; color:var(--muted); white-space:nowrap; z-index:100; pointer-events:none; box-shadow:0 4px 12px rgba(0,0,0,0.4); }
  .term:hover .term-tip { display:block; }
  body.level-advanced .term:hover .term-tip { display:none; }

  /* Recommended path banner (beginner only) */
  .rec-path { background:rgba(34,197,94,0.08); border:1px solid rgba(34,197,94,0.25); border-radius:10px; padding:12px 20px; margin:0 0 20px; font-size:0.85rem; color:#22c55e; text-align:center; }

  /* Hero equation subtitle (beginner) */
  .equation-hero-sub { font-size:0.9rem; color:var(--muted); margin-top:6px; }

  /* Per-section level switch buttons */
  .level-switch { display:flex; gap:6px; margin:8px 0 4px; }
  .ls-btn { background:transparent; border:1px solid var(--border); color:var(--muted); padding:4px 12px; border-radius:6px; cursor:pointer; font-size:0.75rem; font-family:inherit; transition:all 0.2s; }
  .ls-btn:hover { border-color:var(--text); color:var(--text); }
  .ls-btn.active { background:rgba(59,130,246,0.15); border-color:var(--accent); color:var(--accent); }

  /* Per-section overrides — when a card has a local override, show that level's content regardless of global */
  .card.level-override-beg .level-beg { display: block !important; }
  .card.level-override-beg .level-int { display: none !important; }
  .card.level-override-beg .level-adv { display: none !important; }
  .card.level-override-adv .level-adv { display: block !important; }
  .card.level-override-adv .level-int { display: none !important; }
  .card.level-override-adv .level-beg { display: none !important; }

  /* ==================== NETFLIX LANDING PAGE ==================== */
  html { scroll-behavior: smooth; }
  section[id] { scroll-margin-top: 60px; }

  .hero {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    padding-bottom: 60px;
    position: relative;
  }
  .hero > * { width: 100%; }

  .hero-scroll-hint {
    position: absolute;
    bottom: 30px;
    left: 50%;
    transform: translateX(-50%);
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    color: var(--dim);
    font-size: 0.8rem;
    letter-spacing: 0.05em;
    text-transform: uppercase;
    animation: hero-bounce 2s ease-in-out infinite;
    width: auto !important;
  }
  .hero-scroll-hint .chevron {
    width: 20px; height: 20px;
    border-right: 2px solid var(--dim);
    border-bottom: 2px solid var(--dim);
    transform: rotate(45deg);
  }
  @keyframes hero-bounce {
    0%, 100% { transform: translateX(-50%) translateY(0); }
    50% { transform: translateX(-50%) translateY(8px); }
  }

  .hero-progress {
    max-width: 500px;
    margin: 24px auto 0;
  }
  .hero-progress-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 0.8rem;
    color: var(--muted);
    margin-bottom: 6px;
  }
  .hero-progress-label .progress-pct {
    color: var(--accent3);
    font-weight: 700;
    font-family: 'Courier New', monospace;
  }
  .hero-progress-bar {
    width: 100%;
    height: 6px;
    background: var(--border);
    border-radius: 3px;
    overflow: hidden;
  }
  .hero-progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--accent), var(--accent2), var(--accent3));
    border-radius: 3px;
    transition: width 0.6s cubic-bezier(0.22, 1, 0.36, 1);
  }

  /* Module card grid */
  .module-grid-section {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px 60px;
  }
  .module-grid-heading {
    text-align: center;
    margin-bottom: 40px;
  }
  .module-grid-heading h2 {
    font-size: 1.6rem;
    font-weight: 700;
    color: #f1f5f9;
    margin-bottom: 8px;
  }
  .module-grid-heading p {
    color: var(--muted);
    font-size: 0.95rem;
  }
  .module-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
    gap: 20px;
  }
  @media (min-width: 1100px) {
    .module-grid { grid-template-columns: repeat(3, 1fr); }
  }

  .module-card {
    background: var(--card);
    border: 1px solid var(--border);
    border-radius: 16px;
    cursor: pointer;
    transition: transform 0.3s cubic-bezier(0.22, 1, 0.36, 1), border-color 0.3s, box-shadow 0.3s;
    overflow: hidden;
    display: flex;
    flex-direction: column;
  }
  .module-card:hover {
    transform: translateY(-6px);
    border-color: var(--accent);
    box-shadow: 0 12px 40px rgba(59,130,246,0.15), 0 0 0 1px rgba(59,130,246,0.1);
  }
  .module-card.visited { border-color: rgba(34,197,94,0.3); }
  .module-card.visited:hover {
    border-color: rgba(34,197,94,0.6);
    box-shadow: 0 12px 40px rgba(34,197,94,0.12);
  }

  .module-card-thumb {
    height: 100px;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
    overflow: hidden;
  }
  .module-card-thumb.thumb-beginner {
    background: linear-gradient(135deg, rgba(34,197,94,0.08) 0%, rgba(6,182,212,0.06) 100%);
  }
  .module-card-thumb.thumb-intermediate {
    background: linear-gradient(135deg, rgba(245,158,11,0.08) 0%, rgba(139,92,246,0.06) 100%);
  }
  .module-card-thumb.thumb-advanced {
    background: linear-gradient(135deg, rgba(239,68,68,0.08) 0%, rgba(245,158,11,0.06) 100%);
  }
  .module-card-thumb::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image:
      linear-gradient(rgba(255,255,255,0.02) 1px, transparent 1px),
      linear-gradient(90deg, rgba(255,255,255,0.02) 1px, transparent 1px);
    background-size: 20px 20px;
  }
  .module-card-icon {
    font-size: 2.4rem;
    opacity: 0.9;
    transition: transform 0.4s cubic-bezier(0.22, 1, 0.36, 1);
    z-index: 1;
  }
  .module-card:hover .module-card-icon { transform: scale(1.15); }

  .module-card-body {
    padding: 18px 20px 20px;
    flex: 1;
    display: flex;
    flex-direction: column;
  }
  .module-card-header {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 8px;
  }
  .module-card-num {
    font-size: 0.75rem;
    font-weight: 700;
    color: var(--accent);
    font-family: 'Courier New', monospace;
    letter-spacing: 0.05em;
  }
  .module-card-header .section-badge { margin-left: 0; }
  .module-card-title {
    font-size: 1.05rem;
    font-weight: 700;
    color: #f1f5f9;
    margin-bottom: 6px;
    line-height: 1.3;
  }
  .module-card-desc {
    font-size: 0.85rem;
    color: var(--muted);
    line-height: 1.5;
    flex: 1;
  }
  .module-card-footer {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-top: 14px;
    padding-top: 12px;
    border-top: 1px solid var(--border);
  }
  .module-card-status {
    display: flex;
    align-items: center;
    gap: 6px;
    font-size: 0.75rem;
    color: var(--dim);
    text-transform: uppercase;
    letter-spacing: 0.04em;
    font-weight: 600;
  }
  .module-card-status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--border);
    transition: background 0.3s;
  }
  .module-card.visited .module-card-status-dot {
    background: #22c55e;
    box-shadow: 0 0 6px rgba(34,197,94,0.5);
  }
  .module-card.visited .module-card-status { color: #22c55e; }
  .module-card-arrow {
    color: var(--dim);
    font-size: 1rem;
    transition: transform 0.3s, color 0.3s;
  }
  .module-card:hover .module-card-arrow {
    color: var(--accent);
    transform: translateX(4px);
  }

  /* Sticky navigation */
  .sticky-nav {
    position: fixed;
    top: 0; left: 0; right: 0;
    z-index: 1000;
    background: rgba(10,14,26,0.92);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    border-bottom: 1px solid var(--border);
    transform: translateY(-100%);
    transition: transform 0.35s cubic-bezier(0.22, 1, 0.36, 1);
    pointer-events: none;
  }
  .sticky-nav.visible {
    transform: translateY(0);
    pointer-events: auto;
  }
  .sticky-nav-inner {
    max-width: 1200px;
    margin: 0 auto;
    padding: 0 20px;
    display: flex;
    align-items: center;
    height: 52px;
    gap: 6px;
    overflow-x: auto;
    scrollbar-width: none;
  }
  .sticky-nav-inner::-webkit-scrollbar { display: none; }
  .sticky-nav-title {
    font-size: 0.8rem;
    font-weight: 700;
    color: var(--accent);
    white-space: nowrap;
    margin-right: 12px;
    flex-shrink: 0;
  }
  .sticky-nav-item {
    background: transparent;
    border: none;
    color: var(--dim);
    font-family: inherit;
    font-size: 0.75rem;
    font-weight: 600;
    padding: 6px 10px;
    border-radius: 6px;
    cursor: pointer;
    white-space: nowrap;
    transition: color 0.2s, background 0.2s;
    flex-shrink: 0;
  }
  .sticky-nav-item:hover {
    color: var(--text);
    background: rgba(255,255,255,0.05);
  }
  .sticky-nav-item.active {
    color: var(--accent);
    background: rgba(59,130,246,0.1);
  }
  .sticky-nav-progress {
    margin-left: auto;
    flex-shrink: 0;
    display: flex;
    align-items: center;
    gap: 8px;
  }
  .sticky-nav-progress-bar {
    width: 60px; height: 4px;
    background: var(--border);
    border-radius: 2px;
    overflow: hidden;
  }
  .sticky-nav-progress-fill {
    height: 100%;
    width: 0%;
    background: linear-gradient(90deg, var(--accent), var(--accent3));
    border-radius: 2px;
    transition: width 0.4s;
  }
  .sticky-nav-progress-text {
    font-size: 0.7rem;
    color: var(--muted);
    font-family: 'Courier New', monospace;
    font-weight: 700;
  }

  @media (max-width: 700px) {
    .module-grid { grid-template-columns: 1fr; gap: 14px; }
    .module-card-thumb { height: 80px; }
    .sticky-nav-title { display: none; }
    .sticky-nav-item { font-size: 0.7rem; padding: 5px 8px; }
  }
</style>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js" defer></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js" defer></script>
</head>
<body>

<canvas id="starfield"></canvas>

<div class="content-wrap">

<!-- Sticky Navigation -->
<nav class="sticky-nav" id="sticky-nav">
  <div class="sticky-nav-inner">
    <span class="sticky-nav-title">FTL</span>
    <button class="sticky-nav-item" data-target="sec-speedlimit">01 Speed</button>
    <button class="sticky-nav-item" data-target="sec-twins">02 Twins</button>
    <button class="sticky-nav-item" data-target="sec-contraction">03 Length</button>
    <button class="sticky-nav-item" data-target="sec-causality">04 Causality</button>
    <button class="sticky-nav-item" data-target="sec-curvature">05 Gravity</button>
    <button class="sticky-nav-item" data-target="sec-clocks">06 Clock</button>
    <button class="sticky-nav-item" data-target="sec-spacetime">06b Diagram</button>
    <button class="sticky-nav-item" data-target="sec-lorentz">07 Lorentz</button>
    <button class="sticky-nav-item" data-target="sec-energy">08 Energy</button>
    <button class="sticky-nav-item" data-target="sec-examples">09 Evidence</button>
    <button class="sticky-nav-item" data-target="sec-emc2">10 E=mc&sup2;</button>
    <button class="sticky-nav-item" data-target="sec-compare">11 Summary</button>
    <div class="sticky-nav-progress">
      <div class="sticky-nav-progress-bar">
        <div class="sticky-nav-progress-fill" id="nav-progress-fill"></div>
      </div>
      <span class="sticky-nav-progress-text" id="nav-progress-text">0%</span>
    </div>
  </div>
</nav>

<!-- Hero -->
<header class="hero">
  <h1>Why Faster-Than-Light Travel Is Impossible</h1>
  <p>An interactive exploration of Einstein's Special Relativity, time dilation, and the cosmic speed limit.</p>
  <div class="equation-hero">E = mc&sup2;</div>
  <div class="equation-hero-sub level-beg">Energy equals mass times the speed of light squared &mdash; the most famous equation in physics!</div>

  <div class="difficulty-toggle" id="difficulty-toggle">
    <span class="dt-label">Level:</span>
    <button class="dt-btn" data-level="beginner">
      <span class="dt-icon">&#127793;</span> Beginner
      <span class="dt-sub">Grades 7&ndash;9</span>
    </button>
    <button class="dt-btn active" data-level="intermediate">
      <span class="dt-icon">&#9889;</span> Intermediate
      <span class="dt-sub">Grades 10&ndash;12</span>
    </button>
    <button class="dt-btn" data-level="advanced">
      <span class="dt-icon">&#128300;</span> Advanced
      <span class="dt-sub">College+</span>
    </button>
  </div>

  <div class="rec-path level-beg">
    <strong>Recommended path:</strong> Start with sections 01, 02, 03, 06, then 09 for real-world proof!
  </div>

  <div class="hero-progress" id="hero-progress">
    <div class="hero-progress-label">
      <span>Your Progress</span>
      <span class="progress-pct" id="hero-progress-pct">0 / 12 modules</span>
    </div>
    <div class="hero-progress-bar">
      <div class="hero-progress-fill" id="hero-progress-fill"></div>
    </div>
  </div>

  <div class="hero-scroll-hint">
    <span>Explore Modules</span>
    <div class="chevron"></div>
  </div>
</header>

<!-- Module Card Grid -->
<div class="module-grid-section" id="module-grid">
  <div class="module-grid-heading">
    <h2>Choose Your Module</h2>
    <p>12 interactive explorations from beginner to advanced</p>
  </div>
  <div class="module-grid">
    <div class="module-card" data-section="sec-speedlimit">
      <div class="module-card-thumb thumb-beginner"><span class="module-card-icon">&#x1F680;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">01</span><span class="section-badge badge-beginner">Start Here</span></div>
        <div class="module-card-title">The Speed Limit of the Universe</div>
        <div class="module-card-desc">No equations &mdash; just visual stories that show why nothing can outrun light.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-twins">
      <div class="module-card-thumb thumb-beginner"><span class="module-card-icon">&#x1F46F;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">02</span><span class="section-badge badge-beginner">Beginner</span></div>
        <div class="module-card-title">The Twin Paradox</div>
        <div class="module-card-desc">One twin rockets away and returns younger. Watch them age at different rates in real time.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-contraction">
      <div class="module-card-thumb thumb-beginner"><span class="module-card-icon">&#x2194;&#xFE0F;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">03</span><span class="section-badge badge-beginner">Beginner</span></div>
        <div class="module-card-title">Length Contraction</div>
        <div class="module-card-desc">Moving objects physically shrink &mdash; watch a starship compress as it approaches light speed.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-causality">
      <div class="module-card-thumb thumb-intermediate"><span class="module-card-icon">&#x26A0;&#xFE0F;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">04</span><span class="section-badge badge-intermediate">Intermediate</span></div>
        <div class="module-card-title">Causality Violation</div>
        <div class="module-card-desc">FTL doesn't just break a speed limit &mdash; it lets you receive messages before they were sent.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-curvature">
      <div class="module-card-thumb thumb-intermediate"><span class="module-card-icon">&#x1F30D;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">05</span><span class="section-badge badge-intermediate">Intermediate</span></div>
        <div class="module-card-title">Spacetime Curvature in 3D</div>
        <div class="module-card-desc">Interactive 3D gravity: place masses, launch orbits, and see spacetime warp in real time.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-clocks">
      <div class="module-card-thumb thumb-beginner"><span class="module-card-icon">&#x23F1;&#xFE0F;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">06</span><span class="section-badge badge-beginner">Beginner</span></div>
        <div class="module-card-title">Photon Clock &amp; Time Dilation</div>
        <div class="module-card-desc">A photon bouncing between mirrors reveals how time itself slows for moving objects.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-spacetime">
      <div class="module-card-thumb thumb-intermediate"><span class="module-card-icon">&#x1F4C8;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">06b</span><span class="section-badge badge-intermediate">Intermediate</span></div>
        <div class="module-card-title">Minkowski Spacetime Diagram</div>
        <div class="module-card-desc">The geometry of the universe &mdash; why light speed divides spacetime into reachable and unreachable.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-lorentz">
      <div class="module-card-thumb thumb-intermediate"><span class="module-card-icon">&#x1D6FE;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">07</span><span class="section-badge badge-intermediate">Intermediate</span></div>
        <div class="module-card-title">The Lorentz Factor</div>
        <div class="module-card-desc">The mathematical heart of special relativity &mdash; and why it blows up at light speed.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-energy">
      <div class="module-card-thumb thumb-advanced"><span class="module-card-icon">&#x221E;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">08</span><span class="section-badge badge-advanced">Advanced</span></div>
        <div class="module-card-title">The Infinite Energy Barrier</div>
        <div class="module-card-desc">Reaching light speed requires infinite energy. See the relativistic vs classical curves diverge.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-examples">
      <div class="module-card-thumb thumb-beginner"><span class="module-card-icon">&#x1F6F0;&#xFE0F;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">09</span><span class="section-badge badge-beginner">Beginner</span></div>
        <div class="module-card-title">Real-World Evidence</div>
        <div class="module-card-desc">GPS satellites, muon decay, particle accelerators &mdash; we measure relativity every day.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-emc2">
      <div class="module-card-thumb thumb-intermediate"><span class="module-card-icon">&#x2699;&#xFE0F;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">10</span><span class="section-badge badge-intermediate">Intermediate</span></div>
        <div class="module-card-title">E = mc&sup2; and Mass-Energy</div>
        <div class="module-card-desc">Mass is frozen energy. Energy has inertia. This equivalence drives the cosmic speed limit.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
    <div class="module-card" data-section="sec-compare">
      <div class="module-card-thumb thumb-intermediate"><span class="module-card-icon">&#x1F52C;</span></div>
      <div class="module-card-body">
        <div class="module-card-header"><span class="module-card-num">11</span><span class="section-badge badge-intermediate">Intermediate</span></div>
        <div class="module-card-title">Putting It All Together</div>
        <div class="module-card-desc">Adjust velocity and watch all relativistic effects &mdash; time, length, energy &mdash; simultaneously.</div>
        <div class="module-card-footer"><div class="module-card-status"><span class="module-card-status-dot"></span><span class="module-card-status-text">Not visited</span></div><span class="module-card-arrow">&#x2192;</span></div>
      </div>
    </div>
  </div>
</div>

<!-- Section 01: Speed Limit Explained Simply -->
<section id="sec-speedlimit">
  <h2><span class="num">01</span> The Speed Limit of the Universe <span class="section-badge badge-beginner">Start Here</span></h2>
  <p class="subtitle">No equations, no formulas &mdash; just visual stories that show why nothing can outrun light.</p>

  <div class="card">
    <p class="explain level-beg">
      Nothing can travel faster than light &mdash; but why? These five animations show you the answer without any math.
      Think of it like a budget: you have a fixed amount of &ldquo;speed&rdquo; to spend, and you can put it toward
      moving through space <em>or</em> moving through time, but never both at full speed.
    </p>
    <p class="explain level-int">
      Everything in the universe is always moving through spacetime at exactly one speed: <strong>the speed of light</strong>.
      You can trade speed through space for speed through time, but you can never exceed the total budget.
      Move faster through space? You move slower through time. Here&rsquo;s what that looks and feels like.
    </p>
    <p class="explain level-adv">
      Every object traces a path through 4D spacetime with a <span class="term">four-velocity<span class="term-tip">A vector in spacetime whose magnitude is always c</span></span>
      whose magnitude is always <em>c</em>. The <span class="term">spacetime interval<span class="term-tip">ds&sup2; = &minus;c&sup2;dt&sup2; + dx&sup2; &mdash; the invariant &ldquo;distance&rdquo; in spacetime</span></span>
      ds&sup2; = &minus;c&sup2;dt&sup2; + dx&sup2; is invariant: more spatial velocity means less temporal velocity,
      and vice versa. These visualizations illustrate that tradeoff.
    </p>

    <div class="tab-bar" id="speedlimit-tabs">
      <button class="tab-btn active" data-tab="sl-speedometer">Speedometer</button>
      <button class="tab-btn" data-tab="sl-astronaut">Astronaut</button>
      <button class="tab-btn" data-tab="sl-photon">Photon&rsquo;s View</button>
      <button class="tab-btn" data-tab="sl-wall">The Wall</button>
      <button class="tab-btn" data-tab="sl-candles">Birthday Candles</button>
    </div>

    <!-- Tab 1: Speedometer of Spacetime -->
    <div id="sl-speedometer" class="tab-content active">
      <div class="slider-group">
        <label>Your speed <span class="val" id="sl-speed-label">0.00c</span></label>
        <input type="range" id="sl-speed" min="0" max="100" value="0" step="1">
      </div>
      <div class="canvas-wrap">
        <canvas id="sl-canvas" width="800" height="500"></canvas>
      </div>
    </div>

    <!-- Tab 2: Astronaut Aging -->
    <div id="sl-astronaut" class="tab-content">
      <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
        <button id="sl-astro-play" class="tab-btn active" style="flex:1;min-width:100px;">Start Aging</button>
        <button id="sl-astro-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
      </div>
      <div class="slider-group">
        <label>Rocket speed <span class="val" id="sl-astro-vel-label">0.80c</span></label>
        <input type="range" id="sl-astro-vel" min="10" max="99" value="80" step="1">
      </div>
      <div class="canvas-wrap">
        <canvas id="sl-astro-canvas" width="800" height="500"></canvas>
      </div>
    </div>

    <!-- Tab 3: Photon's View -->
    <div id="sl-photon" class="tab-content">
      <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
        <button id="sl-photon-play" class="tab-btn active" style="flex:1;min-width:100px;">Send Photon</button>
        <button id="sl-photon-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
      </div>
      <div class="canvas-wrap">
        <canvas id="sl-photon-canvas" width="800" height="500"></canvas>
      </div>
    </div>

    <!-- Tab 4: The Wall -->
    <div id="sl-wall" class="tab-content">
      <div class="slider-group">
        <label>Push speed <span class="val" id="sl-wall-label">0.00c</span></label>
        <input type="range" id="sl-wall-speed" min="0" max="100" value="0" step="1">
      </div>
      <div class="canvas-wrap">
        <canvas id="sl-wall-canvas" width="800" height="500"></canvas>
      </div>
    </div>

    <!-- Tab 5: Birthday Candles -->
    <div id="sl-candles" class="tab-content">
      <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
        <button id="sl-candle-play" class="tab-btn active" style="flex:1;min-width:100px;">Start Journey</button>
        <button id="sl-candle-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
        <button id="sl-candle-speed" class="tab-btn" style="flex:1;min-width:100px;">Speed: 1&times;</button>
      </div>
      <div class="slider-group">
        <label>Travel speed <span class="val" id="sl-candle-vel-label">0.80c</span></label>
        <input type="range" id="sl-candle-vel" min="10" max="99" value="80" step="1">
      </div>
      <div class="canvas-wrap">
        <canvas id="sl-candle-canvas" width="800" height="500"></canvas>
      </div>
    </div>

    <p class="explain level-beg">
      All five pictures show the same big idea: <strong>the faster you go, the more time slows down for you</strong>.
      At light speed, time stops completely. Nothing with any mass can actually reach that speed &mdash; it would
      take infinite energy. Keep scrolling to see more ways this shows up!
    </p>
    <p class="explain level-int">
      Every visualization above shows the same truth from a different angle: <strong>moving through space and moving through time are connected</strong>.
      The faster you go through space, the slower you go through time. At light speed, time stops completely.
      The sections below explore the physics behind these effects in detail.
    </p>
    <p class="explain level-adv">
      Each tab illustrates a consequence of the Minkowski metric. The spacetime speedometer is the
      four-velocity constraint |u&mu;| = c. Astronaut aging is proper time &tau; = &int;ds/c along a worldline.
      The photon&rsquo;s view is the null limit ds&sup2; = 0. The energy hill is the divergence of &gamma;mc&sup2;.
      The birthday candles are the integrated proper time difference &Delta;&tau; between two worldlines.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 02: Twin Paradox -->
<section id="sec-twins">
  <h2><span class="num">02</span> The Twin Paradox <span class="section-badge badge-beginner">Beginner</span></h2>
  <p class="subtitle">One twin stays home. The other rockets to a star and back. When they reunite, the traveler is younger. This is real.</p>

  <div class="card">
    <p class="explain level-beg">
      Imagine two identical twins. One stays home, one takes a super-fast rocket trip to a distant star and back.
      When they meet again, the traveler is actually <strong>younger</strong>! This really happens &mdash; it&rsquo;s not science fiction.
      The faster the rocket goes, the bigger the age difference.
    </p>
    <p class="explain level-int">
      The <strong>twin paradox</strong> is the most famous consequence of <span class="term">time dilation<span class="term-tip">Time passes slower for objects moving at high speed</span></span>. Twin A stays on Earth.
      Twin B travels to a distant star at high speed, turns around, and returns. Because Twin B's clock
      runs slower during the trip, <strong>Twin B ages less</strong>. This isn't symmetric &mdash; Twin B
      <em>accelerated</em> (changed direction), breaking the symmetry between the two frames.
    </p>
    <p class="explain level-adv">
      The twin paradox resolves through <span class="term">proper time<span class="term-tip">The time measured along an object&rsquo;s own worldline: &tau; = &int;ds/c</span></span>:
      &tau; = &int;&radic;(1 &minus; v&sup2;/c&sup2;) dt. The stay-home twin&rsquo;s worldline is geodesic (straight in Minkowski space),
      maximizing proper time. The traveler&rsquo;s worldline has a kink at turnaround &mdash; a non-inertial segment &mdash;
      accumulating less proper time. The metric signature (&minus;,+,+,+) ensures the straight path is always longest.
    </p>

    <div class="slider-group">
      <label>Travel velocity <span class="val" id="twin-vel-label">0.50c</span></label>
      <input type="range" id="twin-vel" min="10" max="99" value="50" step="1">
    </div>
    <div class="slider-group">
      <label>Destination distance <span class="val" id="twin-dist-label">5.0 ly</span></label>
      <input type="range" id="twin-dist" min="1" max="50" value="10" step="1">
    </div>

    <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
      <button id="twin-play" class="tab-btn active" style="flex:1;min-width:100px;">Launch Trip</button>
      <button id="twin-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
      <button id="twin-speed" class="tab-btn" style="flex:1;min-width:100px;">Speed: 1&times;</button>
    </div>

    <div class="canvas-wrap">
      <canvas id="twin-canvas" width="800" height="750"></canvas>
    </div>

    <div class="readouts" style="margin-top:16px;">
      <div class="readout">
        <div class="label">Earth Twin Age</div>
        <div class="value yellow" id="tw-earth-age">30.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Traveler Twin Age</div>
        <div class="value cyan" id="tw-trav-age">30.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Earth Time Elapsed</div>
        <div class="value blue" id="tw-earth-time">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Traveler Time Elapsed</div>
        <div class="value purple" id="tw-trav-time">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Age Difference</div>
        <div class="value red" id="tw-diff">0.0 yr</div>
      </div>
      <div class="readout">
        <div class="label">Trip Phase</div>
        <div class="value" id="tw-phase" style="color:var(--muted);">Ready</div>
      </div>
    </div>

    <p class="explain level-beg" style="margin-top:16px;">
      <strong>But wait &mdash; isn&rsquo;t it unfair?</strong> From the rocket&rsquo;s point of view, isn&rsquo;t Earth moving away?
      The difference is that the rocket had to <em>turn around</em>. Turning around means changing speed and direction,
      and that breaks the tie. The twin who turned around is always the younger one when they meet again.
      Look at the spacetime diagram below &mdash; the rocket&rsquo;s path has a &ldquo;kink&rdquo; where it turned around.
    </p>
    <p class="explain level-int" style="margin-top:16px;">
      <strong>Why isn't this a paradox?</strong> From the rocket's frame, doesn't Earth's clock run slow too?
      Yes &mdash; during each constant-velocity leg, each twin sees the other's clock running slow.
      But the traveler <em>turns around</em> (accelerates), which is <strong>not</strong> an inertial frame change.
      The turnaround breaks the symmetry. In the spacetime diagram below, the traveler's worldline
      has a <strong>kink</strong> &mdash; it's a longer path through spacetime, but a <em>shorter</em> proper time.
      The straight worldline (staying home) always accumulates the most proper time between two events.
    </p>
    <p class="explain level-adv" style="margin-top:16px;">
      <strong>Resolution via the metric:</strong> Proper time along a worldline is &tau; = &int;&radic;(&minus;ds&sup2;)/c.
      The stay-home worldline is geodesic in flat Minkowski space, and by the reversed triangle inequality of
      Lorentzian geometry, the geodesic between two timelike-separated events has the <em>maximum</em> proper time.
      The traveler&rsquo;s piecewise-inertial path with a turnaround kink always accumulates less.
      Equivalently, during turnaround the traveler shifts to a frame where Earth&rsquo;s clock jumps forward by &Delta;t = 2vd/c&sup2;.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 03: Length Contraction -->
<section id="sec-contraction">
  <h2><span class="num">03</span> Length Contraction <span class="section-badge badge-beginner">Beginner</span></h2>
  <p class="subtitle">Moving objects physically shrink along their direction of motion &mdash; watch a starship compress as it accelerates toward c.</p>

  <div class="card">
    <p class="explain level-beg">
      When something moves really fast, it actually gets <strong>shorter</strong> in the direction it&rsquo;s moving.
      Not because it&rsquo;s squished by a force &mdash; space itself contracts! The ship&rsquo;s passengers don&rsquo;t
      notice anything different about their own ship. Instead, they see the universe compressed ahead of them.
      Try the slider to see how much a ship shrinks at different speeds.
    </p>
    <p class="explain level-int">
      Just as time dilates, <strong>lengths contract</strong>. An object moving at velocity v is measured by a stationary
      observer to be shorter by a factor of 1/&gamma;: <strong>L = L&#x2080; / &gamma;</strong>.
      At 0.87c the ship is half its rest length. At 0.99c it's compressed to just 14%. The ship's occupants
      notice nothing different about their own ship &mdash; instead, they see the <em>universe</em> contracted ahead of them.
    </p>
    <p class="explain level-adv">
      <span class="term">Length contraction<span class="term-tip">Moving objects are measured shorter along the direction of motion: L = L&#x2080;/&gamma;</span></span>
      is a direct consequence of the <span class="term">relativity of simultaneity<span class="term-tip">Events simultaneous in one frame aren&rsquo;t simultaneous in another</span></span>.
      Measuring a moving object&rsquo;s length requires noting both ends <em>simultaneously</em>, but &ldquo;simultaneous&rdquo;
      differs between frames. In the rest frame S&prime;, the rod endpoints are at (0,0) and (L&#x2080;,0). Lorentz-transforming
      to S where the rod moves at v, the simultaneous measurement yields L = L&#x2080;/&gamma;. The contraction is real
      but frame-dependent &mdash; the proper length L&#x2080; is invariant.
    </p>

    <div class="slider-group">
      <label>Velocity <span class="val" id="lc-vel-label">0.00c</span></label>
      <input type="range" id="lc-vel" min="0" max="990" value="0" step="5">
    </div>

    <div class="canvas-wrap">
      <canvas id="lc-canvas" width="800" height="480"></canvas>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Length (L₀)</div>
        <div class="value blue" id="lc-rest">100.0 m</div>
      </div>
      <div class="readout">
        <div class="label">Observed Length (L)</div>
        <div class="value cyan" id="lc-obs">100.0 m</div>
      </div>
      <div class="readout">
        <div class="label">Contraction</div>
        <div class="value yellow" id="lc-pct">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">γ (Lorentz)</div>
        <div class="value purple" id="lc-gamma">1.000</div>
      </div>
    </div>

    <div style="display:flex;gap:12px;margin-top:8px;flex-wrap:wrap;">
      <button id="lc-flyby" class="tab-btn active" style="flex:1;min-width:140px;">Launch Fly-By</button>
      <button id="lc-flyby-reset" class="tab-btn" style="flex:1;min-width:140px;">Reset</button>
    </div>

    <p class="explain level-beg" style="margin-top:16px;">
      The <strong>top picture</strong> shows the ship parked &mdash; its full length. The <strong>bottom picture</strong>
      shows the same ship zooming past you. Notice how it gets squished! Press <em>Launch Fly-By</em> to see
      ships streak past at different speeds. The faster they go, the shorter they look.
    </p>
    <p class="explain level-int" style="margin-top:16px;">
      The <strong>top view</strong> shows the ship at rest for reference. The <strong>bottom view</strong> shows how a
      stationary observer measures the same ship as it flies past. Press <em>Launch Fly-By</em> to see
      contracted ships streak past the observation platform at your chosen speed. The ruler and grid
      stay fixed &mdash; only the ship contracts.
    </p>
    <p class="explain level-adv" style="margin-top:16px;">
      Note: what you <em>see</em> optically differs from the Lorentz-contracted length due to light travel time
      (Terrell rotation). A sphere would appear rotated, not flattened. The visualization here shows the
      Lorentz-contracted measurement, not the optical appearance. The ghost outline shows the proper length
      for direct comparison.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 04: Causality Violation -->
<section id="sec-causality">
  <h2><span class="num">04</span> Causality Violation &mdash; Why FTL Breaks Reality <span class="section-badge badge-intermediate">Intermediate</span></h2>
  <p class="subtitle">FTL doesn't just break a speed limit &mdash; it lets you receive messages before they were sent, destroying cause and effect.</p>

  <div class="card">
    <p class="explain level-beg">
      If you could send a message faster than light, some people in the universe would see you get the reply
      <strong>before you sent the message</strong>. That&rsquo;s like getting an answer before asking the question &mdash;
      impossible! This is the deepest reason why nothing can go faster than light: it would break
      <span class="term">causality<span class="term-tip">The rule that causes always come before their effects</span></span>
      &mdash; the rule that causes always come before their effects.
    </p>
    <p class="explain level-int">
      The speed of light isn't an arbitrary speed limit &mdash; it's the boundary between <strong>cause</strong> and <strong>effect</strong>.
      In special relativity, different observers moving at different velocities disagree about <em>when</em> events happen.
      For events connected by light or slower signals, everyone agrees on the order. But for faster-than-light signals,
      some observers see the reply arrive <strong>before the message was sent</strong> &mdash; creating logical paradoxes
      that make FTL communication physically impossible.
    </p>
    <p class="explain level-adv">
      For a spacelike-separated signal (FTL), &exist; a Lorentz boost that reverses the temporal ordering.
      Specifically, if a signal travels at speed s &gt; c, an observer moving at v &gt; c&sup2;/s sees it arrive
      at negative time: t&prime; = &gamma;(t &minus; vx/c&sup2;) &lt; 0. This is the <strong>tachyonic antitelephone</strong>
      argument (Tolman, 1917; Benford et al., 1970). Combined with the relativity principle (all inertial frames
      are equivalent), any FTL signal can be combined with a Lorentz boost to create a closed timelike curve.
    </p>

    <div class="tab-bar" id="causality-tabs">
      <button class="tab-btn active" data-tab="causality-simul">Simultaneity &amp; Light Cones</button>
      <button class="tab-btn" data-tab="causality-paradox">The Paradox</button>
    </div>

    <!-- Tab 1: Simultaneity & Light Cones -->
    <div id="causality-simul" class="tab-content active">
      <div style="display:flex;gap:16px;flex-wrap:wrap;margin-bottom:8px;">
        <div class="slider-group" style="flex:1;min-width:200px;">
          <label>Observer velocity <span class="val" id="caus-vel-label">0.00c</span></label>
          <input type="range" id="caus-vel" min="0" max="95" value="0" step="1">
        </div>
        <div class="slider-group" style="flex:1;min-width:200px;">
          <label>FTL message speed <span class="val" id="caus-ftl-label">2.0c</span></label>
          <input type="range" id="caus-ftl" min="20" max="500" value="20" step="1">
        </div>
      </div>

      <div class="canvas-wrap">
        <canvas id="causality-canvas" width="800" height="650"></canvas>
      </div>

      <div class="readouts">
        <div class="readout">
          <div class="label">Observer Velocity</div>
          <div class="value blue" id="cv-vel">0.00c</div>
        </div>
        <div class="readout">
          <div class="label">FTL Message Speed</div>
          <div class="value cyan" id="cv-ftl">2.0c</div>
        </div>
        <div class="readout">
          <div class="label">Earth Frame Arrival</div>
          <div class="value yellow" id="cv-earth-t">+2.19 yr</div>
        </div>
        <div class="readout">
          <div class="label">Moving Frame Arrival</div>
          <div class="value purple" id="cv-moving-t">+2.19 yr</div>
        </div>
        <div class="readout">
          <div class="label">Time Reversal</div>
          <div class="value red" id="cv-reversal">0 days</div>
        </div>
        <div class="readout">
          <div class="label">Causality</div>
          <div class="value" id="cv-status" style="color:#22c55e;">OK</div>
        </div>
      </div>

      <p class="explain level-beg">
        The <span class="term">light cone<span class="term-tip">The region of spacetime reachable at or below light speed</span></span>
        is like a &ldquo;safe zone.&rdquo; Messages inside the cone always arrive in the right order.
        But an FTL message goes <em>outside</em> the cone, into the danger zone where different people
        disagree about what happened first. Try increasing the observer speed to see the arrival time go negative!
      </p>
      <p class="explain level-int">
        The Lorentz transformation tells us: <strong>t&prime; = &gamma;(t &minus; vx/c&sup2;)</strong>.
        For an FTL message traveling distance <em>d</em> at speed <em>s&middot;c</em>, the arrival time in the
        Earth frame is t = d/s. But a moving observer sees it arrive at t&prime; = &gamma;(d/s &minus; v&middot;d/c&sup2;).
        When <strong>v &gt; c/s</strong>, this goes <em>negative</em> &mdash; the message arrives before it was sent.
      </p>
      <p class="explain level-adv">
        The critical condition is v &gt; c&sup2;/s, where s is the FTL signal speed. For s = 2c, any observer
        with v &gt; 0.5c sees reversed ordering. The Lorentz-transformed arrival time
        t&prime; = &gamma;d(1/s &minus; v/c&sup2;) changes sign at v = c&sup2;/s. Since s &gt; c, the threshold v &lt; c
        is always achievable by a subluminal observer. This is why <em>any</em> FTL speed, no matter how modest,
        enables time-reversed signaling.
      </p>
    </div>

    <!-- Tab 2: The Paradox -->
    <div id="causality-paradox" class="tab-content">
      <div style="display:flex;gap:12px;margin-bottom:12px;flex-wrap:wrap;">
        <button id="paradox-play" class="tab-btn active" style="flex:1;min-width:100px;">Play Scenario</button>
        <button id="paradox-reset" class="tab-btn" style="flex:1;min-width:100px;">Reset</button>
        <button id="paradox-speed" class="tab-btn" style="flex:1;min-width:100px;">Speed: 1&times;</button>
      </div>

      <div class="canvas-wrap">
        <canvas id="paradox-canvas" width="800" height="650"></canvas>
      </div>

      <div class="readouts">
        <div class="readout">
          <div class="label">Earth Clock</div>
          <div class="value yellow" id="px-earth-t">T = 0.00 yr</div>
        </div>
        <div class="readout">
          <div class="label">Alpha Centauri Clock</div>
          <div class="value cyan" id="px-ac-t">T = 0.00 yr</div>
        </div>
        <div class="readout">
          <div class="label">Moving Frame Clock</div>
          <div class="value purple" id="px-moving-t">T&prime; = 0.00 yr</div>
        </div>
        <div class="readout">
          <div class="label">Phase</div>
          <div class="value" id="px-phase" style="color:var(--muted);">Ready</div>
        </div>
        <div class="readout">
          <div class="label">Message Content</div>
          <div class="value cyan" id="px-msg" style="font-size:1rem;">&mdash;</div>
        </div>
        <div class="readout">
          <div class="label">Paradox</div>
          <div class="value" id="px-paradox" style="color:#22c55e;">None yet</div>
        </div>
      </div>

      <p class="explain level-beg">
        <strong>Here&rsquo;s the problem:</strong> Earth sends a message saying &ldquo;HELLO&rdquo; to another star.
        Because the message goes faster than light, someone on a moving spaceship sees the reply arrive
        <em>before</em> the message was sent! The reply says &ldquo;DON&rsquo;T SEND.&rdquo; But if you don&rsquo;t send it,
        the reply never exists. If you do send it, the warning was triggered. Either way, it makes no sense.
        That&rsquo;s why FTL messaging is impossible &mdash; it creates unsolvable contradictions.
      </p>
      <p class="explain level-int">
        <strong>The causal loop:</strong> Earth sends &ldquo;HELLO&rdquo; to Alpha Centauri at 2.185c.
        It arrives in 2 years (Earth frame), but an observer moving at 0.50c sees it arrive
        <strong>78 days in the past</strong>. Alpha Centauri replies at the same FTL speed.
        The reply reaches Earth <em>before</em> the original was sent. Now imagine the reply says
        &ldquo;DON&rsquo;T SEND&rdquo; &mdash; if you obey, the warning was never triggered. If you ignore it,
        the warning <em>was</em> triggered. Either way: <strong>paradox</strong>.
      </p>
      <p class="explain level-adv">
        <strong>Tachyonic antitelephone construction:</strong> Event A (Earth, t=0): send &ldquo;HELLO&rdquo; at 2.185c.
        Event B (Alpha Centauri, t=2yr): arrival. Boost to frame S&prime; at v=0.5c: t&prime;(B) = &gamma;(2 &minus; 0.5 &times; 4.37) &approx; &minus;0.21yr.
        Alpha Centauri retransmits in S&prime; at 2.185c. The reply reaches Earth at t &lt; 0 &mdash; before Event A.
        This constructs a closed timelike curve (CTC). By Novikov&rsquo;s self-consistency principle, CTCs require
        self-consistent histories, but the &ldquo;DON&rsquo;T SEND&rdquo; payload is explicitly inconsistent. Conclusion: FTL + Lorentz invariance &rArr; logical contradiction.
      </p>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 05: Spacetime Curvature -->
<section id="sec-curvature">
  <h2><span class="num">05</span> Spacetime Curvature in 3D <span class="section-badge badge-intermediate">Intermediate</span></h2>
  <p class="subtitle">Mass warps spacetime. Objects follow the straightest possible paths through curved geometry &mdash; what we perceive as gravity.</p>

  <div class="card">
    <p class="explain level-beg">
      Gravity isn&rsquo;t a pulling force &mdash; it&rsquo;s more like a curved path. Imagine rolling a marble on a trampoline
      with a bowling ball in the middle. The marble curves because the surface is curved, not because something is pulling it.
      That&rsquo;s what mass does to space! Use the presets below to explore, or place your own masses.
    </p>
    <p class="explain level-int">
      Einstein's <strong>General Relativity</strong> reveals that gravity isn't a force &mdash; it's the curvature of spacetime
      caused by mass and energy. A planet orbiting a star is simply following the straightest possible path (a <span class="term">geodesic<span class="term-tip">The straightest possible path through curved spacetime</span></span>)
      through warped spacetime. Use the presets below to explore simulations, or place your own masses.
    </p>
    <p class="explain level-adv">
      General Relativity replaces Newtonian gravity with the Einstein field equations: G&mu;&nu; = 8&pi;G/c&sup4; T&mu;&nu;.
      The <span class="term">stress-energy tensor<span class="term-tip">T&mu;&nu; &mdash; describes the density and flux of energy and momentum in spacetime</span></span> T&mu;&nu;
      sources spacetime curvature. Free particles follow geodesics of the
      <span class="term">Schwarzschild metric<span class="term-tip">The spacetime geometry around a non-rotating spherical mass</span></span>
      ds&sup2; = &minus;(1&minus;r_s/r)c&sup2;dt&sup2; + (1&minus;r_s/r)&sup1;dr&sup2; + r&sup2;d&Omega;&sup2;.
      This visualization uses a Newtonian potential proxy (&Phi; &prop; &minus;M/r) for computational simplicity.
    </p>

    <!-- ===== 3D CONTAINER (TOP — fills 70-80% of space) ===== -->
    <div id="curvature-container">
      <div id="curv-tooltip" style="position:absolute;top:10px;left:50%;transform:translateX(-50%);background:rgba(17,24,39,0.85);border:1px solid var(--border);border-radius:8px;padding:6px 12px;font-size:0.75rem;color:var(--muted);pointer-events:none;display:none;z-index:10;white-space:nowrap;">
        Potential: <span id="curv-tip-potential" style="color:var(--accent3);">--</span> &nbsp; Time dilation: <span id="curv-tip-dilation" style="color:var(--accent);">--</span>
      </div>
      <div id="curv-labels" style="position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;overflow:hidden;z-index:5;"></div>
      <div id="curv-cam-help" style="position:absolute;bottom:10px;left:10px;background:rgba(17,24,39,0.7);border-radius:6px;padding:4px 8px;font-size:0.65rem;color:var(--dim);pointer-events:none;z-index:5;opacity:0.7;">
        Drag: Rotate &nbsp;&bull;&nbsp; Right-drag: Pan &nbsp;&bull;&nbsp; Scroll: Zoom
      </div>
      <!-- Mode indicator -->
      <div id="curv-mode-indicator" style="position:absolute;bottom:10px;right:10px;background:rgba(17,24,39,0.85);border:1px solid #22c55e;border-radius:6px;padding:4px 10px;font-size:0.72rem;font-weight:600;color:#22c55e;pointer-events:none;z-index:6;">Camera Controls</div>
      <div id="curv-shell-legend" style="display:none;position:absolute;top:10px;left:10px;background:rgba(17,24,39,0.85);border:1px solid var(--border);border-radius:8px;padding:8px 12px;font-size:0.75rem;color:var(--muted);pointer-events:none;z-index:5;line-height:1.6;max-width:220px;">
        <strong style="color:var(--text);">Spacetime Curvature</strong><br>
        Grid compresses near mass &mdash; this IS gravity!<br>
        <span style="color:#ff3333;">&#9632;</span> Inner (red) = strongest curvature<br>
        <span style="color:#f59e0b;">&#9632;</span> Middle (orange) = medium curvature<br>
        <span style="color:#3b82f6;">&#9632;</span> Outer (blue) = nearly flat space<br>
        Objects follow straight paths through this curved grid.
      </div>
      <!-- Info overlay (top-right, compact) -->
      <div id="curv-info-overlay">
        <div class="curv-info-row"><span class="curv-info-label">Simulation</span> <span class="curv-info-val" id="curv-info-scenario">Earth</span></div>
        <div class="curv-info-row"><span class="curv-info-label">Time</span> <span class="curv-info-val" id="curv-info-time">0.0s</span></div>
        <div class="curv-info-row"><span class="curv-info-label">Dilation</span> <span class="curv-info-val" id="curv-info-dilation">1.000</span></div>
        <div class="curv-info-row readout-adv"><span class="curv-info-label">Energy</span> <span class="curv-info-val" id="curv-info-energy">&mdash;</span></div>
        <div class="curv-info-row" id="curv-info-force-row" style="display:none;border-top:1px solid rgba(255,255,255,0.08);padding-top:3px;margin-top:2px;"><span class="curv-info-label" style="color:#ef4444;">Field F &prop; 1/r&sup2;</span> <span class="curv-info-val" id="curv-info-force" style="color:#ffdd44;">&mdash;</span></div>
      </div>
      <button id="curv-fullscreen-close" style="display:none;position:absolute;top:16px;left:16px;z-index:10001;background:rgba(17,24,39,0.85);border:1px solid var(--border);color:var(--text);padding:8px 16px;border-radius:8px;cursor:pointer;font-size:0.9rem;font-family:inherit;">Exit Fullscreen</button>
      <div id="curv-fullscreen-instructions" style="display:none;position:absolute;bottom:16px;left:16px;z-index:10001;background:rgba(17,24,39,0.85);border:1px solid var(--border);border-radius:8px;padding:12px 16px;font-size:0.8rem;color:var(--muted);max-width:300px;line-height:1.5;">
        <strong style="color:var(--text);">Controls:</strong><br>
        Left-click + drag: Rotate<br>
        Right-click + drag: Pan<br>
        Scroll: Zoom<br>
        Click grid: Place mass / Launch particle<br>
        Press H: Show/hide controls<br>
        Press Esc: Exit fullscreen
      </div>
    </div>

    <!-- ===== BOTTOM PANEL (fixed to viewport bottom when section active) ===== -->
    <div id="curv-bottom-panel">
    <div id="curv-control-panel">

      <!-- LEFT COLUMN: Quick Start -->
      <div class="curv-col" id="curv-col-left">
        <div class="curv-col-header">Quick Start</div>
        <!-- Mass presets hidden (kept in DOM for JS compatibility) -->
        <div style="display:none;">
          <button class="tab-btn active" id="curv-preset-earth" data-preset="earth">Earth</button>
          <button class="tab-btn" id="curv-preset-sun" data-preset="sun">Sun</button>
          <button class="tab-btn" id="curv-preset-bh" data-preset="blackhole">Black Hole</button>
          <button class="tab-btn" id="curv-preset-binary" data-preset="binary">Binary Stars</button>
        </div>
        <div class="curv-btn-group-label">Simulations</div>
        <div class="curv-btn-group">
          <button class="tab-btn" id="curv-scenario-iss" data-scenario="iss" title="ISS orbits Earth at 408 km altitude">ISS</button>
          <button class="tab-btn" id="curv-scenario-moon" data-scenario="moon" title="Moon orbits Earth at 384,400 km">Moon</button>
          <button class="tab-btn" id="curv-scenario-earthsun" data-scenario="earthsun" title="Earth orbits the Sun at 1 AU">Earth-Sun</button>
          <button class="tab-btn" id="curv-scenario-binarystar" data-scenario="binarystar" title="Two equal stars orbit their common center of mass">Binary Stars</button>
          <button class="tab-btn" id="curv-scenario-figure8" data-scenario="figure8" title="Chenciner-Montgomery 3-body solution on a figure-8 path">Figure-8</button>
        </div>
        <div id="curv-scenario-info" style="display:none;color:var(--dim);font-size:0.7rem;padding:2px 0;line-height:1.4;font-style:italic;"></div>
        <div class="curv-btn-group-label">View</div>
        <div class="curv-btn-group">
          <button class="tab-btn" id="curv-view-2d">2D Sheet</button>
          <button class="tab-btn active" id="curv-view-3d">3D Spherical</button>
        </div>
      </div>

      <!-- MIDDLE COLUMN: Simulation Controls -->
      <div class="curv-col" id="curv-col-mid">
        <div class="curv-col-header">Simulation</div>
        <div class="curv-btn-group">
          <button class="tab-btn" id="curv-pause">Pause</button>
          <button class="tab-btn" id="curv-step-fwd">Step +1</button>
          <button class="tab-btn" id="curv-reset-all">Reset All</button>
        </div>
        <div class="slider-group">
          <label>Sim speed <span class="val" id="curv-sim-speed-label">1.0x</span></label>
          <input type="range" id="curv-sim-speed" min="0" max="100" value="50" step="1">
        </div>
        <div class="curv-check-grid">
          <label><input type="checkbox" id="curv-show-grid" checked> Grid</label>
          <label><input type="checkbox" id="curv-show-trails" checked> Trails</label>
          <label><input type="checkbox" id="curv-cross-sections" checked> Cross-Sections</label>
          <label><input type="checkbox" id="curv-show-forces"> Force Field</label>
          <label><input type="checkbox" id="curv-straightness"> Geodesics</label>
          <label><input type="checkbox" id="curv-show-flat-ref"> Flat Space Ref</label>
        </div>
        <div class="slider-group">
          <label>Curvature strength <span class="val" id="curv-warp-label">5.0</span></label>
          <input type="range" id="curv-warp-slider" min="1" max="20" value="10" step="1">
        </div>
      </div>

      <!-- RIGHT COLUMN: Advanced (collapsible) -->
      <div class="curv-col" id="curv-col-right">
        <div class="curv-collapse-header" id="curv-adv-toggle">Advanced &#9660;</div>
        <div class="curv-collapse-body open" id="curv-adv-body">
          <!-- Hidden camera buttons (JS references these by ID) -->
          <div style="display:none;">
            <button id="curv-cam-top">Top</button>
            <button id="curv-cam-side">Side</button>
            <button id="curv-cam-front">Front</button>
            <button class="active" id="curv-cam-free">Free</button>
            <button id="curv-cam-follow">Follow</button>
          </div>
          <div class="curv-btn-group-label">Mode <span style="color:var(--dim);font-size:0.6rem;font-weight:400;">(M/P/O keys)</span></div>
          <div class="curv-btn-group">
            <button class="tab-btn active" id="curv-mode-camera" title="Camera only — click and drag to rotate (Esc)">Camera</button>
            <button class="tab-btn" id="curv-mode-place" title="Click on grid to place a mass (M)">Place Mass</button>
            <button class="tab-btn" id="curv-mode-drop" title="Click on grid to drop a particle (P)">Drop Particle</button>
            <button class="tab-btn" id="curv-mode-orbit" title="Click on grid to launch an orbit (O)">Launch Orbit</button>
            <button class="tab-btn" id="curv-mode-rain" title="Drop 6 particles from all directions">Rain</button>
            <button class="tab-btn" id="curv-mode-orbits" title="Multi-plane orbital demonstrations">Orbital Planes</button>
          </div>
          <div id="curv-mass-slider-group">
            <div class="slider-group">
              <label>Mass strength <span class="val" id="curv-mass-label">1.0</span></label>
              <input type="range" id="curv-mass-slider" min="1" max="100" value="10" step="1">
            </div>
          </div>
          <div id="curv-launch-speed-group" style="display:none;">
            <div class="slider-group">
              <label>Launch speed <span class="val" id="curv-speed-label">1.0x v<sub>circ</sub></span></label>
              <input type="range" id="curv-launch-speed" min="1" max="100" value="50" step="1">
            </div>
          </div>
          <div id="curv-inclination-group" style="display:none;">
            <div class="slider-group">
              <label>Orbital inclination <span class="val" id="curv-incl-label">0&deg;</span></label>
              <input type="range" id="curv-inclination" min="0" max="180" value="0" step="1">
            </div>
          </div>
          <div id="curv-orbit-presets" style="display:none;gap:4px;flex-wrap:wrap;">
            <div class="curv-btn-group-label">Orbital Demos</div>
            <div class="curv-btn-group">
              <button class="tab-btn" id="curv-orbpreset-3plane">3-Plane</button>
              <button class="tab-btn" id="curv-orbpreset-solar">Solar System</button>
              <button class="tab-btn" id="curv-orbpreset-globular">Globular</button>
            </div>
          </div>
          <div id="curv-orbit-info" style="display:none;color:var(--dim);font-size:0.7rem;padding:2px 0;line-height:1.4;font-style:italic;"></div>
          <div class="curv-btn-group" style="margin-top:2px;">
            <button class="tab-btn" id="curv-clear">Clear All</button>
            <button class="tab-btn" id="curv-fullscreen" style="margin-left:auto;">Fullscreen</button>
          </div>
        </div>
        <!-- Help (collapsible, closed by default) -->
        <div class="curv-collapse-header" id="curv-help-toggle">Help &#9654;</div>
        <div class="curv-collapse-body" id="curv-help-body">
          <p><strong>Camera:</strong> Drag to rotate, right-drag to pan, scroll to zoom. Use Top/Side/Front buttons for preset angles.</p>
          <p><strong>3D View:</strong> The mass sits at the <em>center</em> of the grid &mdash; gravity curves space equally in ALL directions, not just &ldquo;down.&rdquo;</p>
          <p><strong>Shells:</strong> Three nested shells show gravity strength. <span style="color:#ff3333;">Inner (red)</span> = strongest, <span style="color:#f59e0b;">Middle (orange)</span> = medium, <span style="color:#3b82f6;">Outer (blue)</span> = weakest.</p>
          <p><strong>Modes:</strong> Place Mass adds gravity sources. Drop/Orbit/Rain launch test particles. Orbital Planes shows multi-inclination orbits.</p>
        </div>
      </div>
    </div>
    <!-- Readouts (inside bottom panel) -->
    <div class="readouts" id="curv-readout-strip">
      <div class="readout">
        <div class="label">Masses</div>
        <div class="value blue" id="curv-mass-count">0</div>
      </div>
      <div class="readout">
        <div class="label">Particles</div>
        <div class="value cyan" id="curv-particle-count">0</div>
      </div>
      <div class="readout">
        <div class="label">Velocity</div>
        <div class="value purple" id="curv-particle-vel">0.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="curv-dilation">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Orbital Period</div>
        <div class="value red" id="curv-orbit-period">&mdash;</div>
      </div>
      <div class="readout readout-adv">
        <div class="label">Altitude</div>
        <div class="value cyan" id="curv-altitude">&mdash;</div>
      </div>
      <div class="readout readout-adv">
        <div class="label">Escape Vel</div>
        <div class="value red" id="curv-escape-vel">&mdash;</div>
      </div>
      <div class="readout">
        <div class="label">Time Elapsed</div>
        <div class="value cyan" id="curv-elapsed-time">0.0s</div>
      </div>
      <div class="readout readout-adv">
        <div class="label">Energy Drift</div>
        <div class="value" id="curv-energy-drift" style="color:#22c55e;">&mdash;</div>
      </div>
    </div>
    </div><!-- /curv-bottom-panel -->

    <!-- Hidden info divs (kept for JS compatibility) -->
    <div id="curv-3d-hint" style="display:none;color:var(--accent);font-size:0.82rem;padding:4px 0;line-height:1.5;">
      <strong>3D Spherical view:</strong> The mass sits at the <em>center</em> of the grid &mdash; gravity curves space equally in ALL directions, not just &ldquo;down.&rdquo; Use Top/Side/Front views to see this from every angle.
    </div>

    <p class="explain level-beg explain-bottom">
      <strong>Gravity pulls from ALL directions, not just &ldquo;down.&rdquo;</strong> The 2D trampoline picture is helpful but
      misleading &mdash; it makes gravity look like it only bends space downward. Switch to <strong>3D Spherical</strong>
      to see how space actually curves equally in every direction around a mass. Try <strong>Rain</strong>
      to drop objects from above, below, and all sides &mdash; they all curve the same way!
    </p>
    <p class="explain level-int explain-bottom">
      <strong>Gravity isn't &ldquo;downward&rdquo; &mdash; it's inward.</strong> The 2D sheet view shows the classic &ldquo;rubber sheet&rdquo; analogy,
      but this is misleading because it only shows curvature in one direction. Switch to <strong>3D Spherical</strong> view to see
      concentric shells of spacetime compressing equally in all directions around a mass. Use <strong>Rain</strong>
      to drop test objects from above, below, and all sides &mdash; they all experience identical curvature.
      An orbiting planet isn't being &ldquo;pulled&rdquo; &mdash; it's following the straightest possible path (a <strong>geodesic</strong>)
      through warped spacetime.
    </p>
    <p class="explain level-adv explain-bottom">
      <strong>Spherical symmetry of the Schwarzschild solution:</strong> The metric is diagonal in (t,r,&theta;,&phi;)
      and depends only on r, making all angular directions equivalent. The orbital plane presets demonstrate
      this: orbits at any inclination are equally stable. The 2D embedding diagram (Flamm&rsquo;s paraboloid)
      embeds only the equatorial slice (t=const, &theta;=&pi;/2) into Euclidean 3-space, which is inherently misleading.
      The 3D shell view better represents the full spatial curvature of the r=const surfaces.
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 06: Photon Clocks -->
<section id="sec-clocks">
  <h2><span class="num">06</span> Photon Clock &amp; Time Dilation <span class="section-badge badge-beginner">Beginner</span></h2>
  <p class="subtitle">A photon bouncing between two mirrors reveals how time itself slows for moving objects.</p>

  <div class="card">
    <p class="explain level-beg">
      Imagine a clock that works by bouncing a beam of light between two mirrors, up and down.
      When the clock is sitting still, the light goes straight up and down. But when the clock moves sideways,
      the light has to travel a longer zigzag path &mdash; and light <em>always</em> goes at the same speed.
      So the moving clock <strong>must tick slower</strong>. That&rsquo;s time dilation!
    </p>
    <p class="explain level-int">
      A <strong>photon clock</strong> bounces a photon between two mirrors. At rest, the photon travels straight up and down.
      But when the clock moves, the photon must travel a longer diagonal path. Since light speed is constant (c),
      <strong>the moving clock ticks slower</strong> &mdash; this is <span class="term">time dilation<span class="term-tip">Time passes slower for objects moving at high speed</span></span>.
    </p>
    <p class="explain level-adv">
      The photon clock thought experiment directly derives the <span class="term">Lorentz factor<span class="term-tip">&gamma; = 1/&radic;(1&minus;v&sup2;/c&sup2;) &mdash; the ratio of coordinate time to proper time</span></span> from Pythagorean geometry.
      In the rest frame, the round-trip time is t&#x2080; = 2L/c. In a frame where the clock moves at v, the photon
      path length is 2&radic;(L&sup2; + (vt/2)&sup2;). Setting this equal to ct and solving: t = &gamma;t&#x2080; where &gamma; = 1/&radic;(1&minus;&beta;&sup2;).
      The Pythagorean triangle overlay shows the geometry directly. This result also follows from the Minkowski metric
      by computing proper time along the clock&rsquo;s worldline.
    </p>

    <div class="slider-group">
      <label>Velocity <span class="val" id="clock-vel-label">0.00c</span></label>
      <input type="range" id="clock-vel" min="0" max="99" value="0" step="1">
    </div>

    <div class="clock-row">
      <div>
        <div class="clock-label">Stationary Clock</div>
        <div class="canvas-wrap">
          <canvas id="clock-rest" width="400" height="300"></canvas>
        </div>
      </div>
      <div>
        <div class="clock-label">Moving Clock (v = <span id="clock-v-display">0.00c</span>)</div>
        <div class="canvas-wrap">
          <canvas id="clock-moving" width="400" height="300"></canvas>
        </div>
      </div>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Velocity</div>
        <div class="value cyan" id="r-vel">0.00c</div>
      </div>
      <div class="readout">
        <div class="label">Lorentz Factor (γ)</div>
        <div class="value purple" id="r-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="r-dilation">1.000×</div>
      </div>
      <div class="readout">
        <div class="label">1 Earth Hour =</div>
        <div class="value blue" id="r-traveler">60.0 min</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 06b: Spacetime Diagram -->
<section id="sec-spacetime">
  <h2><span class="num">06b</span> Minkowski Spacetime Diagram <span class="section-badge badge-intermediate">Intermediate</span></h2>
  <p class="subtitle">The geometry of the universe &mdash; why the speed of light divides spacetime into reachable and forever-unreachable regions.</p>

  <div class="card">
    <p class="explain level-beg">
      Think of a map, but instead of two space directions, one axis is space and the other is time.
      Your path through this map is called your <span class="term">worldline<span class="term-tip">Your path through spacetime &mdash; shows everywhere you&rsquo;ve been and when</span></span>
      &mdash; it shows everywhere you&rsquo;ve been and when. Light draws diagonal lines on this map.
      Everything inside those lines is reachable; everything outside is forever out of reach (you&rsquo;d need FTL to get there).
    </p>
    <p class="explain level-int">
      A <strong>spacetime diagram</strong> plots space (horizontal) against time (vertical, in units of ct).
      Light always travels at 45&deg; lines, forming the <span class="term">light cone<span class="term-tip">The boundary between reachable and unreachable regions of spacetime</span></span>. Any massive object's worldline
      must stay <em>inside</em> the cone (steeper than 45&deg;). To go faster than light would mean leaving
      the cone &mdash; entering a region where cause and effect break down.
    </p>
    <p class="explain level-adv">
      The Minkowski spacetime diagram represents the invariant interval ds&sup2; = &minus;c&sup2;dt&sup2; + dx&sup2;.
      Light cones are null surfaces (ds&sup2; = 0) at 45&deg;. Timelike worldlines (ds&sup2; &lt; 0) stay inside the cone.
      Spacelike separations (ds&sup2; &gt; 0) lie outside &mdash; events here have frame-dependent temporal ordering.
      The object&rsquo;s <span class="term">worldline<span class="term-tip">Your path through spacetime &mdash; shows everywhere you&rsquo;ve been and when</span></span>
      angle &theta; = arctan(v/c) relative to the time axis.
    </p>

    <div class="slider-group">
      <label>Observer velocity <span class="val" id="st-vel-label">0.00c</span></label>
      <input type="range" id="st-vel" min="0" max="990" value="0" step="10">
    </div>

    <div class="canvas-wrap">
      <canvas id="spacetime-canvas" width="800" height="600"></canvas>
    </div>

    <div class="st-legend">
      <div class="st-legend-item"><span class="swatch" style="background:rgba(250,204,21,0.4)"></span> Future light cone (reachable)</div>
      <div class="st-legend-item"><span class="swatch" style="background:rgba(96,165,250,0.25)"></span> Spacelike region (FTL needed)</div>
      <div class="st-legend-item"><span class="swatch" style="background:#f59e0b"></span> Light (45&deg;, c)</div>
      <div class="st-legend-item"><span class="swatch" style="background:#06b6d4"></span> Object worldline</div>
      <div class="st-legend-item"><span class="swatch" style="background:#a855f7"></span> Simultaneity line (moving frame)</div>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Worldline angle</div>
        <div class="value cyan" id="st-angle">90.0&deg;</div>
      </div>
      <div class="readout">
        <div class="label">Light cone angle</div>
        <div class="value yellow" id="st-cone">45.0&deg;</div>
      </div>
      <div class="readout">
        <div class="label">Proper time ratio</div>
        <div class="value purple" id="st-proper">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Simultaneity tilt</div>
        <div class="value blue" id="st-simtilt">0.0&deg;</div>
      </div>
    </div>

    <p class="explain level-beg">
      As you speed up, your path tilts closer to the light line. The line that shows &ldquo;what&rsquo;s happening right now&rdquo;
      also tilts &mdash; different speeds disagree about what &ldquo;now&rdquo; means! At light speed, everything merges
      into the diagonal. Going faster would flip cause and effect &mdash; that&rsquo;s why it&rsquo;s impossible.
    </p>
    <p class="explain level-int">
      As velocity increases, the worldline tilts toward the light cone and the <strong>simultaneity line</strong>
      (what the moving observer calls "now") tilts symmetrically. At v = c, both collapse onto the light cone.
      Beyond c, the worldline would enter the <strong>spacelike region</strong> &mdash; the object would arrive
      before it left in some reference frames, violating causality.
    </p>
    <p class="explain level-adv">
      Under a Lorentz boost, the time axis (worldline) and space axis (simultaneity line) scissor symmetrically
      toward the light cone. At rapidity &phi; = arctanh(&beta;), the worldline angle is &phi; from vertical and
      the simultaneity line tilts by the same angle from horizontal. Proper time tick spacing along the worldline
      stretches by &gamma;, reflecting the time dilation factor. At &beta; = 1, the axes collapse onto the null cone,
      and proper time intervals vanish (ds&sup2; = 0).
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 07: Lorentz Factor -->
<section id="sec-lorentz">
  <h2><span class="num">07</span> The Lorentz Factor <span class="section-badge badge-intermediate">Intermediate</span></h2>
  <p class="subtitle">The mathematical heart of special relativity &mdash; and why it blows up at light speed.</p>

  <div class="card">
    <div class="canvas-wrap">
      <canvas id="lorentz-graph" width="800" height="400"></canvas>
    </div>

    <div class="slider-group">
      <label>Explore velocity <span class="val" id="lorentz-vel-label">0.00c</span></label>
      <input type="range" id="lorentz-vel" min="0" max="999" value="0" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">v / c</div>
        <div class="value cyan" id="l-v">0.000</div>
      </div>
      <div class="readout">
        <div class="label">γ (Lorentz Factor)</div>
        <div class="value purple" id="l-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Length Contraction</div>
        <div class="value blue" id="l-length">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">Relativistic Mass</div>
        <div class="value yellow" id="l-mass">1.000× m₀</div>
      </div>
    </div>

    <p class="explain level-beg">
      The <span class="term">Lorentz factor<span class="term-tip">A number (&gamma;) that tells you how much time slows and space contracts at a given speed</span></span>
      (written as &gamma;, the Greek letter &ldquo;gamma&rdquo;) tells us how much time slows down and space shrinks at any speed.
      At everyday speeds it&rsquo;s basically 1 (no effect). But as you approach light speed, it shoots up toward infinity!
      That&rsquo;s why you can never actually reach light speed &mdash; all the effects become infinitely strong.
    </p>
    <p class="explain level-int">
      The graph above shows how &gamma; stays near 1 at low velocities but <strong>diverges to infinity</strong> as v &rarr; c.
      This single number governs time dilation (clocks run &gamma;&times; slower), length contraction
      (objects shrink by 1/&gamma;), and relativistic mass increase (inertia grows by &gamma;). The derivation below
      shows how it emerges directly from the photon clock.
    </p>
    <p class="explain level-adv">
      &gamma; = (1 &minus; &beta;&sup2;)^(&minus;1/2) is the Lorentz factor, where &beta; = v/c. In terms of rapidity &phi; = arctanh(&beta;),
      &gamma; = cosh(&phi;) and &beta;&gamma; = sinh(&phi;). Rapidities add linearly under Lorentz boosts, making them the
      natural velocity parameter. The divergence at &beta; = 1 reflects the null boundary of the Lorentz group.
    </p>

    <div class="derivation eq-only">
      <h4>Derivation from the Photon Clock</h4>
      <div class="deriv-step">
        <span class="step-num">1</span>
        <span>Light path at rest: L = c&middot;t₀</span>
        <span class="annotation">straight up-down</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">2</span>
        <span>Light path moving: D = c&middot;t</span>
        <span class="annotation">diagonal path</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">3</span>
        <span>(c&middot;t)&sup2; = (v&middot;t)&sup2; + (c&middot;t₀)&sup2;</span>
        <span class="annotation">Pythagorean theorem</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">4</span>
        <span>c&sup2;t&sup2; &minus; v&sup2;t&sup2; = c&sup2;t₀&sup2;</span>
        <span class="annotation">rearrange</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">5</span>
        <span>t&sup2;(1 &minus; v&sup2;/c&sup2;) = t₀&sup2;</span>
        <span class="annotation">factor out t&sup2;</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">6</span>
        <span>t = t₀ / &radic;(1 &minus; v&sup2;/c&sup2;) = γ&middot;t₀</span>
        <span class="annotation">time dilation!</span>
      </div>
      <div class="deriv-step">
        <span class="step-num">7</span>
        <span>γ = 1 / &radic;(1 &minus; v&sup2;/c&sup2;)</span>
        <span class="annotation">Lorentz factor</span>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 08: Energy -->
<section id="sec-energy">
  <h2><span class="num">08</span> The Infinite Energy Barrier <span class="section-badge badge-advanced">Advanced</span></h2>
  <p class="subtitle">E = mc&sup2; is only the rest energy. The full picture shows why FTL requires infinite energy.</p>

  <div class="card">
    <div class="tab-bar">
      <button class="tab-btn active" data-tab="energy-ke">Kinetic Energy</button>
      <button class="tab-btn" data-tab="energy-total">Total Energy</button>
      <button class="tab-btn" data-tab="energy-momentum">Momentum</button>
    </div>

    <div id="energy-ke" class="tab-content active">
      <div class="canvas-wrap">
        <canvas id="ke-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain level-beg">
        The faster you push something, the harder it gets to push it faster. Near light speed, it takes
        <strong>almost infinite energy</strong> to speed up even a tiny bit more. The yellow line (real physics)
        shoots up way faster than the white line (old-school physics). That&rsquo;s the energy wall.
      </p>
      <p class="explain level-int">
        Relativistic kinetic energy: <strong>KE = (&gamma; - 1)mc&sup2;</strong>. As v approaches c, &gamma; approaches infinity,
        so the energy needed grows without bound. No finite energy source can accelerate mass to light speed.
      </p>
      <p class="explain level-adv">
        KE = (&gamma; &minus; 1)mc&sup2; is derived from the work integral: KE = &int;F&middot;dx = &int;(dp/dt)&middot;v dt
        where p = &gamma;mv. The classical limit (&beta; &laquo; 1): KE &asymp; &frac12;mv&sup2; + (3/8)mv&sup4;/c&sup2; + &hellip;
        The divergence at &beta; &rarr; 1 is not merely asymptotic; it follows from the Lorentz group structure.
      </p>
    </div>

    <div id="energy-total" class="tab-content">
      <div class="canvas-wrap">
        <canvas id="total-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain level-beg">
        Even when something is sitting still, it has a huge amount of energy locked inside it &mdash;
        that&rsquo;s what E = mc&sup2; means! The faster it moves, the more total energy it has, and that energy
        shoots up toward infinity near light speed.
      </p>
      <p class="explain level-int">
        Total relativistic energy: <strong>E = &gamma;mc&sup2;</strong>. At rest (v=0), this reduces to E = mc&sup2;.
        The rest mass energy of a 1 kg object is <strong>9 &times; 10&sup1;&sup6; joules</strong> &mdash; equivalent to ~21 megatons of TNT.
      </p>
      <p class="explain level-adv">
        E = &gamma;mc&sup2; is the time component of the four-momentum p&mu; = (&gamma;mc, &gamma;mv). The invariant mass
        is recovered from p&mu;p&sup;&mu; = &minus;m&sup2;c&sup2;, giving E&sup2; = (pc)&sup2; + (mc&sup2;)&sup2;.
        For massless particles (m = 0), E = pc, which is satisfied by photons with E = h&nu;.
      </p>
    </div>

    <div id="energy-momentum" class="tab-content">
      <div class="canvas-wrap">
        <canvas id="momentum-graph" width="800" height="400"></canvas>
      </div>
      <p class="explain level-beg">
        Momentum is how hard something is to stop. Near light speed, an object&rsquo;s momentum grows
        way faster than you&rsquo;d expect &mdash; it becomes incredibly hard to stop or speed up.
        The real curve (yellow) diverges from the straight line (white) you&rsquo;d expect from everyday experience.
      </p>
      <p class="explain level-int">
        Relativistic momentum: <strong>p = &gamma;mv</strong>. Unlike classical p = mv, this diverges as v &rarr; c.
        The energy-momentum relation: <strong>E&sup2; = (pc)&sup2; + (mc&sup2;)&sup2;</strong> unifies energy, momentum, and mass.
      </p>
      <p class="explain level-adv">
        The four-momentum p&mu; = m(dx&mu;/d&tau;) = (&gamma;mc, &gamma;m<strong>v</strong>) transforms as a Lorentz four-vector.
        Its spatial magnitude p = &gamma;mv diverges as &beta; &rarr; 1. The invariant mass-shell relation
        p&mu;p&sup;&mu; = &minus;m&sup2;c&sup2; yields E&sup2; = p&sup2;c&sup2; + m&sup2;c&sup4;, the most general energy-momentum relation.
      </p>
    </div>

    <div class="slider-group">
      <label>Object velocity <span class="val" id="energy-vel-label">0.00c</span></label>
      <input type="range" id="energy-vel" min="0" max="999" value="0" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Energy (mc&sup2;)</div>
        <div class="value blue" id="e-rest">1.00</div>
      </div>
      <div class="readout">
        <div class="label">Kinetic Energy</div>
        <div class="value yellow" id="e-ke">0.00</div>
      </div>
      <div class="readout">
        <div class="label">Total Energy (γmc&sup2;)</div>
        <div class="value red" id="e-total">1.00</div>
      </div>
      <div class="readout">
        <div class="label">Momentum (γmv)</div>
        <div class="value purple" id="e-mom">0.00</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 09: Real-World Examples -->
<section id="sec-examples">
  <h2><span class="num">09</span> Real-World Evidence <span class="section-badge badge-beginner">Beginner</span></h2>
  <p class="subtitle">Special relativity isn't just theory &mdash; we measure its effects every day.</p>

  <div class="examples-grid">
    <div class="example-card">
      <div class="icon">&#x1F6F0;</div>
      <h4>GPS Satellites</h4>
      <p>GPS satellites move at ~3.9 km/s. Without relativistic corrections, positioning would drift by ~11 km/day. Both special and general relativity corrections are applied.</p>
      <div class="stat">v = 0.0000130c | &Delta;t = 7 &mu;s/day (SR)</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x269B;</div>
      <h4>Muon Decay</h4>
      <p>Cosmic ray muons should decay in ~2.2&mu;s and travel only ~660m. But we detect them at sea level because time dilation at 0.998c extends their lifetime by ~15x.</p>
      <div class="stat">v = 0.998c | γ &asymp; 15.8 | range: ~10 km</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x1F500;</div>
      <h4>Particle Accelerators</h4>
      <p>At the LHC, protons reach 0.999999991c. Their relativistic mass is ~7,454 times rest mass. Each proton carries energy comparable to a flying mosquito &mdash; in a single subatomic particle.</p>
      <div class="stat">v = 0.999999991c | γ &asymp; 7,454</div>
    </div>
    <div class="example-card">
      <div class="icon">&#x2B50;</div>
      <h4>Stellar Aberration</h4>
      <p>Stars appear slightly shifted due to Earth's orbital velocity (~30 km/s). This aberration angle matches relativistic predictions exactly, not Newtonian ones.</p>
      <div class="stat">v = 0.0001c | aberration &asymp; 20.5&quot;</div>
    </div>
  </div>

  <div class="card" style="margin-top: 24px;">
    <h3>Interactive: Muon Decay Simulation</h3>
    <p class="explain level-beg">Watch tiny particles called muons rain down from the sky. They should die off after just 660 meters, but because they&rsquo;re moving at 99.8% the speed of light, time slows down for them and they survive all the way to the ground!</p>
    <p class="explain level-int">Watch muons created at 15 km altitude travel toward Earth. At rest, they'd decay after ~660m. Time dilation lets them reach the surface.</p>
    <p class="explain level-adv">Muon half-life at rest: &tau; = 2.2 &mu;s. Classical range: c&tau; &asymp; 660 m. At v = 0.998c, &gamma; &asymp; 15.8, so the dilated lifetime is &gamma;&tau; &asymp; 34.8 &mu;s, giving a range of ~10.4 km &mdash; sufficient to reach sea level from typical production altitudes of 10&ndash;15 km. This was confirmed by Rossi &amp; Hall (1941).</p>
    <div class="canvas-wrap">
      <canvas id="muon-canvas" width="800" height="300"></canvas>
    </div>
    <div style="display:flex;gap:12px;margin-top:12px;flex-wrap:wrap;">
      <button id="muon-start" class="tab-btn active" style="flex:1;min-width:120px;">Start Simulation</button>
      <button id="muon-reset" class="tab-btn" style="flex:1;min-width:120px;">Reset</button>
    </div>
    <div class="readouts" style="margin-top:16px;">
      <div class="readout">
        <div class="label">Classical Muons Surviving</div>
        <div class="value yellow" id="muon-classical">100%</div>
      </div>
      <div class="readout">
        <div class="label">Relativistic Muons Surviving</div>
        <div class="value cyan" id="muon-relativistic">100%</div>
      </div>
      <div class="readout">
        <div class="label">Altitude</div>
        <div class="value blue" id="muon-alt">15.0 km</div>
      </div>
    </div>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 10: Relativistic Mass & E=mc² -->
<section id="sec-emc2">
  <h2><span class="num">10</span> E = mc&sup2; and Mass-Energy Equivalence <span class="section-badge badge-intermediate">Intermediate</span></h2>
  <p class="subtitle">Mass is frozen energy. Energy has inertia. This is why the speed limit exists.</p>

  <div class="card">
    <div class="canvas-wrap">
      <canvas id="emc2-graph" width="800" height="400"></canvas>
    </div>

    <div class="slider-group">
      <label>Mass (kg) <span class="val" id="mass-label">1.00 kg</span></label>
      <input type="range" id="mass-slider" min="1" max="100" value="1" step="1">
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">Rest Energy</div>
        <div class="value cyan" id="emc2-rest">9.0 &times; 10&sup1;&sup6; J</div>
      </div>
      <div class="readout">
        <div class="label">Equivalent TNT</div>
        <div class="value yellow" id="emc2-tnt">21.5 MT</div>
      </div>
      <div class="readout">
        <div class="label">Could Power</div>
        <div class="value blue" id="emc2-power">A city for 2.9 years</div>
      </div>
    </div>

    <p class="explain level-beg" style="margin-top:16px;">
      A tiny amount of mass contains an <strong>enormous</strong> amount of energy. One kilogram has enough
      energy to power a city for years! This is why the speed limit exists: as you push something faster,
      the energy you add makes it harder and harder to push. Near light speed, it would take literally
      infinite energy to go any faster. Light itself can travel at c only because photons have zero mass.
    </p>
    <p class="explain level-int" style="margin-top:16px;">
      <strong>Why does E = mc&sup2; create a speed limit?</strong> When you push an object, you add energy.
      That energy increases its inertia (resistance to further acceleration). The faster it goes,
      the more energy each additional m/s requires. Approaching c, the energy requirement
      diverges to infinity. The object's inertia becomes infinite before it can reach c.
      <br><br>
      Massless particles (photons) <em>must</em> travel at exactly c &mdash; they have no rest frame.
      Anything with mass is forever trapped below c.
    </p>
    <p class="explain level-adv" style="margin-top:16px;">
      The mass-energy equivalence E&#x2080; = mc&sup2; is the rest-frame value of the time component of the four-momentum.
      Nuclear binding energy illustrates this: a helium-4 nucleus has mass 4.0026 u, less than the
      sum of its parts (4.0319 u). The mass defect &Delta;m = 0.0293 u corresponds to 27.3 MeV of binding energy.
      This is the energy source of stellar fusion. The speed limit follows from the Lorentz group:
      massive representations have timelike four-momenta (p&sup2; &lt; 0), which can never be boosted to null (p&sup2; = 0).
    </p>
  </div>
</section>

<div class="section-divider"><hr></div>

<!-- Section 11: Speed comparison -->
<section id="sec-compare">
  <h2><span class="num">11</span> Putting It All Together <span class="section-badge badge-intermediate">Intermediate</span></h2>
  <p class="subtitle">Adjust the velocity and watch all relativistic effects simultaneously.</p>

  <div class="card">
    <div class="slider-group">
      <label>Velocity <span class="val" id="master-vel-label">0.00c</span></label>
      <input type="range" id="master-vel" min="0" max="9999" value="0" step="1">
    </div>

    <div class="canvas-wrap">
      <canvas id="combined-graph" width="800" height="400"></canvas>
    </div>

    <div class="readouts">
      <div class="readout">
        <div class="label">γ (Lorentz)</div>
        <div class="value purple" id="c-gamma">1.000</div>
      </div>
      <div class="readout">
        <div class="label">Time Dilation</div>
        <div class="value yellow" id="c-time">1.000&times;</div>
      </div>
      <div class="readout">
        <div class="label">Length (% of rest)</div>
        <div class="value cyan" id="c-length">100.0%</div>
      </div>
      <div class="readout">
        <div class="label">Energy (units mc&sup2;)</div>
        <div class="value red" id="c-energy">1.000</div>
      </div>
    </div>

    <p class="explain level-beg">
      All these effects happen together. The faster you go, the more time slows, the more space contracts,
      and the more energy it costs &mdash; all at once. Move the slider to see every effect blow up at light speed.
      This is why <strong>nothing can reach the speed of light</strong>: the universe fights back from every direction.
    </p>
    <p class="explain level-int">
      The vertical dashed line marks your chosen velocity. Notice how <strong>all quantities diverge
      simultaneously</strong> as v &rarr; c. This isn't a coincidence &mdash; it's the geometry of spacetime itself.
      The speed of light isn't just a speed limit for light; it's woven into the fabric of the universe.
    </p>
    <p class="explain level-adv">
      All these effects are manifestations of the same underlying Minkowski geometry. The Lorentz factor &gamma;
      governs time dilation (&Delta;t = &gamma;&Delta;&tau;), length contraction (L = L&#x2080;/&gamma;), and relativistic energy
      (E = &gamma;mc&sup2;). Their simultaneous divergence at &beta; = 1 reflects the null boundary of the Lorentz group
      SO(3,1). The speed of light is not an empirical speed limit but a structural constant of spacetime &mdash;
      the conversion factor between space and time coordinates in the metric ds&sup2; = &minus;c&sup2;dt&sup2; + d<strong>x</strong>&sup2;.
    </p>
  </div>
</section>

<footer>
  Built to illuminate the beauty of Einstein's Special Relativity
</footer>

</div><!-- /content-wrap -->

<script>
// ==================== UTILITIES ====================
const c = 299792458; // m/s
const gamma = (beta) => 1 / Math.sqrt(1 - beta * beta);
const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
const lerp = (a, b, t) => a + (b - a) * t;

function fmt(n, d = 3) {
  if (n >= 1e18) return (n / 1e18).toFixed(1) + ' × 10¹⁸';
  if (n >= 1e16) return (n / 1e16).toFixed(1) + ' × 10¹⁶';
  if (n >= 1e12) return (n / 1e12).toFixed(1) + ' × 10¹²';
  if (n >= 1e9) return (n / 1e9).toFixed(1) + ' × 10⁹';
  if (n >= 1e6) return (n / 1e6).toFixed(1) + ' × 10⁶';
  if (n >= 1e4) return (n / 1e4).toFixed(1) + ' × 10⁴';
  if (n >= 100) return n.toFixed(1);
  if (n >= 10) return n.toFixed(2);
  return n.toFixed(d);
}

function setupCanvas(id) {
  const canvas = document.getElementById(id);
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  const w = canvas.getAttribute('width') | 0;
  const h = canvas.getAttribute('height') | 0;
  canvas.width = w * dpr;
  canvas.height = h * dpr;
  canvas.style.width = w + 'px';
  canvas.style.maxWidth = '100%';
  canvas.style.height = 'auto';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);
  return { canvas, ctx, w, h };
}

// ==================== STARFIELD ====================
(function initStarfield() {
  const canvas = document.getElementById('starfield');
  const ctx = canvas.getContext('2d');
  let stars = [];
  function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    stars = Array.from({ length: 200 }, () => ({
      x: Math.random() * canvas.width,
      y: Math.random() * canvas.height,
      r: Math.random() * 1.5 + 0.3,
      a: Math.random() * 0.6 + 0.2,
      speed: Math.random() * 0.0005 + 0.0002,
      phase: Math.random() * Math.PI * 2
    }));
  }
  resize();
  window.addEventListener('resize', resize);
  function draw(t) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    stars.forEach(s => {
      const flicker = 0.5 + 0.5 * Math.sin(t * s.speed * 1000 + s.phase);
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,220,255,${s.a * flicker})`;
      ctx.fill();
    });
    requestAnimationFrame(draw);
  }
  requestAnimationFrame(draw);
})();

// ==================== PHOTON CLOCKS (smooth) ====================
(function initClocks() {
  const restC = setupCanvas('clock-rest');
  const moveC = setupCanvas('clock-moving');
  const slider = document.getElementById('clock-vel');
  let beta = 0;
  const mirrorGap = 180;
  const mirrorY1 = 50;
  const mirrorY2 = mirrorY1 + mirrorGap;
  const TRAIL_LEN = 18;

  // Trail buffers
  const restTrail = [];
  const moveTrail = [];

  // Mirror flash state (0-1, decays)
  let restFlash = 0, moveFlash = 0;
  let restLastDir = true, moveLastDir = true; // true = going down

  // Proper timestamps
  let prevTs = null;
  let accumTime = 0;

  function drawMirror(ctx, x, y, halfW, flash, color) {
    // Mirror body
    const grad = ctx.createLinearGradient(x - halfW, y - 3, x + halfW, y + 3);
    grad.addColorStop(0, '#1e293b');
    grad.addColorStop(0.5, '#334155');
    grad.addColorStop(1, '#1e293b');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.roundRect(x - halfW, y - 3, halfW * 2, 6, 2);
    ctx.fill();
    // Reflective highlight
    ctx.strokeStyle = `rgba(148,163,184,${0.4 + flash * 0.6})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(x - halfW + 4, y);
    ctx.lineTo(x + halfW - 4, y);
    ctx.stroke();
    // Flash glow
    if (flash > 0.01) {
      const fg = ctx.createRadialGradient(x, y, 0, x, y, 40 * flash);
      fg.addColorStop(0, color.replace(')', `,${flash * 0.5})`).replace('rgb', 'rgba'));
      fg.addColorStop(1, 'transparent');
      ctx.fillStyle = fg;
      ctx.fillRect(x - 50, y - 50, 100, 100);
    }
  }

  function drawPhoton(ctx, x, y, color, trail, radius) {
    // Trail
    for (let i = 0; i < trail.length; i++) {
      const a = (i / trail.length) * 0.35;
      const r = (i / trail.length) * (radius || 4) * 0.8;
      ctx.beginPath();
      ctx.arc(trail[i].x, trail[i].y, r, 0, Math.PI * 2);
      ctx.fillStyle = color.replace(')', `,${a})`).replace('rgb', 'rgba');
      ctx.fill();
    }
    // Outer glow
    const g1 = ctx.createRadialGradient(x, y, 0, x, y, 18);
    g1.addColorStop(0, color.replace(')', ',0.4)').replace('rgb', 'rgba'));
    g1.addColorStop(0.5, color.replace(')', ',0.1)').replace('rgb', 'rgba'));
    g1.addColorStop(1, 'transparent');
    ctx.fillStyle = g1;
    ctx.fillRect(x - 20, y - 20, 40, 40);
    // Inner glow
    const g2 = ctx.createRadialGradient(x, y, 0, x, y, 8);
    g2.addColorStop(0, '#ffffff');
    g2.addColorStop(0.3, color);
    g2.addColorStop(1, 'transparent');
    ctx.fillStyle = g2;
    ctx.beginPath();
    ctx.arc(x, y, 6, 0, Math.PI * 2);
    ctx.fill();
    // Core
    ctx.beginPath();
    ctx.arc(x, y, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fff';
    ctx.fill();
  }

  function drawTicks(ctx, w, h, count, label, color) {
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, w / 2, h - 8);
    // Tick counter with color
    ctx.font = 'bold 18px Courier New';
    ctx.fillStyle = color;
    ctx.fillText(count, w / 2, h - 26);
    ctx.font = '10px system-ui';
    ctx.fillStyle = '#64748b';
    ctx.fillText('ticks', w / 2 + 28, h - 24);
  }

  function drawPythagorean(ctx, topX, botX, alpha) {
    if (alpha < 0.02) return;
    const cx = (topX + botX) / 2;
    // Vertical leg (c·t₀)
    ctx.strokeStyle = `rgba(6,182,212,${alpha * 0.7})`;
    ctx.lineWidth = 1.5;
    ctx.setLineDash([5, 3]);
    ctx.beginPath();
    ctx.moveTo(cx, mirrorY1);
    ctx.lineTo(cx, mirrorY2);
    ctx.stroke();
    // Horizontal leg (v·t)
    ctx.strokeStyle = `rgba(245,158,11,${alpha * 0.7})`;
    ctx.beginPath();
    ctx.moveTo(cx, mirrorY2);
    ctx.lineTo(botX, mirrorY2);
    ctx.stroke();
    // Hypotenuse (c·t)
    ctx.strokeStyle = `rgba(168,85,247,${alpha * 0.9})`;
    ctx.setLineDash([]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(topX, mirrorY1);
    ctx.lineTo(botX, mirrorY2);
    ctx.stroke();
    ctx.setLineDash([]);
    // Labels
    ctx.font = 'italic 11px Georgia';
    ctx.textAlign = 'center';
    ctx.fillStyle = `rgba(6,182,212,${alpha})`;
    ctx.fillText('c·t₀', cx - 14, (mirrorY1 + mirrorY2) / 2 + 4);
    ctx.fillStyle = `rgba(245,158,11,${alpha})`;
    ctx.fillText('v·t', (cx + botX) / 2, mirrorY2 + 15);
    ctx.fillStyle = `rgba(168,85,247,${alpha})`;
    const hx = (topX + botX) / 2 + 14;
    const hy = (mirrorY1 + mirrorY2) / 2 - 6;
    ctx.fillText('c·t', hx, hy);
    // Right angle marker
    const sz = 8;
    ctx.strokeStyle = `rgba(100,116,139,${alpha * 0.6})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(cx + sz, mirrorY2);
    ctx.lineTo(cx + sz, mirrorY2 - sz);
    ctx.lineTo(cx, mirrorY2 - sz);
    ctx.stroke();
  }

  function animate(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50); // cap at 50ms to handle tab-switching
    prevTs = ts;
    accumTime += dt;

    const restPeriod = 1200;
    const g = beta > 0 ? gamma(beta) : 1;
    const movePeriod = restPeriod * g;

    const restTicks = Math.floor(accumTime / restPeriod);
    const moveTicks = Math.floor(accumTime / movePeriod);

    // --- Rest clock ---
    {
      const { ctx, w, h } = restC;
      ctx.clearRect(0, 0, w, h);
      const cx = w / 2;

      const phase = (accumTime % restPeriod) / restPeriod;
      const goingDown = phase < 0.5;
      const t = goingDown ? phase * 2 : (1 - phase) * 2;
      // Ease in-out for smoother bounce
      const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;
      const py = goingDown ? lerp(mirrorY1, mirrorY2, et) : lerp(mirrorY2, mirrorY1, et);

      // Flash on direction change
      if (goingDown !== restLastDir) {
        restFlash = 1;
        restLastDir = goingDown;
      }
      restFlash *= 0.9;

      // Vertical guide
      ctx.strokeStyle = 'rgba(71,85,105,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.beginPath();
      ctx.moveTo(cx, mirrorY1 + 6);
      ctx.lineTo(cx, mirrorY2 - 6);
      ctx.stroke();
      ctx.setLineDash([]);

      drawMirror(ctx, cx, mirrorY1, 35, goingDown ? 0 : restFlash, 'rgb(6,182,212)');
      drawMirror(ctx, cx, mirrorY2, 35, goingDown ? restFlash : 0, 'rgb(6,182,212)');

      // Update trail
      restTrail.push({ x: cx, y: py });
      if (restTrail.length > TRAIL_LEN) restTrail.shift();

      drawPhoton(ctx, cx, py, 'rgb(6,182,212)', restTrail);
      drawTicks(ctx, w, h, restTicks, 'Stationary Observer', '#06b6d4');
    }

    // --- Moving clock ---
    {
      const { ctx, w, h } = moveC;
      ctx.clearRect(0, 0, w, h);

      const phase = (accumTime % movePeriod) / movePeriod;
      const goingDown = phase < 0.5;
      const t = goingDown ? phase * 2 : (1 - phase) * 2;
      const et = t < 0.5 ? 2 * t * t : 1 - Math.pow(-2 * t + 2, 2) / 2;

      const drift = beta * 120;
      const cx = w / 2;
      const topX = cx - drift;
      const botX = cx + drift;
      const px = goingDown ? lerp(topX, botX, et) : lerp(botX, topX, et);
      const py = goingDown ? lerp(mirrorY1, mirrorY2, et) : lerp(mirrorY2, mirrorY1, et);

      if (goingDown !== moveLastDir) {
        moveFlash = 1;
        moveLastDir = goingDown;
      }
      moveFlash *= 0.9;

      // Pythagorean triangle (more visible at higher speeds)
      drawPythagorean(ctx, topX, botX, Math.min(beta * 2, 1));

      // Diagonal guide path
      ctx.strokeStyle = 'rgba(168,85,247,0.15)';
      ctx.lineWidth = 1;
      ctx.setLineDash([3, 6]);
      ctx.beginPath();
      ctx.moveTo(topX, mirrorY1);
      ctx.lineTo(botX, mirrorY2);
      ctx.moveTo(botX, mirrorY2);
      ctx.lineTo(topX, mirrorY1);
      ctx.stroke();
      ctx.setLineDash([]);

      drawMirror(ctx, topX, mirrorY1, 35, goingDown ? 0 : moveFlash, 'rgb(168,85,247)');
      drawMirror(ctx, botX, mirrorY2, 35, goingDown ? moveFlash : 0, 'rgb(168,85,247)');

      moveTrail.push({ x: px, y: py });
      if (moveTrail.length > TRAIL_LEN) moveTrail.shift();

      drawPhoton(ctx, px, py, 'rgb(168,85,247)', moveTrail);
      drawTicks(ctx, w, h, moveTicks, 'Moving Observer', '#a855f7');

      // Velocity arrow
      if (beta > 0.01) {
        const arrowY = mirrorY2 + 30;
        ctx.strokeStyle = 'rgba(245,158,11,0.6)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(cx - 50, arrowY);
        ctx.lineTo(cx + 50, arrowY);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(cx + 50, arrowY);
        ctx.lineTo(cx + 42, arrowY - 4);
        ctx.moveTo(cx + 50, arrowY);
        ctx.lineTo(cx + 42, arrowY + 4);
        ctx.stroke();
        ctx.fillStyle = 'rgba(245,158,11,0.7)';
        ctx.font = '11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('v = ' + beta.toFixed(2) + 'c →', cx, arrowY - 8);
      }
    }

    requestAnimationFrame(animate);
  }

  slider.addEventListener('input', () => {
    beta = slider.value / 100;
    const g = beta > 0 ? gamma(beta) : 1;
    document.getElementById('clock-vel-label').textContent = beta.toFixed(2) + 'c';
    document.getElementById('clock-v-display').textContent = beta.toFixed(2) + 'c';
    document.getElementById('r-vel').textContent = beta.toFixed(2) + 'c';
    document.getElementById('r-gamma').textContent = fmt(g);
    document.getElementById('r-dilation').textContent = fmt(g) + '×';
    const travMinutes = 60 / g;
    document.getElementById('r-traveler').textContent = travMinutes.toFixed(1) + ' min';
  });

  requestAnimationFrame(animate);
})();

// ==================== SPACETIME DIAGRAM ====================
(function initSpacetime() {
  const { ctx, w, h } = setupCanvas('spacetime-canvas');
  const slider = document.getElementById('st-vel');
  let beta = 0;
  let animBeta = 0; // smoothly interpolated
  let animTime = 0;
  let prevTs = null;

  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;
    animTime += dt;

    // Smooth interpolation toward target beta
    animBeta += (beta - animBeta) * Math.min(1, dt * 0.008);

    ctx.clearRect(0, 0, w, h);
    const ox = w / 2;    // origin x
    const oy = h * 0.75; // origin y (lower part so more future visible)
    const scale = Math.min(w, h) * 0.33;

    // --- Background regions ---
    // Future light cone fill (timelike)
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(ox, oy - scale * 2.5);
    ctx.lineTo(ox + scale * 1.8, oy - scale * 1.8);
    ctx.closePath();
    ctx.fillStyle = 'rgba(250,204,21,0.06)';
    ctx.fill();

    // Past light cone fill
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.2, oy + scale * 1.2);
    ctx.lineTo(ox, oy + scale * 1.6);
    ctx.lineTo(ox + scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fillStyle = 'rgba(250,204,21,0.03)';
    ctx.fill();

    // Spacelike regions (left and right of cone)
    ctx.fillStyle = 'rgba(96,165,250,0.03)';
    // Left spacelike
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox - scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(0, oy);
    ctx.lineTo(ox - scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fill();
    // Right spacelike
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox + scale * 1.8, oy - scale * 1.8);
    ctx.lineTo(w, oy);
    ctx.lineTo(ox + scale * 1.2, oy + scale * 1.2);
    ctx.closePath();
    ctx.fill();

    // --- Grid ---
    ctx.strokeStyle = 'rgba(30,41,59,0.6)';
    ctx.lineWidth = 0.5;
    for (let i = -5; i <= 5; i++) {
      // Vertical grid (space)
      const gx = ox + i * scale * 0.4;
      ctx.beginPath(); ctx.moveTo(gx, 0); ctx.lineTo(gx, h); ctx.stroke();
      // Horizontal grid (time)
      const gy = oy + i * scale * 0.4;
      ctx.beginPath(); ctx.moveTo(0, gy); ctx.lineTo(w, gy); ctx.stroke();
    }

    // --- Axes ---
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    // Space axis (x)
    ctx.beginPath(); ctx.moveTo(0, oy); ctx.lineTo(w, oy); ctx.stroke();
    // Time axis (ct)
    ctx.beginPath(); ctx.moveTo(ox, 0); ctx.lineTo(ox, h); ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('x (space)', w - 10, oy - 10);
    ctx.textAlign = 'center';
    ctx.fillText('ct (time)', ox + 28, 18);

    // Axis arrows
    ctx.fillStyle = '#475569';
    ctx.beginPath();
    ctx.moveTo(ox, 4); ctx.lineTo(ox - 5, 14); ctx.lineTo(ox + 5, 14);
    ctx.closePath(); ctx.fill();
    ctx.beginPath();
    ctx.moveTo(w - 4, oy); ctx.lineTo(w - 14, oy - 5); ctx.lineTo(w - 14, oy + 5);
    ctx.closePath(); ctx.fill();

    // --- Light cone lines (45°) ---
    ctx.strokeStyle = '#f59e0b';
    ctx.lineWidth = 2;
    ctx.setLineDash([]);
    // Future
    ctx.beginPath();
    ctx.moveTo(ox - scale * 2, oy - scale * 2);
    ctx.lineTo(ox, oy);
    ctx.lineTo(ox + scale * 2, oy - scale * 2);
    ctx.stroke();
    // Past
    ctx.globalAlpha = 0.4;
    ctx.beginPath();
    ctx.moveTo(ox - scale * 1.5, oy + scale * 1.5);
    ctx.lineTo(ox, oy);
    ctx.lineTo(ox + scale * 1.5, oy + scale * 1.5);
    ctx.stroke();
    ctx.globalAlpha = 1;

    // Light cone label
    ctx.fillStyle = '#f59e0b';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('v = c', ox + scale * 0.9 + 4, oy - scale * 0.9 - 4);
    ctx.textAlign = 'right';
    ctx.fillText('v = c', ox - scale * 0.9 - 4, oy - scale * 0.9 - 4);

    // --- Region labels ---
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillStyle = 'rgba(250,204,21,0.4)';
    ctx.fillText('FUTURE', ox, oy - scale * 1.1);
    ctx.fillText('(timelike)', ox, oy - scale * 1.1 + 15);
    ctx.fillStyle = 'rgba(250,204,21,0.25)';
    ctx.fillText('PAST', ox, oy + scale * 0.55);
    ctx.fillStyle = 'rgba(96,165,250,0.35)';
    ctx.fillText('SPACELIKE', ox + scale * 1.1, oy - scale * 0.15);
    ctx.font = '10px system-ui';
    ctx.fillText('(FTL needed)', ox + scale * 1.1, oy);
    ctx.fillStyle = 'rgba(96,165,250,0.35)';
    ctx.font = 'bold 12px system-ui';
    ctx.fillText('SPACELIKE', ox - scale * 1.1, oy - scale * 0.15);
    ctx.font = '10px system-ui';
    ctx.fillText('(FTL needed)', ox - scale * 1.1, oy);

    // --- Object worldline ---
    const b = animBeta;
    const wlLen = scale * 2;
    // Worldline: dx/d(ct) = v/c = beta, so for ct units up, x = beta * ct
    const wlEndX = ox + b * wlLen;
    const wlEndY = oy - wlLen;

    // Worldline glow
    ctx.strokeStyle = 'rgba(6,182,212,0.15)';
    ctx.lineWidth = 8;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();
    ctx.strokeStyle = 'rgba(6,182,212,0.3)';
    ctx.lineWidth = 4;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();
    // Worldline core
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2.5;
    ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(wlEndX, wlEndY); ctx.stroke();

    // Arrowhead on worldline
    const wlAngle = Math.atan2(wlEndY - oy, wlEndX - ox);
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.moveTo(wlEndX, wlEndY);
    ctx.lineTo(wlEndX - 10 * Math.cos(wlAngle - 0.3), wlEndY - 10 * Math.sin(wlAngle - 0.3));
    ctx.lineTo(wlEndX - 10 * Math.cos(wlAngle + 0.3), wlEndY - 10 * Math.sin(wlAngle + 0.3));
    ctx.closePath(); ctx.fill();

    // Worldline label
    ctx.fillStyle = '#06b6d4';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    const lblOff = b > 0.3 ? -16 : 8;
    ctx.fillText('worldline', wlEndX + 8, wlEndY + lblOff);
    ctx.font = '11px system-ui';
    ctx.fillText('v = ' + b.toFixed(2) + 'c', wlEndX + 8, wlEndY + lblOff + 15);

    // --- Simultaneity line (tilted "now" for moving observer) ---
    // In Minkowski diagram, the simultaneity line tilts at angle arctan(v/c) from x-axis
    if (b > 0.01) {
      const simLen = scale * 1.5;
      const simEndX = ox + simLen;
      const simEndY = oy - b * simLen;
      const simStartX = ox - simLen;
      const simStartY = oy + b * simLen;

      ctx.strokeStyle = 'rgba(168,85,247,0.2)';
      ctx.lineWidth = 6;
      ctx.beginPath(); ctx.moveTo(simStartX, simStartY); ctx.lineTo(simEndX, simEndY); ctx.stroke();
      ctx.strokeStyle = '#a855f7';
      ctx.lineWidth = 2;
      ctx.setLineDash([6, 4]);
      ctx.beginPath(); ctx.moveTo(simStartX, simStartY); ctx.lineTo(simEndX, simEndY); ctx.stroke();
      ctx.setLineDash([]);

      ctx.fillStyle = '#a855f7';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('"now" (moving frame)', simEndX + 6, simEndY - 4);
    }

    // --- Animated photon on the light cone ---
    const photonPhase = (animTime % 3000) / 3000;
    const photonDist = photonPhase * scale * 1.5;
    const ppx = ox + photonDist;
    const ppy = oy - photonDist;
    // Right-going photon
    const pg = ctx.createRadialGradient(ppx, ppy, 0, ppx, ppy, 6);
    pg.addColorStop(0, '#fbbf24');
    pg.addColorStop(1, 'transparent');
    ctx.fillStyle = pg;
    ctx.fillRect(ppx - 8, ppy - 8, 16, 16);
    ctx.beginPath(); ctx.arc(ppx, ppy, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fef3c7'; ctx.fill();
    // Left-going photon
    const ppx2 = ox - photonDist;
    const ppy2 = oy - photonDist;
    const pg2 = ctx.createRadialGradient(ppx2, ppy2, 0, ppx2, ppy2, 6);
    pg2.addColorStop(0, '#fbbf24');
    pg2.addColorStop(1, 'transparent');
    ctx.fillStyle = pg2;
    ctx.fillRect(ppx2 - 8, ppy2 - 8, 16, 16);
    ctx.beginPath(); ctx.arc(ppx2, ppy2, 3, 0, Math.PI * 2);
    ctx.fillStyle = '#fef3c7'; ctx.fill();

    // --- Proper time tick marks along worldline ---
    if (b > 0.01) {
      const g = gamma(Math.min(b, 0.999));
      const tickSpacing = scale * 0.3;
      const numTicks = Math.floor(wlLen / tickSpacing);
      const perpAngle = wlAngle + Math.PI / 2;
      ctx.strokeStyle = 'rgba(6,182,212,0.5)';
      ctx.lineWidth = 1;
      for (let i = 1; i <= numTicks; i++) {
        const frac = (i * tickSpacing) / wlLen;
        const tx = lerp(ox, wlEndX, frac);
        const ty = lerp(oy, wlEndY, frac);
        ctx.beginPath();
        ctx.moveTo(tx - 5 * Math.cos(perpAngle), ty - 5 * Math.sin(perpAngle));
        ctx.lineTo(tx + 5 * Math.cos(perpAngle), ty + 5 * Math.sin(perpAngle));
        ctx.stroke();
      }
      // Corresponding coordinate-time ticks on ct axis
      ctx.strokeStyle = 'rgba(148,163,184,0.3)';
      for (let i = 1; i <= numTicks; i++) {
        const frac = (i * tickSpacing) / wlLen;
        const ty = oy - frac * wlLen;
        ctx.beginPath();
        ctx.moveTo(ox - 5, ty);
        ctx.lineTo(ox + 5, ty);
        ctx.stroke();
      }
    }

    // --- Origin event dot ---
    ctx.beginPath();
    ctx.arc(ox, oy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#f1f5f9';
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('event (here, now)', ox - 10, oy + 4);

    requestAnimationFrame(draw);
  }

  slider.addEventListener('input', () => {
    beta = slider.value / 1000;
    const b = Math.min(beta, 0.999);
    document.getElementById('st-vel-label').textContent = beta.toFixed(2) + 'c';

    // Worldline angle from space axis: angle = arctan(ct / x) = arctan(1/beta)
    // From vertical (ct axis): theta = arctan(beta)
    const wlAngleDeg = beta > 0.001 ? Math.atan(1 / beta) * 180 / Math.PI : 90;
    document.getElementById('st-angle').innerHTML = wlAngleDeg.toFixed(1) + '&deg;';
    document.getElementById('st-cone').innerHTML = '45.0&deg;';

    const g = beta > 0.001 ? gamma(b) : 1;
    document.getElementById('st-proper').textContent = (1 / g).toFixed(3);

    const simTilt = Math.atan(beta) * 180 / Math.PI;
    document.getElementById('st-simtilt').innerHTML = simTilt.toFixed(1) + '&deg;';
  });

  requestAnimationFrame(draw);
})();

// ==================== LORENTZ GRAPH ====================
(function initLorentz() {
  const { ctx, w, h } = setupCanvas('lorentz-graph');
  const slider = document.getElementById('lorentz-vel');
  let currentBeta = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    // Labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);
    ctx.save();
    ctx.translate(16, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('γ (Lorentz Factor)', 0, 0);
    ctx.restore();

    // Grid + tick marks
    const maxGamma = 20;
    for (let g = 0; g <= maxGamma; g += 5) {
      const y = pad.t + gh - (g / maxGamma) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(g.toString(), pad.l - 8, y + 4);
    }
    for (let v = 0; v <= 1; v += 0.2) {
      const x = pad.l + v * gw;
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      ctx.fillText(v.toFixed(1) + 'c', x, pad.t + gh + 20);
    }

    // Curve
    ctx.beginPath();
    ctx.strokeStyle = '#a855f7';
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 500; i++) {
      const b = (i / 500) * 0.999;
      const g = gamma(b);
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(g, maxGamma) / maxGamma) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Asymptote at v=c
    ctx.strokeStyle = 'rgba(239,68,68,0.5)';
    ctx.setLineDash([6, 4]);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(pad.l + gw, pad.t);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('v = c (impossible for mass)', pad.l + gw - 6, pad.t + 16);

    // Current point
    if (currentBeta > 0) {
      const g = gamma(Math.min(currentBeta, 0.9999));
      const x = pad.l + currentBeta * gw;
      const y = pad.t + gh - (Math.min(g, maxGamma) / maxGamma) * gh;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(6,182,212,0.4)';
      ctx.beginPath();
      ctx.moveTo(x, pad.t + gh);
      ctx.lineTo(x, y);
      ctx.lineTo(pad.l, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(x, y, 6, 0, Math.PI * 2);
      ctx.fillStyle = '#06b6d4';
      ctx.fill();
      ctx.strokeStyle = '#0e7490';
      ctx.lineWidth = 2;
      ctx.stroke();
    }
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 1000;
    const g = currentBeta > 0 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    document.getElementById('lorentz-vel-label').textContent = currentBeta.toFixed(3) + 'c';
    document.getElementById('l-v').textContent = currentBeta.toFixed(3);
    document.getElementById('l-gamma').textContent = fmt(g);
    document.getElementById('l-length').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('l-mass').textContent = fmt(g) + '× m₀';
    draw();
  });

  draw();
})();

// ==================== LENGTH CONTRACTION ====================
(function initContraction() {
  const { ctx, w, h } = setupCanvas('lc-canvas');
  const slider = document.getElementById('lc-vel');
  const flybyBtn = document.getElementById('lc-flyby');
  const flybyResetBtn = document.getElementById('lc-flyby-reset');

  let beta = 0;
  let prevTs = null;

  // Fly-by state
  let flybyActive = false;
  let flybyShips = []; // {x, beta, color}

  const REST_LEN = 100; // meters (conceptual)
  const SHIP_PX_REST = 280; // pixels at rest
  const topY = 10;       // top view area
  const midY = h / 2 - 10;  // divider
  const botY = h / 2 + 10;  // bottom view area
  const viewH = h / 2 - 20;

  // --- Ship drawing ---
  function drawShip(ctx, cx, cy, lengthPx, heightPx, color, label, faded) {
    const hw = lengthPx / 2;
    const hh = heightPx / 2;
    const alpha = faded ? 0.25 : 1;

    ctx.globalAlpha = alpha;

    // Engine glow (rear)
    if (!faded && beta > 0.01) {
      const eg = ctx.createRadialGradient(cx - hw - 4, cy, 0, cx - hw - 4, cy, hh * 1.8);
      eg.addColorStop(0, 'rgba(6,182,212,0.25)');
      eg.addColorStop(1, 'transparent');
      ctx.fillStyle = eg;
      ctx.fillRect(cx - hw - hh * 2, cy - hh * 2, hh * 4, hh * 4);
    }

    // Hull body
    ctx.beginPath();
    ctx.moveTo(cx + hw, cy);                          // nose tip
    ctx.lineTo(cx + hw * 0.65, cy - hh);              // top front
    ctx.lineTo(cx - hw * 0.6, cy - hh);               // top rear
    ctx.lineTo(cx - hw, cy - hh * 0.5);               // engine top
    ctx.lineTo(cx - hw, cy + hh * 0.5);               // engine bottom
    ctx.lineTo(cx - hw * 0.6, cy + hh);               // bottom rear
    ctx.lineTo(cx + hw * 0.65, cy + hh);              // bottom front
    ctx.closePath();

    const hGrad = ctx.createLinearGradient(cx, cy - hh, cx, cy + hh);
    hGrad.addColorStop(0, color);
    hGrad.addColorStop(0.4, lightenColor(color, 40));
    hGrad.addColorStop(1, darkenColor(color, 40));
    ctx.fillStyle = hGrad;
    ctx.fill();
    ctx.strokeStyle = lightenColor(color, 60);
    ctx.lineWidth = 1;
    ctx.stroke();

    // Cockpit window
    const winW = Math.max(lengthPx * 0.12, 6);
    const winH = Math.max(heightPx * 0.35, 4);
    ctx.beginPath();
    ctx.ellipse(cx + hw * 0.4, cy, winW / 2, winH / 2, 0, 0, Math.PI * 2);
    ctx.fillStyle = 'rgba(6,182,212,0.6)';
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.beginPath();
    ctx.ellipse(cx + hw * 0.4 - 1, cy - 1, winW * 0.25, winH * 0.25, 0, 0, Math.PI * 2);
    ctx.fill();

    // Engine nozzles
    const nozW = Math.max(lengthPx * 0.04, 3);
    ctx.fillStyle = '#475569';
    for (let n = -1; n <= 1; n += 2) {
      ctx.fillRect(cx - hw - nozW, cy + n * hh * 0.25 - nozW / 2, nozW, nozW);
    }

    // Hull detail lines
    ctx.strokeStyle = lightenColor(color, 30) + '66';
    ctx.lineWidth = 0.5;
    for (let i = 1; i <= 3; i++) {
      const lx = cx - hw * 0.6 + (i / 4) * lengthPx * 0.8;
      ctx.beginPath();
      ctx.moveTo(lx, cy - hh + 2);
      ctx.lineTo(lx, cy + hh - 2);
      ctx.stroke();
    }

    // Nacelles / wings
    const wingSpan = hh * 1.5;
    ctx.fillStyle = darkenColor(color, 20);
    // Top wing
    ctx.beginPath();
    ctx.moveTo(cx - hw * 0.2, cy - hh);
    ctx.lineTo(cx - hw * 0.5, cy - wingSpan);
    ctx.lineTo(cx - hw * 0.7, cy - wingSpan);
    ctx.lineTo(cx - hw * 0.5, cy - hh);
    ctx.closePath();
    ctx.fill();
    // Bottom wing
    ctx.beginPath();
    ctx.moveTo(cx - hw * 0.2, cy + hh);
    ctx.lineTo(cx - hw * 0.5, cy + wingSpan);
    ctx.lineTo(cx - hw * 0.7, cy + wingSpan);
    ctx.lineTo(cx - hw * 0.5, cy + hh);
    ctx.closePath();
    ctx.fill();

    // Wing-tip engines
    if (lengthPx > 40) {
      ctx.fillStyle = '#94a3b8';
      ctx.beginPath();
      ctx.ellipse(cx - hw * 0.6, cy - wingSpan, nozW * 1.2, nozW * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
      ctx.beginPath();
      ctx.ellipse(cx - hw * 0.6, cy + wingSpan, nozW * 1.2, nozW * 0.8, 0, 0, Math.PI * 2);
      ctx.fill();
    }

    ctx.globalAlpha = 1;

    // Label
    if (label) {
      ctx.fillStyle = faded ? '#475569' : '#e2e8f0';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(label, cx, cy + hh * 1.5 + 22);
    }
  }

  function lightenColor(hex, amount) {
    const r = Math.min(255, parseInt(hex.slice(1,3), 16) + amount);
    const g = Math.min(255, parseInt(hex.slice(3,5), 16) + amount);
    const b = Math.min(255, parseInt(hex.slice(5,7), 16) + amount);
    return `rgb(${r},${g},${b})`;
  }
  function darkenColor(hex, amount) {
    const r = Math.max(0, parseInt(hex.slice(1,3), 16) - amount);
    const g = Math.max(0, parseInt(hex.slice(3,5), 16) - amount);
    const b = Math.max(0, parseInt(hex.slice(5,7), 16) - amount);
    return `rgb(${r},${g},${b})`;
  }

  // --- Ruler ---
  function drawRuler(ctx, x, y, totalPx, label, segments) {
    const segW = totalPx / segments;
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.fillStyle = '#64748b';
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    // Main line
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x + totalPx, y);
    ctx.stroke();
    // Ticks
    for (let i = 0; i <= segments; i++) {
      const tx = x + i * segW;
      const major = i % 2 === 0;
      ctx.beginPath();
      ctx.moveTo(tx, y - (major ? 6 : 3));
      ctx.lineTo(tx, y + (major ? 6 : 3));
      ctx.stroke();
      if (major) {
        ctx.fillText(Math.round(i * REST_LEN / segments) + '', tx, y + 16);
      }
    }
    // Label
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.fillText(label, x + totalPx / 2, y - 12);
  }

  // --- Dimension bracket ---
  function drawBracket(ctx, x1, x2, y, label, color) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 1.5;
    const bh = 6;
    ctx.beginPath();
    ctx.moveTo(x1, y - bh); ctx.lineTo(x1, y); ctx.lineTo(x2, y); ctx.lineTo(x2, y - bh);
    ctx.stroke();
    // Arrow heads
    ctx.beginPath();
    ctx.moveTo(x1 + 5, y - 2); ctx.lineTo(x1, y); ctx.lineTo(x1 + 5, y + 2);
    ctx.moveTo(x2 - 5, y - 2); ctx.lineTo(x2, y); ctx.lineTo(x2 - 5, y + 2);
    ctx.stroke();
    ctx.fillStyle = color;
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(label, (x1 + x2) / 2, y + 15);
  }

  // --- Grid ---
  function drawGrid(ctx, x, y, gw, gh, cellSize) {
    ctx.strokeStyle = 'rgba(30,41,59,0.5)';
    ctx.lineWidth = 0.5;
    for (let gx = 0; gx <= gw; gx += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x + gx, y);
      ctx.lineTo(x + gx, y + gh);
      ctx.stroke();
    }
    for (let gy = 0; gy <= gh; gy += cellSize) {
      ctx.beginPath();
      ctx.moveTo(x, y + gy);
      ctx.lineTo(x + gw, y + gy);
      ctx.stroke();
    }
  }

  // --- Main animation ---
  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;

    const g = beta > 0.001 ? gamma(Math.min(beta, 0.999)) : 1;
    const contractedPx = SHIP_PX_REST / g;
    const contractedM = REST_LEN / g;

    ctx.clearRect(0, 0, w, h);

    const cx = w / 2;

    // ===== TOP: Rest frame =====
    const topCenterY = topY + viewH / 2;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, topY, w, viewH);

    // Grid
    drawGrid(ctx, cx - SHIP_PX_REST / 2 - 40, topY + 10, SHIP_PX_REST + 80, viewH - 20, 28);

    // Section label
    ctx.fillStyle = 'rgba(148,163,184,0.3)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('REST FRAME (v = 0)', 14, topY + 22);

    // Rest ship
    drawShip(ctx, cx, topCenterY, SHIP_PX_REST, 50, '#3b82f6', null, false);

    // Ruler above
    drawRuler(ctx, cx - SHIP_PX_REST / 2, topY + 24, SHIP_PX_REST, 'Rest length (m)', 10);

    // Bracket below
    drawBracket(ctx, cx - SHIP_PX_REST / 2, cx + SHIP_PX_REST / 2, topCenterY + 46,
      'L₀ = ' + REST_LEN.toFixed(0) + ' m', '#3b82f6');

    // ===== DIVIDER =====
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, midY);
    ctx.lineTo(w - 20, midY);
    ctx.stroke();
    ctx.fillStyle = '#475569';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('— as seen by stationary observer —', cx, midY + 4);

    // ===== BOTTOM: Observer's frame =====
    const botCenterY = botY + viewH / 2;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, botY + 8, w, viewH);

    // Grid (same spacing as top — shows contraction against fixed reference)
    drawGrid(ctx, cx - SHIP_PX_REST / 2 - 40, botY + 18, SHIP_PX_REST + 80, viewH - 20, 28);

    // Section label
    ctx.fillStyle = 'rgba(148,163,184,0.3)';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('OBSERVER FRAME (v = ' + beta.toFixed(2) + 'c)', 14, botY + 30);

    // Ghost rest-length outline (faded)
    if (beta > 0.01) {
      drawShip(ctx, cx, botCenterY, SHIP_PX_REST, 50, '#3b82f6', null, true);
    }

    // Contracted ship
    const shipH = 50;
    drawShip(ctx, cx, botCenterY, contractedPx, shipH, '#06b6d4', null, false);

    // Ruler (same total width as rest ruler for comparison)
    drawRuler(ctx, cx - SHIP_PX_REST / 2, botY + 32, SHIP_PX_REST, 'Observer\'s ruler (m)', 10);

    // Bracket below contracted ship
    drawBracket(ctx, cx - contractedPx / 2, cx + contractedPx / 2, botCenterY + 46,
      'L = ' + contractedM.toFixed(1) + ' m (' + (100 / g).toFixed(1) + '%)', '#06b6d4');

    // Contraction arrows (showing squeeze)
    if (beta > 0.05) {
      const restHalf = SHIP_PX_REST / 2;
      const conHalf = contractedPx / 2;
      ctx.strokeStyle = 'rgba(239,68,68,0.5)';
      ctx.lineWidth = 1.5;
      ctx.setLineDash([3, 3]);
      // Left
      ctx.beginPath();
      ctx.moveTo(cx - restHalf, botCenterY - shipH * 0.8);
      ctx.lineTo(cx - conHalf, botCenterY - shipH * 0.3);
      ctx.stroke();
      // Right
      ctx.beginPath();
      ctx.moveTo(cx + restHalf, botCenterY - shipH * 0.8);
      ctx.lineTo(cx + conHalf, botCenterY - shipH * 0.3);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // ===== FLY-BY ANIMATION =====
    if (flybyActive) {
      flybyShips.forEach(ship => {
        ship.x += ship.speed * dt;
      });
      // Remove off-screen ships
      flybyShips = flybyShips.filter(s => s.x < w + 200);

      // Draw fly-by ships in a strip between sections
      flybyShips.forEach(ship => {
        const sg = ship.beta > 0.001 ? gamma(Math.min(ship.beta, 0.999)) : 1;
        const sLen = 120 / sg;
        const sH = 22;
        const sy = midY;

        // Motion blur trail
        const trailLen = ship.beta * 80;
        const tGrad = ctx.createLinearGradient(ship.x - sLen / 2 - trailLen, sy, ship.x - sLen / 2, sy);
        tGrad.addColorStop(0, 'transparent');
        tGrad.addColorStop(1, ship.color + '44');
        ctx.fillStyle = tGrad;
        ctx.fillRect(ship.x - sLen / 2 - trailLen, sy - sH, trailLen, sH * 2);

        drawShip(ctx, ship.x, sy, sLen, sH, ship.color, null, false);

        // Velocity label
        ctx.fillStyle = '#e2e8f0';
        ctx.font = '9px Courier New';
        ctx.textAlign = 'center';
        ctx.fillText(ship.beta.toFixed(2) + 'c', ship.x, sy - sH - 6);
      });

      // Spawn new ships periodically
      if (flybyShips.length === 0 || (flybyShips.length < 4 && flybyShips[flybyShips.length - 1].x > 80)) {
        const speeds = [0.1, 0.5, 0.8, 0.95];
        const colors = ['#22c55e', '#3b82f6', '#a855f7', '#ef4444'];
        if (flybyShips.length < speeds.length) {
          const idx = flybyShips.length;
          flybyShips.push({
            x: -180,
            beta: speeds[idx],
            speed: (0.15 + speeds[idx] * 0.35),
            color: colors[idx]
          });
        }
      }
    }

    // Formula overlay
    ctx.fillStyle = 'rgba(17,24,39,0.7)';
    ctx.beginPath();
    ctx.roundRect(w - 200, h - 40, 190, 30, 6);
    ctx.fill();
    ctx.fillStyle = '#a855f7';
    ctx.font = 'italic 14px Georgia';
    ctx.textAlign = 'center';
    ctx.fillText('L = L₀ / γ = L₀ √(1 − v²/c²)', w - 105, h - 20);

    requestAnimationFrame(draw);
  }

  // --- Slider ---
  slider.addEventListener('input', () => {
    beta = slider.value / 1000;
    const g = beta > 0.001 ? gamma(Math.min(beta, 0.999)) : 1;
    const contractedM = REST_LEN / g;
    document.getElementById('lc-vel-label').textContent = beta.toFixed(2) + 'c';
    document.getElementById('lc-rest').textContent = REST_LEN.toFixed(1) + ' m';
    document.getElementById('lc-obs').textContent = contractedM.toFixed(1) + ' m';
    document.getElementById('lc-pct').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('lc-gamma').textContent = fmt(g);
  });

  // --- Fly-by controls ---
  flybyBtn.addEventListener('click', () => {
    flybyActive = !flybyActive;
    flybyBtn.textContent = flybyActive ? 'Stop Fly-By' : 'Launch Fly-By';
    if (flybyActive) flybyShips = [];
  });
  flybyResetBtn.addEventListener('click', () => {
    flybyActive = false;
    flybyShips = [];
    flybyBtn.textContent = 'Launch Fly-By';
  });

  requestAnimationFrame(draw);
})();

// ==================== ENERGY GRAPHS ====================
(function initEnergy() {
  const keC = setupCanvas('ke-graph');
  const totC = setupCanvas('total-graph');
  const momC = setupCanvas('momentum-graph');
  const slider = document.getElementById('energy-vel');
  let currentBeta = 0;

  function drawGraph(setup, fn, label, color, maxY, yLabel) {
    const { ctx, w, h } = setup;
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 70, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);
    ctx.save();
    ctx.translate(14, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText(yLabel, 0, 0);
    ctx.restore();

    // Grid
    for (let i = 0; i <= 4; i++) {
      const val = (maxY / 4) * i;
      const y = pad.t + gh - (i / 4) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(fmt(val, 1), pad.l - 8, y + 4);
    }

    // Classical comparison (dashed)
    ctx.beginPath();
    ctx.strokeStyle = 'rgba(100,116,139,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 1.5;
    for (let i = 0; i <= 400; i++) {
      const b = (i / 400) * 0.999;
      let classicalVal;
      if (label === 'KE') classicalVal = 0.5 * b * b;
      else if (label === 'Total') classicalVal = 1 + 0.5 * b * b;
      else classicalVal = b;
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(classicalVal, maxY) / maxY) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();
    ctx.setLineDash([]);

    // Relativistic curve
    ctx.beginPath();
    ctx.strokeStyle = color;
    ctx.lineWidth = 2.5;
    for (let i = 0; i <= 500; i++) {
      const b = (i / 500) * 0.999;
      const val = fn(b);
      const x = pad.l + b * gw;
      const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;
      i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Legend
    ctx.fillStyle = color;
    ctx.fillRect(pad.l + 10, pad.t + 8, 20, 3);
    ctx.fillStyle = '#e2e8f0';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Relativistic', pad.l + 36, pad.t + 13);
    ctx.fillStyle = '#64748b';
    ctx.fillRect(pad.l + 10, pad.t + 24, 20, 3);
    ctx.fillText('Classical (Newtonian)', pad.l + 36, pad.t + 29);

    // Current point
    if (currentBeta > 0.001) {
      const val = fn(Math.min(currentBeta, 0.9999));
      const x = pad.l + currentBeta * gw;
      const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;

      ctx.setLineDash([3, 3]);
      ctx.strokeStyle = 'rgba(6,182,212,0.4)';
      ctx.beginPath();
      ctx.moveTo(x, pad.t + gh);
      ctx.lineTo(x, y);
      ctx.stroke();
      ctx.setLineDash([]);

      ctx.beginPath();
      ctx.arc(x, y, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#06b6d4';
      ctx.fill();
    }
  }

  function update() {
    const keFunc = (b) => gamma(b) - 1;
    const totFunc = (b) => gamma(b);
    const momFunc = (b) => gamma(b) * b;

    drawGraph(keC, keFunc, 'KE', '#f59e0b', 20, 'KE / mc²');
    drawGraph(totC, totFunc, 'Total', '#ef4444', 20, 'E / mc²');
    drawGraph(momC, momFunc, 'p', '#a855f7', 20, 'p / mc');
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 1000;
    const g = currentBeta > 0.001 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    const ke = g - 1;
    const mom = g * currentBeta;
    document.getElementById('energy-vel-label').textContent = currentBeta.toFixed(3) + 'c';
    document.getElementById('e-rest').textContent = '1.00 mc²';
    document.getElementById('e-ke').textContent = fmt(ke) + ' mc²';
    document.getElementById('e-total').textContent = fmt(g) + ' mc²';
    document.getElementById('e-mom').textContent = fmt(mom) + ' mc';
    update();
  });

  // Tabs
  document.querySelectorAll('#sec-energy .tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('#sec-energy .tab-btn').forEach(b => b.classList.remove('active'));
      document.querySelectorAll('#sec-energy .tab-content').forEach(c => c.classList.remove('active'));
      btn.classList.add('active');
      document.getElementById(btn.dataset.tab).classList.add('active');
      update();
    });
  });

  update();
})();

// ==================== MUON SIMULATION ====================
(function initMuon() {
  const { ctx, w, h } = setupCanvas('muon-canvas');
  const startBtn = document.getElementById('muon-start');
  const resetBtn = document.getElementById('muon-reset');
  let running = false;
  let altitude = 15000; // meters
  const totalAlt = 15000;
  const muonHalfLife = 1.56e-6; // seconds (half-life)
  const muonSpeed = 0.998; // fraction of c
  const gMuon = gamma(muonSpeed);
  let classicalSurvival = 1;
  let relativisticSurvival = 1;
  let animId = null;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 60, t: 20, b: 40 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Background gradient (sky to ground)
    const skyGrad = ctx.createLinearGradient(0, pad.t, 0, pad.t + gh);
    skyGrad.addColorStop(0, '#0c1445');
    skyGrad.addColorStop(0.85, '#1a2744');
    skyGrad.addColorStop(1, '#2d4a2d');
    ctx.fillStyle = skyGrad;
    ctx.fillRect(pad.l, pad.t, gw, gh);

    // Altitude marks
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'right';
    for (let a = 0; a <= 15; a += 3) {
      const y = pad.t + gh - (a / 15) * gh;
      ctx.fillText(a + ' km', pad.l - 8, y + 4);
      ctx.strokeStyle = 'rgba(100,116,139,0.2)';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
    }

    // Ground
    ctx.fillStyle = '#3d5a3d';
    ctx.fillRect(pad.l, pad.t + gh - 2, gw, 4);
    ctx.fillStyle = '#64748b';
    ctx.textAlign = 'center';
    ctx.fillText('Sea Level', pad.l + gw / 2, pad.t + gh + 16);

    // Muon positions
    const progress = 1 - altitude / totalAlt;
    const currentY = pad.t + progress * gh;

    // Classical decay line (660m ~ 4.4% of 15km)
    const classicalRange = 660;
    const classicalY = pad.t + (classicalRange / totalAlt) * gh;
    ctx.strokeStyle = 'rgba(245,158,11,0.5)';
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t + gh - classicalY + pad.t);
    ctx.lineTo(pad.l + gw, pad.t + gh - classicalY + pad.t);
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = '#f59e0b';
    ctx.textAlign = 'left';
    ctx.fillText('Classical decay range (~660m)', pad.l + gw + 6, pad.t + gh - classicalY + pad.t + 4);

    // Draw muon particles - Classical (left half)
    const numMuons = 30;
    const leftX = pad.l + gw * 0.25;
    const rightX = pad.l + gw * 0.75;

    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 11px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Classical', leftX, pad.t + gh + 30);
    ctx.fillStyle = '#06b6d4';
    ctx.fillText('Relativistic', rightX, pad.t + gh + 30);

    for (let i = 0; i < numMuons; i++) {
      const angle = (i / numMuons) * Math.PI * 2;
      const spread = 40;

      // Classical
      const cx = leftX + Math.cos(angle + i) * spread * (i % 3 + 1) / 3;
      const cy = currentY + Math.sin(angle) * 8;
      const classAlpha = classicalSurvival > (i / numMuons) ? 0.8 : 0.08;
      ctx.beginPath();
      ctx.arc(cx, cy, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(245,158,11,${classAlpha})`;
      ctx.fill();

      // Relativistic
      const rx = rightX + Math.cos(angle + i) * spread * (i % 3 + 1) / 3;
      const ry = currentY + Math.sin(angle) * 8;
      const relAlpha = relativisticSurvival > (i / numMuons) ? 0.8 : 0.08;
      ctx.beginPath();
      ctx.arc(rx, ry, 3, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(6,182,212,${relAlpha})`;
      ctx.fill();
    }
  }

  function step() {
    if (!running) return;
    const speed = muonSpeed * c; // m/s
    const dt = 0.016; // 16ms frame
    const simSpeed = 500; // speed up simulation
    const distStep = speed * dt * simSpeed / c * 150;

    altitude -= distStep;
    if (altitude < 0) altitude = 0;

    const distTraveled = totalAlt - altitude;
    const timeClassical = distTraveled / (muonSpeed * c);
    const timeRelativistic = timeClassical / gMuon;

    classicalSurvival = Math.pow(0.5, timeClassical / muonHalfLife);
    relativisticSurvival = Math.pow(0.5, timeRelativistic / muonHalfLife);

    document.getElementById('muon-classical').textContent = (classicalSurvival * 100).toFixed(1) + '%';
    document.getElementById('muon-relativistic').textContent = (relativisticSurvival * 100).toFixed(1) + '%';
    document.getElementById('muon-alt').textContent = (altitude / 1000).toFixed(1) + ' km';

    draw();

    if (altitude > 0) {
      animId = requestAnimationFrame(step);
    } else {
      running = false;
      startBtn.textContent = 'Start Simulation';
    }
  }

  startBtn.addEventListener('click', () => {
    if (running) {
      running = false;
      startBtn.textContent = 'Resume';
    } else {
      running = true;
      startBtn.textContent = 'Pause';
      step();
    }
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    if (animId) cancelAnimationFrame(animId);
    altitude = totalAlt;
    classicalSurvival = 1;
    relativisticSurvival = 1;
    startBtn.textContent = 'Start Simulation';
    document.getElementById('muon-classical').textContent = '100%';
    document.getElementById('muon-relativistic').textContent = '100%';
    document.getElementById('muon-alt').textContent = '15.0 km';
    draw();
  });

  draw();
})();

// ==================== E=mc² SECTION ====================
(function initEmc2() {
  const { ctx, w, h } = setupCanvas('emc2-graph');
  const slider = document.getElementById('mass-slider');

  function draw(mass) {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 70, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Bar chart comparison
    const items = [
      { label: `${mass} kg at rest\n(E=mc²)`, energy: mass * c * c, color: '#06b6d4' },
      { label: 'Hiroshima\n(~6.3×10¹³ J)', energy: 6.3e13, color: '#f59e0b' },
      { label: 'US daily energy\n(~2.7×10¹⁶ J)', energy: 2.7e16, color: '#a855f7' },
      { label: `${mass} kg at 0.9c\n(γmc²)`, energy: gamma(0.9) * mass * c * c, color: '#ef4444' },
    ];

    const maxE = Math.max(...items.map(i => i.energy));
    const barW = gw / items.length - 20;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.save();
    ctx.translate(14, pad.t + gh / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Energy (log scale)', 0, 0);
    ctx.restore();

    // Use log scale
    const logMax = Math.log10(maxE);
    const logMin = 10;

    items.forEach((item, i) => {
      const x = pad.l + (i + 0.5) * (gw / items.length) - barW / 2;
      const logE = Math.log10(Math.max(item.energy, 1));
      const barH = ((logE - logMin) / (logMax - logMin + 2)) * gh;

      // Bar
      const grad = ctx.createLinearGradient(x, pad.t + gh - barH, x, pad.t + gh);
      grad.addColorStop(0, item.color);
      grad.addColorStop(1, item.color + '44');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.roundRect(x, pad.t + gh - barH, barW, barH, [4, 4, 0, 0]);
      ctx.fill();

      // Value on bar
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 11px Courier New';
      ctx.textAlign = 'center';
      const eStr = item.energy.toExponential(1);
      ctx.fillText(eStr + ' J', x + barW / 2, pad.t + gh - barH - 8);

      // Label below
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px system-ui';
      const lines = item.label.split('\n');
      lines.forEach((line, li) => {
        ctx.fillText(line, x + barW / 2, pad.t + gh + 14 + li * 13);
      });
    });
  }

  slider.addEventListener('input', () => {
    const mass = parseFloat(slider.value);
    document.getElementById('mass-label').textContent = mass.toFixed(0) + ' kg';

    const energy = mass * c * c;
    const tntMegatons = energy / 4.184e15;
    const cityYears = energy / (1e9 * 3.15e7);

    document.getElementById('emc2-rest').innerHTML = (energy / 1e16).toFixed(1) + ' &times; 10&sup1;&sup6; J';
    document.getElementById('emc2-tnt').textContent = tntMegatons.toFixed(1) + ' MT';
    document.getElementById('emc2-power').textContent = `A city for ${cityYears.toFixed(1)} years`;
    draw(mass);
  });

  draw(1);
})();

// ==================== TWIN PARADOX ====================
(function initTwins() {
  const { ctx, w, h } = setupCanvas('twin-canvas');
  const velSlider = document.getElementById('twin-vel');
  const distSlider = document.getElementById('twin-dist');
  const playBtn = document.getElementById('twin-play');
  const resetBtn = document.getElementById('twin-reset');
  const speedBtn = document.getElementById('twin-speed');

  let beta = 0.5;
  let distLY = 5.0; // light-years one way
  let running = false;
  let finished = false;
  let simTime = 0; // Earth elapsed time in years
  let simSpeed = 1; // multiplier
  let prevTs = null;
  let animId = null;

  // Derived quantities
  function getTripStats() {
    const g = gamma(beta);
    const tOneWayEarth = distLY / beta;      // years (Earth frame)
    const tTotalEarth = 2 * tOneWayEarth;     // round trip, Earth
    const tTotalTraveler = tTotalEarth / g;    // round trip, traveler
    return { g, tOneWayEarth, tTotalEarth, tTotalTraveler };
  }

  function getPhase(earthTime) {
    const { tOneWayEarth, tTotalEarth } = getTripStats();
    if (earthTime <= 0) return { phase: 'ready', frac: 0, leg: 0 };
    if (earthTime >= tTotalEarth) return { phase: 'reunited', frac: 1, leg: 2 };
    if (earthTime < tOneWayEarth) return { phase: 'outbound', frac: earthTime / tOneWayEarth, leg: 0 };
    if (earthTime < tOneWayEarth * 1.0001) return { phase: 'turnaround', frac: 0.5, leg: 1 };
    return { phase: 'return', frac: (earthTime - tOneWayEarth) / tOneWayEarth, leg: 2 };
  }

  // ---- Drawing helpers ----
  function drawStar(ctx, x, y, r, spikes, color) {
    ctx.beginPath();
    for (let i = 0; i < spikes * 2; i++) {
      const angle = (i * Math.PI) / spikes - Math.PI / 2;
      const rad = i % 2 === 0 ? r : r * 0.4;
      const px = x + Math.cos(angle) * rad;
      const py = y + Math.sin(angle) * rad;
      i === 0 ? ctx.moveTo(px, py) : ctx.lineTo(px, py);
    }
    ctx.closePath();
    ctx.fillStyle = color;
    ctx.fill();
  }

  function drawPerson(ctx, x, y, scale, faceColor, bodyColor, age) {
    const s = scale;
    // Body
    ctx.fillStyle = bodyColor;
    ctx.beginPath();
    ctx.roundRect(x - 8 * s, y - 2 * s, 16 * s, 22 * s, 4 * s);
    ctx.fill();
    // Head
    ctx.fillStyle = faceColor;
    ctx.beginPath();
    ctx.arc(x, y - 12 * s, 10 * s, 0, Math.PI * 2);
    ctx.fill();
    // Eyes
    ctx.fillStyle = '#1e293b';
    ctx.beginPath();
    ctx.arc(x - 3.5 * s, y - 14 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.arc(x + 3.5 * s, y - 14 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.fill();
    // Mouth
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.arc(x, y - 9 * s, 3 * s, 0.1, Math.PI - 0.1);
    ctx.stroke();
    // Hair (grays with age)
    const grayAmount = Math.min(1, Math.max(0, (age - 40) / 40));
    const hairR = Math.round(lerp(60, 180, grayAmount));
    const hairG = Math.round(lerp(40, 180, grayAmount));
    const hairB = Math.round(lerp(30, 180, grayAmount));
    ctx.fillStyle = `rgb(${hairR},${hairG},${hairB})`;
    ctx.beginPath();
    ctx.ellipse(x, y - 20 * s, 10 * s, 5 * s, 0, Math.PI, 0);
    ctx.fill();
    // Age label
    ctx.fillStyle = '#e2e8f0';
    ctx.font = `bold ${11 * s}px system-ui`;
    ctx.textAlign = 'center';
    ctx.fillText(age.toFixed(1) + ' yr', x, y + 30 * s);
  }

  function drawRocket(ctx, x, y, scale, angle, flameOn) {
    ctx.save();
    ctx.translate(x, y);
    ctx.rotate(angle);
    const s = scale;
    // Flame
    if (flameOn) {
      const flicker = 0.7 + Math.random() * 0.3;
      const fGrad = ctx.createLinearGradient(0, 12 * s, 0, 12 * s + 18 * s * flicker);
      fGrad.addColorStop(0, '#f59e0b');
      fGrad.addColorStop(0.4, '#ef4444');
      fGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = fGrad;
      ctx.beginPath();
      ctx.moveTo(-5 * s, 12 * s);
      ctx.lineTo(5 * s, 12 * s);
      ctx.lineTo(1 * s, 12 * s + 16 * s * flicker);
      ctx.lineTo(-1 * s, 12 * s + 16 * s * flicker);
      ctx.closePath();
      ctx.fill();
    }
    // Body
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath();
    ctx.moveTo(0, -14 * s);
    ctx.lineTo(-6 * s, 6 * s);
    ctx.lineTo(-8 * s, 12 * s);
    ctx.lineTo(8 * s, 12 * s);
    ctx.lineTo(6 * s, 6 * s);
    ctx.closePath();
    ctx.fill();
    // Nose cone
    const nGrad = ctx.createLinearGradient(0, -14 * s, 0, -4 * s);
    nGrad.addColorStop(0, '#ef4444');
    nGrad.addColorStop(1, '#b91c1c');
    ctx.fillStyle = nGrad;
    ctx.beginPath();
    ctx.moveTo(0, -14 * s);
    ctx.lineTo(-4 * s, -4 * s);
    ctx.lineTo(4 * s, -4 * s);
    ctx.closePath();
    ctx.fill();
    // Window
    ctx.fillStyle = '#06b6d4';
    ctx.beginPath();
    ctx.arc(0, -1 * s, 3 * s, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = 'rgba(255,255,255,0.3)';
    ctx.beginPath();
    ctx.arc(-1 * s, -2 * s, 1.5 * s, 0, Math.PI * 2);
    ctx.fill();
    // Fins
    ctx.fillStyle = '#64748b';
    ctx.beginPath();
    ctx.moveTo(-6 * s, 6 * s);
    ctx.lineTo(-12 * s, 14 * s);
    ctx.lineTo(-8 * s, 12 * s);
    ctx.closePath();
    ctx.fill();
    ctx.beginPath();
    ctx.moveTo(6 * s, 6 * s);
    ctx.lineTo(12 * s, 14 * s);
    ctx.lineTo(8 * s, 12 * s);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  function draw(ts) {
    if (prevTs === null) prevTs = ts;
    const dt = Math.min(ts - prevTs, 50);
    prevTs = ts;

    const { g, tOneWayEarth, tTotalEarth, tTotalTraveler } = getTripStats();

    if (running && !finished) {
      const realSecsForTrip = Math.max(6, Math.min(20, tTotalEarth * 2));
      const yearsPerMs = tTotalEarth / (realSecsForTrip * 1000) * simSpeed;
      simTime += dt * yearsPerMs;
      if (simTime >= tTotalEarth) {
        simTime = tTotalEarth;
        finished = true;
        running = false;
        playBtn.textContent = 'Trip Complete';
      }
    }

    const { phase, frac, leg } = getPhase(simTime);

    // Traveler proper time
    let travelerTime = 0;
    if (simTime <= tOneWayEarth) {
      travelerTime = simTime / g;
    } else {
      travelerTime = tOneWayEarth / g + (simTime - tOneWayEarth) / g;
    }
    if (simTime >= tTotalEarth) travelerTime = tTotalTraveler;

    const earthAge = 30 + simTime;
    const travAge = 30 + travelerTime;

    // Update readouts
    document.getElementById('tw-earth-age').textContent = earthAge.toFixed(1) + ' yr';
    document.getElementById('tw-trav-age').textContent = travAge.toFixed(1) + ' yr';
    document.getElementById('tw-earth-time').textContent = simTime.toFixed(1) + ' yr';
    document.getElementById('tw-trav-time').textContent = travelerTime.toFixed(1) + ' yr';
    document.getElementById('tw-diff').textContent = (simTime - travelerTime).toFixed(1) + ' yr';
    const phaseNames = { ready: 'Ready', outbound: 'Outbound →', turnaround: 'Turnaround ↩', return: '← Return', reunited: 'Reunited!' };
    document.getElementById('tw-phase').textContent = phaseNames[phase] || phase;

    // ---- Canvas drawing ----
    ctx.clearRect(0, 0, w, h);

    // STACKED LAYOUT: top = trip animation, bottom = full-width spacetime diagram
    const tripH = h * 0.34;
    const dividerY = tripH;
    const stTop = tripH + 16;

    // ========= TOP: Trip Animation (full width) =========
    const earthX = 100;
    const starX = w - 100;
    const groundY = tripH * 0.62;

    // Background: space gradient
    const spGrad = ctx.createLinearGradient(0, 0, 0, tripH);
    spGrad.addColorStop(0, '#05081a');
    spGrad.addColorStop(0.7, '#0a1030');
    spGrad.addColorStop(1, '#0c1225');
    ctx.fillStyle = spGrad;
    ctx.fillRect(0, 0, w, tripH);

    // Decorative stars
    const starSeed = [0.05,0.12,0.22,0.35,0.43,0.58,0.67,0.78,0.88,0.95,0.15,0.31,0.52,0.71,0.84];
    for (let i = 0; i < starSeed.length; i++) {
      const sx = starSeed[i] * w;
      const sy = starSeed[(i+5)%starSeed.length] * groundY * 0.6 + 8;
      const sr = 0.5 + starSeed[(i+3)%starSeed.length] * 1.3;
      ctx.beginPath();
      ctx.arc(sx, sy, sr, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(200,210,255,${0.15 + starSeed[(i+7)%starSeed.length] * 0.3})`;
      ctx.fill();
    }

    // Earth
    const earthR = 28;
    ctx.beginPath();
    ctx.arc(earthX, groundY, earthR, 0, Math.PI * 2);
    const eGrad = ctx.createRadialGradient(earthX - 6, groundY - 6, 3, earthX, groundY, earthR);
    eGrad.addColorStop(0, '#3b82f6');
    eGrad.addColorStop(0.5, '#2563eb');
    eGrad.addColorStop(1, '#1e3a5f');
    ctx.fillStyle = eGrad;
    ctx.fill();
    ctx.fillStyle = 'rgba(34,197,94,0.4)';
    ctx.beginPath();
    ctx.ellipse(earthX - 5, groundY - 4, 7, 10, -0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.beginPath();
    ctx.ellipse(earthX + 9, groundY + 5, 6, 5, 0.5, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Earth', earthX, groundY + earthR + 16);

    // Destination star
    drawStar(ctx, starX, groundY - 4, 20, 5, '#fbbf24');
    const sgGrad = ctx.createRadialGradient(starX, groundY - 4, 5, starX, groundY - 4, 36);
    sgGrad.addColorStop(0, 'rgba(251,191,36,0.3)');
    sgGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sgGrad;
    ctx.fillRect(starX - 40, groundY - 44, 80, 80);
    ctx.fillStyle = '#f59e0b';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(distLY.toFixed(1) + ' ly', starX, groundY + earthR + 16);

    // Distance line
    ctx.strokeStyle = 'rgba(100,116,139,0.3)';
    ctx.setLineDash([5, 8]);
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(earthX + earthR + 6, groundY);
    ctx.lineTo(starX - 24, groundY);
    ctx.stroke();
    ctx.setLineDash([]);

    // Rocket position
    let rocketX, rocketY, rocketAngle, flameOn = false;
    const rocketScale = 1.5;
    if (phase === 'ready') {
      rocketX = earthX + earthR + 30;
      rocketY = groundY;
      rocketAngle = Math.PI / 2;
    } else if (phase === 'outbound') {
      rocketX = lerp(earthX + earthR + 30, starX - 35, frac);
      rocketY = groundY - Math.sin(frac * Math.PI) * 40;
      rocketAngle = Math.PI / 2;
      flameOn = true;
    } else if (phase === 'turnaround') {
      rocketX = starX - 35;
      rocketY = groundY - 40;
      rocketAngle = Math.PI / 2;
      flameOn = true;
    } else if (phase === 'return') {
      rocketX = lerp(starX - 35, earthX + earthR + 30, frac);
      rocketY = groundY - Math.sin(frac * Math.PI) * 40;
      rocketAngle = -Math.PI / 2;
      flameOn = true;
    } else {
      rocketX = earthX + earthR + 30;
      rocketY = groundY;
      rocketAngle = Math.PI / 2;
    }

    drawRocket(ctx, rocketX, rocketY, rocketScale, rocketAngle, flameOn);

    // Twin figures at bottom of trip area
    const twinBaseY = tripH - 8;
    const twinEarthX = earthX + 60;
    const twinTravX = earthX + 120;

    drawPerson(ctx, twinEarthX, twinBaseY - 40, 1.15, '#fcd6a8', '#3b82f6', earthAge);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Earth Twin', twinEarthX, twinBaseY + 2);

    if (phase === 'ready' || phase === 'reunited') {
      // Traveler standing next to Earth twin
      drawPerson(ctx, twinTravX, twinBaseY - 40, 1.15, '#fcd6a8', '#a855f7', travAge);
      ctx.fillStyle = '#94a3b8';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Traveler', twinTravX, twinBaseY + 2);
    } else {
      // Traveler riding above the rocket during flight
      const travRocketY = rocketY - 34 * rocketScale;
      drawPerson(ctx, rocketX, travRocketY, 0.75, '#fcd6a8', '#a855f7', travAge);
      ctx.fillStyle = '#a855f7';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Traveler', rocketX, travRocketY - 26);
    }

    // Age difference highlight on reunion
    if (phase === 'reunited') {
      const diff = (simTime - travelerTime).toFixed(1);
      ctx.fillStyle = 'rgba(239,68,68,0.15)';
      ctx.beginPath();
      ctx.roundRect(twinEarthX - 10, twinBaseY - 86, twinTravX - twinEarthX + 20, 22, 6);
      ctx.fill();
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 13px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Δ ' + diff + ' years younger!', (twinEarthX + twinTravX) / 2, twinBaseY - 70);
    }

    // ========= DIVIDER =========
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(20, dividerY + 6);
    ctx.lineTo(w - 20, dividerY + 6);
    ctx.stroke();

    // ========= BOTTOM: Full-width Spacetime Diagram =========
    const stPad = { l: 70, r: 40, t: 14, b: 40 };
    const stW = w - stPad.l - stPad.r;
    const stH = h - stTop - stPad.t - stPad.b;
    const stOx = stPad.l;
    const stOy = stTop + stPad.t + stH;

    // Background
    ctx.fillStyle = '#060a14';
    ctx.fillRect(0, stTop, w, h - stTop);

    // Title
    ctx.fillStyle = '#64748b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('SPACETIME DIAGRAM', stPad.l, stTop + 10);

    // Axes
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx, stTop + stPad.t);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx + stW, stOy);
    ctx.stroke();

    // Arrow on time axis
    ctx.fillStyle = '#475569';
    ctx.beginPath();
    ctx.moveTo(stOx, stTop + stPad.t);
    ctx.lineTo(stOx - 5, stTop + stPad.t + 12);
    ctx.lineTo(stOx + 5, stTop + stPad.t + 12);
    ctx.closePath();
    ctx.fill();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '13px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('x  (light-years)', stOx + stW / 2, stOy + 32);
    ctx.save();
    ctx.translate(stOx - 50, stTop + stPad.t + stH / 2);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('t  (years)', 0, 0);
    ctx.restore();

    // Scale: map distLY -> 60% of stW, tTotalEarth -> 85% of stH
    const xScale = (stW * 0.6) / Math.max(distLY, 0.1);
    const tScale = (stH * 0.85) / Math.max(tTotalEarth, 0.1);

    // Grid
    ctx.strokeStyle = 'rgba(30,41,59,0.4)';
    ctx.lineWidth = 0.5;
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    const tStep = Math.max(1, Math.ceil(tTotalEarth / 10));
    for (let t = tStep; t <= tTotalEarth * 1.1; t += tStep) {
      const y = stOy - t * tScale;
      if (y < stTop + stPad.t) break;
      ctx.beginPath();
      ctx.moveTo(stOx, y);
      ctx.lineTo(stOx + stW, y);
      ctx.stroke();
      ctx.textAlign = 'right';
      ctx.fillText(t.toFixed(0), stOx - 8, y + 4);
    }
    const xStep = Math.max(1, Math.ceil(distLY / 6));
    for (let x = xStep; x <= distLY * 1.15; x += xStep) {
      const px = stOx + x * xScale;
      if (px > stOx + stW) break;
      ctx.beginPath();
      ctx.moveTo(px, stOy);
      ctx.lineTo(px, stTop + stPad.t);
      ctx.stroke();
      ctx.textAlign = 'center';
      ctx.fillText(x.toFixed(0), px, stOy + 16);
    }

    // Light cone from origin
    ctx.strokeStyle = 'rgba(245,158,11,0.3)';
    ctx.setLineDash([5, 5]);
    ctx.lineWidth = 1.5;
    const lcLen = Math.min(stW, stH);
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx + lcLen, stOy - lcLen);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx - Math.min(stPad.l - 14, lcLen), stOy - Math.min(stPad.l - 14, lcLen));
    ctx.stroke();
    ctx.setLineDash([]);
    ctx.fillStyle = 'rgba(245,158,11,0.4)';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('light (c)', stOx + lcLen * 0.35 + 6, stOy - lcLen * 0.35 - 6);

    // Earth worldline (vertical, stationary)
    ctx.strokeStyle = 'rgba(245,158,11,0.6)';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(stOx, stOy - tTotalEarth * tScale);
    ctx.stroke();
    ctx.fillStyle = '#f59e0b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'right';
    ctx.fillText('Earth twin', stOx - 10, stOy - tTotalEarth * tScale + 16);

    // Traveler worldline (kinked V shape)
    const midX = stOx + distLY * xScale;
    const midY = stOy - tOneWayEarth * tScale;
    const endY = stOy - tTotalEarth * tScale;

    // Wide glow
    ctx.strokeStyle = 'rgba(6,182,212,0.1)';
    ctx.lineWidth = 12;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();
    // Narrow glow
    ctx.strokeStyle = 'rgba(6,182,212,0.25)';
    ctx.lineWidth = 5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();
    // Core
    ctx.strokeStyle = '#06b6d4';
    ctx.lineWidth = 2.5;
    ctx.beginPath();
    ctx.moveTo(stOx, stOy);
    ctx.lineTo(midX, midY);
    ctx.lineTo(stOx, endY);
    ctx.stroke();

    // Turnaround kink
    ctx.beginPath();
    ctx.arc(midX, midY, 6, 0, Math.PI * 2);
    ctx.fillStyle = '#a855f7';
    ctx.fill();
    ctx.strokeStyle = '#c084fc';
    ctx.lineWidth = 1.5;
    ctx.stroke();
    ctx.fillStyle = '#a855f7';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('turnaround', midX + 12, midY + 5);

    // Outbound / return labels
    ctx.fillStyle = '#06b6d4';
    ctx.font = '12px system-ui';
    const outLblX = (stOx + midX) / 2 + 10;
    const outLblY = (stOy + midY) / 2;
    ctx.textAlign = 'left';
    ctx.fillText('outbound →', outLblX, outLblY);
    const retLblX = (stOx + midX) / 2 + 10;
    const retLblY = (midY + endY) / 2;
    ctx.fillText('← return', retLblX, retLblY);

    // Animated position dots
    if (simTime > 0 && simTime <= tTotalEarth) {
      let dotX, dotY;
      if (simTime <= tOneWayEarth) {
        const f = simTime / tOneWayEarth;
        dotX = lerp(stOx, midX, f);
        dotY = lerp(stOy, midY, f);
      } else {
        const f = (simTime - tOneWayEarth) / tOneWayEarth;
        dotX = lerp(midX, stOx, f);
        dotY = lerp(midY, endY, f);
      }
      // Traveler dot glow
      const dg = ctx.createRadialGradient(dotX, dotY, 0, dotX, dotY, 16);
      dg.addColorStop(0, 'rgba(6,182,212,0.7)');
      dg.addColorStop(1, 'transparent');
      ctx.fillStyle = dg;
      ctx.fillRect(dotX - 18, dotY - 18, 36, 36);
      ctx.beginPath();
      ctx.arc(dotX, dotY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();

      // Earth dot
      const eDotY = stOy - simTime * tScale;
      const edg = ctx.createRadialGradient(stOx, eDotY, 0, stOx, eDotY, 14);
      edg.addColorStop(0, 'rgba(245,158,11,0.7)');
      edg.addColorStop(1, 'transparent');
      ctx.fillStyle = edg;
      ctx.fillRect(stOx - 16, eDotY - 16, 32, 32);
      ctx.beginPath();
      ctx.arc(stOx, eDotY, 4.5, 0, Math.PI * 2);
      ctx.fillStyle = '#fef3c7';
      ctx.fill();

      // Connecting dashed line
      ctx.strokeStyle = 'rgba(148,163,184,0.3)';
      ctx.setLineDash([4, 5]);
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(stOx, eDotY);
      ctx.lineTo(dotX, dotY);
      ctx.stroke();
      ctx.setLineDash([]);
    }

    // Proper time annotations at endpoints
    if (simTime >= tTotalEarth) {
      // Background pill for Earth
      ctx.fillStyle = 'rgba(245,158,11,0.12)';
      ctx.beginPath();
      ctx.roundRect(stOx - 80, endY - 18, 74, 22, 4);
      ctx.fill();
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'right';
      ctx.fillText('τ = ' + tTotalEarth.toFixed(1) + ' yr', stOx - 10, endY - 2);
      // Background pill for Traveler
      ctx.fillStyle = 'rgba(6,182,212,0.12)';
      ctx.beginPath();
      ctx.roundRect(stOx + 6, endY - 18, 82, 22, 4);
      ctx.fill();
      ctx.fillStyle = '#06b6d4';
      ctx.textAlign = 'left';
      ctx.fillText('τ = ' + tTotalTraveler.toFixed(1) + ' yr', stOx + 10, endY - 2);
    }

    // Departure & arrival dots
    ctx.beginPath();
    ctx.arc(stOx, stOy, 5, 0, Math.PI * 2);
    ctx.fillStyle = '#e2e8f0';
    ctx.fill();
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('departure', stOx + 10, stOy - 2);

    if (simTime >= tTotalEarth) {
      ctx.beginPath();
      ctx.arc(stOx, endY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#e2e8f0';
      ctx.fill();
      ctx.fillStyle = '#94a3b8';
      ctx.textAlign = 'left';
      ctx.fillText('reunion', stOx + 10, endY + 14);
    }

    animId = requestAnimationFrame(draw);
  }

  // ---- Slider events ----
  velSlider.addEventListener('input', () => {
    beta = velSlider.value / 100;
    document.getElementById('twin-vel-label').textContent = beta.toFixed(2) + 'c';
    if (!running && !finished) updatePreview();
  });
  distSlider.addEventListener('input', () => {
    distLY = distSlider.value / 2;
    document.getElementById('twin-dist-label').textContent = distLY.toFixed(1) + ' ly';
    if (!running && !finished) updatePreview();
  });

  function updatePreview() {
    const { tTotalEarth, tTotalTraveler } = getTripStats();
    document.getElementById('tw-earth-time').textContent = tTotalEarth.toFixed(1) + ' yr (total)';
    document.getElementById('tw-trav-time').textContent = tTotalTraveler.toFixed(1) + ' yr (total)';
    document.getElementById('tw-diff').textContent = (tTotalEarth - tTotalTraveler).toFixed(1) + ' yr';
  }

  // ---- Controls ----
  playBtn.addEventListener('click', () => {
    if (finished) return;
    if (running) {
      running = false;
      playBtn.textContent = 'Resume';
    } else {
      running = true;
      playBtn.textContent = 'Pause';
    }
  });

  resetBtn.addEventListener('click', () => {
    running = false;
    finished = false;
    simTime = 0;
    prevTs = null;
    playBtn.textContent = 'Launch Trip';
    document.getElementById('tw-earth-age').textContent = '30.0 yr';
    document.getElementById('tw-trav-age').textContent = '30.0 yr';
    document.getElementById('tw-earth-time').textContent = '0.0 yr';
    document.getElementById('tw-trav-time').textContent = '0.0 yr';
    document.getElementById('tw-diff').textContent = '0.0 yr';
    document.getElementById('tw-phase').textContent = 'Ready';
    updatePreview();
  });

  const speeds = [1, 2, 5, 10];
  let speedIdx = 0;
  speedBtn.addEventListener('click', () => {
    speedIdx = (speedIdx + 1) % speeds.length;
    simSpeed = speeds[speedIdx];
    speedBtn.innerHTML = 'Speed: ' + simSpeed + '&times;';
  });

  // Initialize
  updatePreview();
  requestAnimationFrame(draw);
})();

// ==================== COMBINED GRAPH ====================
(function initCombined() {
  const { ctx, w, h } = setupCanvas('combined-graph');
  const slider = document.getElementById('master-vel');
  let currentBeta = 0;

  function draw() {
    ctx.clearRect(0, 0, w, h);
    const pad = { l: 60, r: 30, t: 30, b: 50 };
    const gw = w - pad.l - pad.r;
    const gh = h - pad.t - pad.b;

    // Axes
    ctx.strokeStyle = '#334155';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(pad.l, pad.t);
    ctx.lineTo(pad.l, pad.t + gh);
    ctx.lineTo(pad.l + gw, pad.t + gh);
    ctx.stroke();

    ctx.fillStyle = '#94a3b8';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('v / c', pad.l + gw / 2, h - 8);

    // Grid
    const maxY = 15;
    for (let i = 0; i <= maxY; i += 5) {
      const y = pad.t + gh - (i / maxY) * gh;
      ctx.strokeStyle = '#1e293b';
      ctx.beginPath();
      ctx.moveTo(pad.l, y);
      ctx.lineTo(pad.l + gw, y);
      ctx.stroke();
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'right';
      ctx.fillText(i.toString(), pad.l - 8, y + 4);
    }
    for (let v = 0; v <= 1; v += 0.2) {
      const x = pad.l + v * gw;
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      ctx.fillText(v.toFixed(1) + 'c', x, pad.t + gh + 20);
    }

    // Curves
    const curves = [
      { fn: (b) => gamma(b), color: '#a855f7', label: 'γ (Lorentz)' },
      { fn: (b) => gamma(b), color: '#f59e0b', label: 'Time Dilation' },
      { fn: (b) => 1 / gamma(b), color: '#06b6d4', label: 'Length (1/γ)', maxVal: 1 },
      { fn: (b) => gamma(b), color: '#ef4444', label: 'Energy (γmc²)' },
    ];

    // Length contraction uses different scale (0-1 mapped to 0-1 on graph)
    curves.forEach((curve, ci) => {
      ctx.beginPath();
      ctx.strokeStyle = curve.color;
      ctx.lineWidth = 2;
      for (let i = 0; i <= 500; i++) {
        const b = (i / 500) * 0.999;
        let val = curve.fn(b);
        if (ci === 2) val = val * maxY; // scale length to fill graph
        const x = pad.l + b * gw;
        const y = pad.t + gh - (Math.min(val, maxY) / maxY) * gh;
        i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
      }
      ctx.stroke();
    });

    // Legend
    curves.forEach((curve, i) => {
      const lx = pad.l + 12;
      const ly = pad.t + 14 + i * 18;
      ctx.fillStyle = curve.color;
      ctx.fillRect(lx, ly - 4, 16, 3);
      ctx.fillStyle = '#e2e8f0';
      ctx.font = '11px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText(curve.label, lx + 22, ly);
    });

    // Current velocity line
    if (currentBeta > 0) {
      const x = pad.l + currentBeta * gw;
      ctx.strokeStyle = 'rgba(255,255,255,0.3)';
      ctx.setLineDash([4, 4]);
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(x, pad.t);
      ctx.lineTo(x, pad.t + gh);
      ctx.stroke();
      ctx.setLineDash([]);
    }
  }

  slider.addEventListener('input', () => {
    currentBeta = slider.value / 10000;
    const g = currentBeta > 0.001 ? gamma(Math.min(currentBeta, 0.9999)) : 1;
    document.getElementById('master-vel-label').textContent = currentBeta.toFixed(4) + 'c';
    document.getElementById('c-gamma').textContent = fmt(g);
    document.getElementById('c-time').innerHTML = fmt(g) + '&times;';
    document.getElementById('c-length').textContent = (100 / g).toFixed(1) + '%';
    document.getElementById('c-energy').textContent = fmt(g);
    draw();
  });

  draw();
})();

// ==================== CAUSALITY VIOLATION ====================
(function initCausality() {
  // ---- Tab switching ----
  const tabBar = document.getElementById('causality-tabs');
  if (!tabBar) return;
  tabBar.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      tabBar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const tgt = btn.getAttribute('data-tab');
      btn.closest('.card').querySelectorAll('.tab-content').forEach(tc => {
        tc.classList.toggle('active', tc.id === tgt);
      });
    });
  });

  // ---- Constants ----
  const ALPHA_CENTAURI = 4.37; // light-years

  // ================================================================
  //  TAB 1: Simultaneity & Light Cones
  // ================================================================
  (function initSimultaneity() {
    const { ctx, w, h } = setupCanvas('causality-canvas');
    const velSlider = document.getElementById('caus-vel');
    const ftlSlider = document.getElementById('caus-ftl');
    let beta = 0;
    let ftlSpeed = 2.0; // multiples of c
    let animBeta = 0;
    let animFtl = 2.0;
    let animTime = 0;
    let prevTs = null;
    let violationFlash = 0;

    function updateReadouts(b, s) {
      const g = b > 0.001 ? gamma(Math.min(b, 0.999)) : 1;
      const tEarth = ALPHA_CENTAURI / s;
      const tMoving = g * (tEarth - b * ALPHA_CENTAURI);
      document.getElementById('cv-vel').textContent = b.toFixed(2) + 'c';
      document.getElementById('cv-ftl').textContent = s.toFixed(1) + 'c';
      document.getElementById('cv-earth-t').textContent = '+' + tEarth.toFixed(2) + ' yr';
      const movSign = tMoving >= 0 ? '+' : '';
      const movEl = document.getElementById('cv-moving-t');
      movEl.textContent = movSign + tMoving.toFixed(2) + ' yr';
      movEl.className = 'value ' + (tMoving < 0 ? 'red' : 'purple');
      const reversalDays = tMoving < 0 ? Math.abs(tMoving * 365.25) : 0;
      document.getElementById('cv-reversal').textContent = reversalDays > 0 ? reversalDays.toFixed(0) + ' days' : 'None';
      const statusEl = document.getElementById('cv-status');
      if (tMoving < 0) {
        statusEl.textContent = 'VIOLATION';
        statusEl.style.color = '#ef4444';
      } else {
        statusEl.textContent = 'OK';
        statusEl.style.color = '#22c55e';
      }
      return tMoving;
    }

    velSlider.addEventListener('input', () => {
      beta = velSlider.value / 100;
      document.getElementById('caus-vel-label').textContent = beta.toFixed(2) + 'c';
      updateReadouts(beta, ftlSpeed);
    });
    ftlSlider.addEventListener('input', () => {
      ftlSpeed = ftlSlider.value / 10;
      document.getElementById('caus-ftl-label').textContent = ftlSpeed.toFixed(1) + 'c';
      updateReadouts(beta, ftlSpeed);
    });

    function draw(ts) {
      if (prevTs === null) prevTs = ts;
      const dt = Math.min(ts - prevTs, 50);
      prevTs = ts;
      animTime += dt;
      animBeta += (beta - animBeta) * Math.min(1, dt * 0.008);
      animFtl += (ftlSpeed - animFtl) * Math.min(1, dt * 0.008);

      const b = animBeta;
      const s = animFtl;
      const g = b > 0.001 ? gamma(Math.min(b, 0.999)) : 1;
      const tEarth = ALPHA_CENTAURI / s;
      const tMoving = g * (tEarth - b * ALPHA_CENTAURI);

      // Violation flash
      if (tMoving < 0) {
        violationFlash = Math.min(1, violationFlash + dt * 0.004);
      } else {
        violationFlash = Math.max(0, violationFlash - dt * 0.004);
      }

      ctx.clearRect(0, 0, w, h);

      // --- Coordinate system ---
      const margin = { left: 80, right: 40, top: 50, bottom: 60 };
      const plotW = w - margin.left - margin.right;
      const plotH = h - margin.top - margin.bottom;
      const ox = margin.left; // origin x (Earth, x=0)
      const oy = margin.top + plotH * 0.65; // origin y (t=0) — shifted down so we see negative time
      const maxX = 8; // light-years
      const maxTup = 6; // years up (future)
      const maxTdown = 3; // years down (past)
      const xScale = plotW / maxX;
      const tScale = plotH / (maxTup + maxTdown);
      const tToY = (t) => oy - t * tScale;
      const xToX = (x) => ox + x * xScale;

      // --- Grid ---
      ctx.strokeStyle = 'rgba(30,41,59,0.5)';
      ctx.lineWidth = 0.5;
      for (let i = -Math.floor(maxTdown); i <= maxTup; i++) {
        const gy = tToY(i);
        ctx.beginPath(); ctx.moveTo(ox, gy); ctx.lineTo(ox + plotW, gy); ctx.stroke();
      }
      for (let i = 0; i <= maxX; i++) {
        const gx = xToX(i);
        ctx.beginPath(); ctx.moveTo(gx, tToY(-maxTdown)); ctx.lineTo(gx, tToY(maxTup)); ctx.stroke();
      }

      // --- Axes ---
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 1.5;
      // Time axis (vertical at x=0)
      ctx.beginPath(); ctx.moveTo(ox, tToY(-maxTdown)); ctx.lineTo(ox, tToY(maxTup)); ctx.stroke();
      // Space axis (horizontal at t=0)
      ctx.beginPath(); ctx.moveTo(ox, oy); ctx.lineTo(ox + plotW, oy); ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Distance (light-years)', ox + plotW / 2, h - 12);
      ctx.save();
      ctx.translate(18, oy);
      ctx.rotate(-Math.PI / 2);
      ctx.fillText('Time (years)', 0, 0);
      ctx.restore();

      // Tick labels
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#64748b';
      ctx.textAlign = 'center';
      for (let i = 0; i <= maxX; i += 2) {
        ctx.fillText(i + '', xToX(i), oy + 18);
      }
      ctx.textAlign = 'right';
      for (let i = -Math.floor(maxTdown); i <= maxTup; i++) {
        if (i === 0) continue;
        ctx.fillText((i > 0 ? '+' : '') + i, ox - 8, tToY(i) + 4);
      }
      ctx.fillText('0', ox - 8, oy + 4);

      // --- Light cone (from origin) ---
      // Future cone shading
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(maxTup), tToY(maxTup));
      ctx.lineTo(ox, tToY(maxTup));
      ctx.closePath();
      ctx.fillStyle = 'rgba(250,204,21,0.05)';
      ctx.fill();

      // Past cone shading
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(maxTdown), tToY(-maxTdown));
      ctx.lineTo(ox, tToY(-maxTdown));
      ctx.closePath();
      ctx.fillStyle = 'rgba(250,204,21,0.04)';
      ctx.fill();

      // Spacelike region shading (FTL zone) - right side
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(maxTup), tToY(maxTup));
      ctx.lineTo(ox + plotW, tToY(maxTup));
      ctx.lineTo(ox + plotW, tToY(-maxTdown));
      ctx.lineTo(xToX(maxTdown), tToY(-maxTdown));
      ctx.closePath();
      ctx.fillStyle = 'rgba(96,165,250,0.04)';
      ctx.fill();
      // Violation flash overlay
      if (violationFlash > 0) {
        ctx.fillStyle = `rgba(239,68,68,${0.06 * violationFlash * (0.5 + 0.5 * Math.sin(animTime * 0.006))})`;
        ctx.fillRect(ox, tToY(maxTup), plotW, plotH);
      }

      // Light cone lines (45°: 1 ly per year)
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2;
      ctx.setLineDash([]);
      // Future right
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(Math.min(maxX, maxTup)), tToY(Math.min(maxX, maxTup)));
      ctx.stroke();
      // Past right
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(xToX(Math.min(maxX, maxTdown)), tToY(-Math.min(maxX, maxTdown)));
      ctx.stroke();

      // Light cone label
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'italic 11px system-ui';
      ctx.textAlign = 'left';
      const lcLabelX = xToX(3.5);
      const lcLabelY = tToY(3.5);
      ctx.save();
      ctx.translate(lcLabelX, lcLabelY);
      ctx.rotate(-Math.PI / 4);
      ctx.fillText('Light (c)', 0, -8);
      ctx.restore();

      // FTL zone label
      ctx.fillStyle = 'rgba(96,165,250,0.5)';
      ctx.font = 'bold 14px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('FTL ZONE', xToX(6), oy - 6);
      ctx.font = '11px system-ui';
      ctx.fillStyle = 'rgba(96,165,250,0.35)';
      ctx.fillText('(spacelike region)', xToX(6), oy + 12);

      // --- Earth worldline (vertical at x=0) ---
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([]);
      ctx.beginPath();
      ctx.moveTo(ox, tToY(-maxTdown));
      ctx.lineTo(ox, tToY(maxTup));
      ctx.stroke();
      // Earth label
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Earth', ox, tToY(maxTup) - 8);

      // --- Alpha Centauri worldline (vertical at x=4.37) ---
      const acX = xToX(ALPHA_CENTAURI);
      ctx.strokeStyle = '#06b6d4';
      ctx.lineWidth = 2.5;
      ctx.beginPath();
      ctx.moveTo(acX, tToY(-maxTdown));
      ctx.lineTo(acX, tToY(maxTup));
      ctx.stroke();
      // AC label
      ctx.fillStyle = '#06b6d4';
      ctx.font = 'bold 12px system-ui';
      ctx.fillText('Alpha Centauri', acX, tToY(maxTup) - 8);
      ctx.font = '10px system-ui';
      ctx.fillStyle = '#06b6d4';
      ctx.fillText('4.37 ly', acX, tToY(maxTup) - 22);

      // --- FTL message line (Earth → AC) ---
      const msgArrT = ALPHA_CENTAURI / s; // arrival time in Earth frame
      const msgStartX = ox;
      const msgStartY = oy; // T=0
      const msgEndX = acX;
      const msgEndY = tToY(msgArrT);

      // Glow
      ctx.strokeStyle = 'rgba(239,68,68,0.2)';
      ctx.lineWidth = 8;
      ctx.setLineDash([]);
      ctx.beginPath(); ctx.moveTo(msgStartX, msgStartY); ctx.lineTo(msgEndX, msgEndY); ctx.stroke();
      // Core
      ctx.strokeStyle = '#ef4444';
      ctx.lineWidth = 2.5;
      ctx.setLineDash([8, 6]);
      ctx.beginPath(); ctx.moveTo(msgStartX, msgStartY); ctx.lineTo(msgEndX, msgEndY); ctx.stroke();
      ctx.setLineDash([]);

      // FTL message label
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 11px system-ui';
      ctx.textAlign = 'center';
      const fmlX = (msgStartX + msgEndX) / 2;
      const fmlY = (msgStartY + msgEndY) / 2;
      ctx.fillText('FTL Message (' + s.toFixed(1) + 'c)', fmlX, fmlY - 12);

      // Arrival event marker
      ctx.beginPath();
      ctx.arc(msgEndX, msgEndY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#ef4444';
      ctx.fill();
      // Send event marker
      ctx.beginPath();
      ctx.arc(msgStartX, msgStartY, 5, 0, Math.PI * 2);
      ctx.fillStyle = '#22c55e';
      ctx.fill();
      // Event labels
      ctx.font = '10px system-ui';
      ctx.textAlign = 'left';
      ctx.fillStyle = '#22c55e';
      ctx.fillText('SEND (T=0)', msgStartX + 10, msgStartY + 4);
      ctx.fillStyle = '#ef4444';
      ctx.textAlign = 'right';
      ctx.fillText('ARRIVE (T=' + msgArrT.toFixed(2) + 'yr)', msgEndX - 10, msgEndY - 8);

      // --- Simultaneity line (moving observer's "now") ---
      if (b > 0.005) {
        // The simultaneity line through the origin: t = (v/c²)·x → t = b·x (in natural units)
        const simSlope = b; // dt/dx in light-year/year units
        const simX1 = 0;
        const simT1 = 0;
        const simX2 = maxX;
        const simT2 = simSlope * maxX;

        // Wide glow
        ctx.strokeStyle = 'rgba(168,85,247,0.15)';
        ctx.lineWidth = 8;
        ctx.beginPath();
        ctx.moveTo(xToX(simX1), tToY(simT1));
        ctx.lineTo(xToX(simX2), tToY(simT2));
        ctx.stroke();

        // Dashed line
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        ctx.moveTo(xToX(simX1), tToY(simT1));
        ctx.lineTo(xToX(simX2), tToY(simT2));
        ctx.stroke();
        ctx.setLineDash([]);

        // "Now" labels
        ctx.fillStyle = '#a855f7';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('"Now" for moving observer', xToX(simX2) - 160, tToY(simT2) - 10);

        // Horizontal "now" for Earth (reference)
        ctx.strokeStyle = 'rgba(148,163,184,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([4, 4]);
        ctx.beginPath();
        ctx.moveTo(ox, oy);
        ctx.lineTo(ox + plotW, oy);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText('"Now" for Earth observer', ox + plotW, oy - 6);

        // Show where the simultaneity line crosses Alpha Centauri
        const simCrossT = simSlope * ALPHA_CENTAURI;
        const simCrossY = tToY(simCrossT);
        ctx.beginPath();
        ctx.arc(acX, simCrossY, 4, 0, Math.PI * 2);
        ctx.fillStyle = '#a855f7';
        ctx.fill();

        // Dashed vertical showing the time difference at AC
        ctx.strokeStyle = 'rgba(168,85,247,0.3)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(acX, oy);
        ctx.lineTo(acX, simCrossY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Label the time offset at AC
        ctx.fillStyle = '#a855f7';
        ctx.font = '10px system-ui';
        ctx.textAlign = 'left';
        const offsetLabel = simCrossT > 0 ? '+' + simCrossT.toFixed(2) + 'yr' : simCrossT.toFixed(2) + 'yr';
        ctx.fillText('Δt = ' + offsetLabel, acX + 8, (oy + simCrossY) / 2 + 4);
      }

      // --- Moving frame arrival time annotation ---
      if (b > 0.005 && tMoving < tEarth) {
        const movArrY = tToY(tMoving);
        // Dashed line from arrival point to the time axis
        ctx.strokeStyle = tMoving < 0 ? 'rgba(239,68,68,0.5)' : 'rgba(168,85,247,0.3)';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([4, 3]);
        ctx.beginPath();
        ctx.moveTo(acX, movArrY);
        ctx.lineTo(ox, movArrY);
        ctx.stroke();
        ctx.setLineDash([]);

        // Label on time axis
        ctx.fillStyle = tMoving < 0 ? '#ef4444' : '#a855f7';
        ctx.font = 'bold 10px system-ui';
        ctx.textAlign = 'right';
        const mtLabel = (tMoving >= 0 ? '+' : '') + tMoving.toFixed(2) + 'yr';
        // Background pill
        const mtText = "T'=" + mtLabel;
        const mtMeasure = ctx.measureText(mtText);
        const pillX = ox - 4 - mtMeasure.width - 8;
        const pillY = movArrY - 8;
        ctx.fillStyle = tMoving < 0 ? 'rgba(239,68,68,0.15)' : 'rgba(168,85,247,0.1)';
        ctx.beginPath();
        ctx.roundRect(pillX, pillY, mtMeasure.width + 12, 18, 4);
        ctx.fill();
        ctx.fillStyle = tMoving < 0 ? '#ef4444' : '#a855f7';
        ctx.fillText(mtText, ox - 6, movArrY + 4);

        // If violation, show a prominent marker
        if (tMoving < 0) {
          // Red zone highlight below T=0
          ctx.fillStyle = `rgba(239,68,68,${0.08 * (0.6 + 0.4 * Math.sin(animTime * 0.005))})`;
          ctx.fillRect(ox, oy, plotW, tToY(Math.max(tMoving, -maxTdown)) - oy);

          // CAUSALITY VIOLATION label
          const flashAlpha = 0.7 + 0.3 * Math.sin(animTime * 0.006);
          ctx.fillStyle = `rgba(239,68,68,${flashAlpha})`;
          ctx.font = 'bold 18px system-ui';
          ctx.textAlign = 'center';
          ctx.fillText('CAUSALITY VIOLATION', w / 2, tToY(maxTup) + 30);
          ctx.font = '12px system-ui';
          ctx.fillText('Message arrives ' + Math.abs(tMoving * 365.25).toFixed(0) + ' days BEFORE it was sent', w / 2, tToY(maxTup) + 50);
        }
      }

      // --- Animated photons on light cone ---
      const photonPhase = (animTime % 4000) / 4000;
      const photonDist = photonPhase * Math.min(maxX, maxTup);
      const ppx = xToX(photonDist);
      const ppy = tToY(photonDist);
      if (ppy > tToY(maxTup)) {
        const pg = ctx.createRadialGradient(ppx, ppy, 0, ppx, ppy, 6);
        pg.addColorStop(0, 'rgba(251,191,36,0.6)');
        pg.addColorStop(1, 'transparent');
        ctx.fillStyle = pg;
        ctx.fillRect(ppx - 8, ppy - 8, 16, 16);
        ctx.beginPath(); ctx.arc(ppx, ppy, 3, 0, Math.PI * 2);
        ctx.fillStyle = '#fef3c7'; ctx.fill();
      }

      requestAnimationFrame(draw);
    }
    updateReadouts(0, 2.0);
    requestAnimationFrame(draw);
  })();

  // ================================================================
  //  TAB 2: The Paradox Animation
  // ================================================================
  (function initParadox() {
    const { ctx, w, h } = setupCanvas('paradox-canvas');
    const playBtn = document.getElementById('paradox-play');
    const resetBtn = document.getElementById('paradox-reset');
    const speedBtn = document.getElementById('paradox-speed');

    // Physics constants for the scenario
    const dist = ALPHA_CENTAURI; // 4.37 ly
    const ftlS = 2.185; // FTL speed in c — arrives in ~2 years
    const obsV = 0.50; // moving observer velocity
    const obsG = gamma(obsV); // 1.1547
    const tArriveEarth = dist / ftlS; // ~2.0 years
    const tArriveMoving = obsG * (tArriveEarth - obsV * dist); // ~ -0.214 yr
    const replyArriveEarth = tArriveEarth + tArriveMoving; // arrives before T=0

    // Animation state
    let running = false;
    let finished = false;
    let simTime = 0; // simulation time in "phase units" (0 to totalDuration)
    let simSpeed = 1;
    let prevTs = null;

    // Phases with durations (in seconds of real time at 1x)
    const phases = [
      { name: 'send',      duration: 2.5, label: 'Sending FTL Message...' },
      { name: 'arrive',    duration: 1.5, label: 'Message Received!' },
      { name: 'reframe',   duration: 2.5, label: 'Switching to Moving Frame...' },
      { name: 'reply',     duration: 2.5, label: 'Sending FTL Reply...' },
      { name: 'paradox',   duration: 2.0, label: 'Reply Arrives Before Sending!' },
      { name: 'loop',      duration: 4.0, label: 'PARADOX: Causal Loop!' },
    ];
    const totalDuration = phases.reduce((s, p) => s + p.duration, 0);

    function getPhase(t) {
      let acc = 0;
      for (let i = 0; i < phases.length; i++) {
        if (t < acc + phases[i].duration) {
          return { idx: i, phase: phases[i].name, frac: (t - acc) / phases[i].duration, label: phases[i].label };
        }
        acc += phases[i].duration;
      }
      return { idx: phases.length - 1, phase: 'loop', frac: 1, label: phases[phases.length - 1].label };
    }

    // Controls
    playBtn.addEventListener('click', () => {
      if (finished) return;
      if (running) {
        running = false;
        playBtn.textContent = 'Resume';
      } else {
        running = true;
        playBtn.textContent = 'Pause';
      }
    });
    resetBtn.addEventListener('click', () => {
      running = false; finished = false; simTime = 0; prevTs = null;
      playBtn.textContent = 'Play Scenario';
      document.getElementById('px-earth-t').textContent = 'T = 0.00 yr';
      document.getElementById('px-ac-t').textContent = 'T = 0.00 yr';
      document.getElementById('px-moving-t').textContent = "T\u2032 = 0.00 yr";
      document.getElementById('px-phase').textContent = 'Ready';
      document.getElementById('px-phase').style.color = 'var(--muted)';
      document.getElementById('px-msg').textContent = '\u2014';
      document.getElementById('px-msg').className = 'value cyan';
      document.getElementById('px-paradox').textContent = 'None yet';
      document.getElementById('px-paradox').style.color = '#22c55e';
    });
    const speeds = [1, 2, 5, 10];
    let speedIdx = 0;
    speedBtn.addEventListener('click', () => {
      speedIdx = (speedIdx + 1) % speeds.length;
      simSpeed = speeds[speedIdx];
      speedBtn.innerHTML = 'Speed: ' + simSpeed + '&times;';
    });

    function draw(ts) {
      if (prevTs === null) prevTs = ts;
      const dt = Math.min(ts - prevTs, 50);
      prevTs = ts;

      if (running && !finished) {
        simTime += (dt / 1000) * simSpeed;
        if (simTime >= totalDuration) {
          simTime = totalDuration;
          finished = true;
          running = false;
          playBtn.textContent = 'Scenario Complete';
        }
      }

      const { idx, phase, frac, label } = running || finished || simTime > 0
        ? getPhase(simTime) : { idx: -1, phase: 'ready', frac: 0, label: 'Ready' };

      ctx.clearRect(0, 0, w, h);

      // ---- Layout ----
      const sceneH = h * 0.35;
      const stH = h * 0.65;
      const stTop = sceneH;

      // ==============================
      //  SCENE VIEW (top 35%)
      // ==============================
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, 0, w, sceneH);
      ctx.clip();

      // Background
      ctx.fillStyle = '#060a14';
      ctx.fillRect(0, 0, w, sceneH);

      // Some stars
      ctx.fillStyle = 'rgba(255,255,255,0.3)';
      for (let i = 0; i < 40; i++) {
        const sx = ((i * 137 + 50) % w);
        const sy = ((i * 97 + 30) % sceneH);
        ctx.fillRect(sx, sy, 1, 1);
      }

      const earthX = 80;
      const acX_scene = w - 80;
      const midY = sceneH / 2;

      // Earth
      ctx.beginPath();
      ctx.arc(earthX, midY, 22, 0, Math.PI * 2);
      const earthGrad = ctx.createRadialGradient(earthX - 5, midY - 5, 2, earthX, midY, 22);
      earthGrad.addColorStop(0, '#60a5fa');
      earthGrad.addColorStop(0.5, '#2563eb');
      earthGrad.addColorStop(1, '#1e3a5f');
      ctx.fillStyle = earthGrad;
      ctx.fill();
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 12px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Earth', earthX, midY + 38);

      // Alpha Centauri (star)
      const starPulse = 0.85 + 0.15 * Math.sin(ts * 0.003);
      ctx.beginPath();
      ctx.arc(acX_scene, midY, 14 * starPulse, 0, Math.PI * 2);
      const starGrad = ctx.createRadialGradient(acX_scene, midY, 0, acX_scene, midY, 14);
      starGrad.addColorStop(0, '#fff');
      starGrad.addColorStop(0.3, '#fbbf24');
      starGrad.addColorStop(1, 'rgba(251,191,36,0)');
      ctx.fillStyle = starGrad;
      ctx.fill();
      // Star glow
      ctx.beginPath();
      ctx.arc(acX_scene, midY, 28, 0, Math.PI * 2);
      const glowGrad = ctx.createRadialGradient(acX_scene, midY, 8, acX_scene, midY, 28);
      glowGrad.addColorStop(0, 'rgba(251,191,36,0.15)');
      glowGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = glowGrad;
      ctx.fill();
      ctx.fillStyle = '#fbbf24';
      ctx.font = 'bold 12px system-ui';
      ctx.fillText('\u03B1 Centauri', acX_scene, midY + 38);

      // Distance label
      ctx.fillStyle = '#64748b';
      ctx.font = '10px system-ui';
      ctx.fillText('4.37 light-years', (earthX + acX_scene) / 2, sceneH - 12);
      // Dashed distance line
      ctx.strokeStyle = 'rgba(100,116,139,0.3)';
      ctx.lineWidth = 1;
      ctx.setLineDash([4, 4]);
      ctx.beginPath();
      ctx.moveTo(earthX + 30, sceneH - 16);
      ctx.lineTo(acX_scene - 24, sceneH - 16);
      ctx.stroke();
      ctx.setLineDash([]);

      // ---- Animated signals in scene ----
      const sigRange = acX_scene - earthX - 60;
      const sigStartX = earthX + 30;

      // Phase: send — FTL message travels Earth → AC
      if (phase === 'send') {
        const px = sigStartX + frac * sigRange;
        // Trail
        const trailLen = 80;
        ctx.strokeStyle = 'rgba(6,182,212,0.3)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(Math.max(sigStartX, px - trailLen), midY);
        ctx.lineTo(px, midY);
        ctx.stroke();
        // Pulse
        const pg = ctx.createRadialGradient(px, midY, 0, px, midY, 10);
        pg.addColorStop(0, '#fff');
        pg.addColorStop(0.3, '#06b6d4');
        pg.addColorStop(1, 'transparent');
        ctx.fillStyle = pg;
        ctx.fillRect(px - 12, midY - 12, 24, 24);
        // Label
        ctx.fillStyle = '#06b6d4';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('"HELLO" @ 2.185c', px, midY - 18);
      }

      // Phase: arrive — flash at AC
      if (phase === 'arrive') {
        const flashR = 20 + 15 * (1 - frac);
        const flashA = 0.4 * (1 - frac);
        ctx.beginPath();
        ctx.arc(acX_scene, midY, flashR, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(6,182,212,${flashA})`;
        ctx.fill();
        ctx.fillStyle = '#06b6d4';
        ctx.font = 'bold 12px system-ui';
        ctx.fillText('RECEIVED "HELLO"', (earthX + acX_scene) / 2, midY - 30);
        ctx.font = '11px system-ui';
        ctx.fillText('T = 2.00 yr (Earth frame)', (earthX + acX_scene) / 2, midY - 14);
      }

      // Phase: reframe — visual transition
      if (phase === 'reframe') {
        const flashAlpha = 0.5 + 0.5 * Math.sin(frac * Math.PI * 4);
        ctx.fillStyle = `rgba(168,85,247,${flashAlpha * 0.15})`;
        ctx.fillRect(0, 0, w, sceneH);
        ctx.fillStyle = '#a855f7';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Moving observer (v=0.50c) sees arrival at', w / 2, midY - 24);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 20px Courier New';
        ctx.fillText("T' = -0.21 yr = -78 days", w / 2, midY + 8);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px system-ui';
        ctx.fillText('The message arrived BEFORE it was sent!', w / 2, midY + 32);
      }

      // Phase: reply — FTL reply travels AC → Earth
      if (phase === 'reply') {
        const px = sigStartX + sigRange - frac * sigRange;
        // Trail
        const trailLen = 80;
        ctx.strokeStyle = 'rgba(239,68,68,0.3)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(Math.min(sigStartX + sigRange, px + trailLen), midY);
        ctx.lineTo(px, midY);
        ctx.stroke();
        // Pulse
        const pg = ctx.createRadialGradient(px, midY, 0, px, midY, 10);
        pg.addColorStop(0, '#fff');
        pg.addColorStop(0.3, '#ef4444');
        pg.addColorStop(1, 'transparent');
        ctx.fillStyle = pg;
        ctx.fillRect(px - 12, midY - 12, 24, 24);
        // Label
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 11px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('"DON\'T SEND" @ 2.185c', px, midY - 18);
      }

      // Phase: paradox — flash at Earth
      if (phase === 'paradox') {
        const flashR = 25 + 20 * (1 - frac);
        const flashA = 0.5 * (1 - frac * 0.5);
        ctx.beginPath();
        ctx.arc(earthX, midY, flashR, 0, Math.PI * 2);
        ctx.fillStyle = `rgba(239,68,68,${flashA})`;
        ctx.fill();
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('Reply arrives BEFORE original was sent!', w / 2, midY - 28);
        ctx.font = 'bold 16px Courier New';
        ctx.fillText('T(reply) < T(send) = 0', w / 2, midY + 4);
      }

      // Phase: loop — the paradox revealed
      if (phase === 'loop') {
        const pulse = 0.5 + 0.5 * Math.sin(ts * 0.005);
        ctx.fillStyle = `rgba(239,68,68,${0.08 * pulse})`;
        ctx.fillRect(0, 0, w, sceneH);

        // Circular arrow showing the loop
        ctx.strokeStyle = `rgba(239,68,68,${0.6 + 0.4 * pulse})`;
        ctx.lineWidth = 3;
        const cx = w / 2, cy = midY;
        const rr = 50;
        ctx.beginPath();
        ctx.arc(cx, cy, rr, -Math.PI * 0.8, Math.PI * 0.6);
        ctx.stroke();
        // Arrowhead
        const aAngle = Math.PI * 0.6;
        const ax = cx + rr * Math.cos(aAngle);
        const ay = cy + rr * Math.sin(aAngle);
        ctx.fillStyle = `rgba(239,68,68,${0.6 + 0.4 * pulse})`;
        ctx.beginPath();
        ctx.moveTo(ax, ay);
        ctx.lineTo(ax + 10, ay - 6);
        ctx.lineTo(ax + 4, ay + 8);
        ctx.closePath();
        ctx.fill();

        ctx.textAlign = 'center';
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 13px system-ui';
        ctx.fillText('CAUSAL LOOP PARADOX', cx, cy - 8);
        ctx.font = '11px system-ui';
        ctx.fillStyle = '#f87171';
        ctx.fillText('If you receive "DON\'T SEND" before sending...', cx, cy + 8);
        ctx.fillText('do you send? Either answer = contradiction', cx, cy + 24);
      }

      ctx.restore(); // end scene clip

      // Divider line
      ctx.strokeStyle = '#1e293b';
      ctx.lineWidth = 1;
      ctx.beginPath(); ctx.moveTo(0, sceneH); ctx.lineTo(w, sceneH); ctx.stroke();

      // ==============================
      //  SPACETIME DIAGRAM (bottom 65%)
      // ==============================
      ctx.save();
      ctx.beginPath();
      ctx.rect(0, stTop, w, stH);
      ctx.clip();

      // Background
      ctx.fillStyle = '#080c16';
      ctx.fillRect(0, stTop, w, stH);

      const stMargin = { left: 80, right: 40, top: 30, bottom: 40 };
      const stPlotW = w - stMargin.left - stMargin.right;
      const stPlotH = stH - stMargin.top - stMargin.bottom;
      const stOx = stMargin.left;
      const stOy = stTop + stMargin.top + stPlotH * 0.7; // origin shifted down
      const stMaxX = 8;
      const stMaxTup = 5;
      const stMaxTdown = 2;
      const stXScale = stPlotW / stMaxX;
      const stTScale = stPlotH / (stMaxTup + stMaxTdown);
      const stTtoY = (t) => stOy - t * stTScale;
      const stXtoX = (x) => stOx + x * stXScale;

      // Grid
      ctx.strokeStyle = 'rgba(30,41,59,0.4)';
      ctx.lineWidth = 0.5;
      for (let i = -Math.floor(stMaxTdown); i <= stMaxTup; i++) {
        const gy = stTtoY(i);
        ctx.beginPath(); ctx.moveTo(stOx, gy); ctx.lineTo(stOx + stPlotW, gy); ctx.stroke();
      }
      for (let i = 0; i <= stMaxX; i += 2) {
        const gx = stXtoX(i);
        ctx.beginPath(); ctx.moveTo(gx, stTtoY(-stMaxTdown)); ctx.lineTo(gx, stTtoY(stMaxTup)); ctx.stroke();
      }

      // Axes
      ctx.strokeStyle = '#475569';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); ctx.moveTo(stOx, stTtoY(-stMaxTdown)); ctx.lineTo(stOx, stTtoY(stMaxTup)); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(stOx, stOy); ctx.lineTo(stOx + stPlotW, stOy); ctx.stroke();

      // Axis labels
      ctx.fillStyle = '#64748b';
      ctx.font = '10px system-ui';
      ctx.textAlign = 'center';
      for (let i = 0; i <= stMaxX; i += 2) ctx.fillText(i + ' ly', stXtoX(i), stOy + 16);
      ctx.textAlign = 'right';
      for (let i = -Math.floor(stMaxTdown); i <= stMaxTup; i++) {
        ctx.fillText((i >= 0 ? '+' : '') + i + 'yr', stOx - 6, stTtoY(i) + 4);
      }

      // Light cone from origin
      ctx.strokeStyle = 'rgba(245,158,11,0.4)';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.moveTo(stOx, stOy);
      ctx.lineTo(stXtoX(Math.min(stMaxX, stMaxTup)), stTtoY(Math.min(stMaxX, stMaxTup)));
      ctx.stroke();
      ctx.beginPath();
      ctx.moveTo(stOx, stOy);
      ctx.lineTo(stXtoX(Math.min(stMaxX, stMaxTdown)), stTtoY(-Math.min(stMaxX, stMaxTdown)));
      ctx.stroke();
      ctx.fillStyle = 'rgba(245,158,11,0.35)';
      ctx.font = 'italic 10px system-ui';
      ctx.textAlign = 'left';
      ctx.fillText('c', stXtoX(2.5), stTtoY(2.5) - 6);

      // Earth worldline
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(stOx, stTtoY(-stMaxTdown));
      ctx.lineTo(stOx, stTtoY(stMaxTup));
      ctx.stroke();
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 10px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Earth', stOx, stTtoY(stMaxTup) - 6);

      // Alpha Centauri worldline
      const stAcX = stXtoX(dist);
      ctx.strokeStyle = '#06b6d4';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(stAcX, stTtoY(-stMaxTdown));
      ctx.lineTo(stAcX, stTtoY(stMaxTup));
      ctx.stroke();
      ctx.fillStyle = '#06b6d4';
      ctx.font = 'bold 10px system-ui';
      ctx.fillText('\u03B1 Cen', stAcX, stTtoY(stMaxTup) - 6);

      // ---- Animated events based on phase ----
      // Event A: Send at (x=0, t=0)
      const evSendX = stOx;
      const evSendY = stOy;

      // Event B: Arrive at (x=4.37, t=2.0)
      const evArrX = stAcX;
      const evArrY = stTtoY(tArriveEarth);

      // Event C: Reply arrives at Earth at negative time
      const replyArrT = tArriveEarth + tArriveMoving; // ~1.79 yr but via moving frame perspective
      // For the paradox, the reply arrives BEFORE T=0
      const evReplyX = stOx;
      const evReplyY = stTtoY(tArriveMoving); // at the negative time

      // Compute animation progress for each element
      const showSendLine = phase !== 'ready';
      const showArrival = idx >= 1; // arrive phase or later
      const showReframe = idx >= 2; // reframe or later
      const showReplyLine = idx >= 3; // reply or later
      const showParadox = idx >= 4; // paradox or later
      const showLoop = idx >= 5;

      // Send event marker (always visible once started)
      if (showSendLine) {
        ctx.beginPath();
        ctx.arc(evSendX, evSendY, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#22c55e';
        ctx.fill();
        ctx.fillStyle = '#22c55e';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('SEND (T=0)', evSendX + 8, evSendY - 6);
      }

      // FTL message line (Earth → AC)
      if (showSendLine) {
        const msgFrac = phase === 'send' ? frac : 1;
        const curX = lerp(evSendX, evArrX, msgFrac);
        const curY = lerp(evSendY, evArrY, msgFrac);
        // Glow
        ctx.strokeStyle = 'rgba(6,182,212,0.2)';
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(evSendX, evSendY); ctx.lineTo(curX, curY); ctx.stroke();
        // Dashed core
        ctx.strokeStyle = '#06b6d4';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(evSendX, evSendY); ctx.lineTo(curX, curY); ctx.stroke();
        ctx.setLineDash([]);
        // Traveling pulse
        if (phase === 'send') {
          const pg = ctx.createRadialGradient(curX, curY, 0, curX, curY, 8);
          pg.addColorStop(0, '#fff');
          pg.addColorStop(0.4, '#06b6d4');
          pg.addColorStop(1, 'transparent');
          ctx.fillStyle = pg;
          ctx.fillRect(curX - 10, curY - 10, 20, 20);
        }
        // Label
        ctx.fillStyle = '#06b6d4';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'center';
        const mlx = (evSendX + evArrX) / 2;
        const mly = (evSendY + evArrY) / 2;
        if (msgFrac > 0.3) {
          ctx.fillText('"HELLO" (2.185c)', mlx + 40, mly + 5);
        }
      }

      // Arrival marker
      if (showArrival) {
        ctx.beginPath();
        ctx.arc(evArrX, evArrY, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#06b6d4';
        ctx.fill();
        ctx.fillStyle = '#06b6d4';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText('ARRIVE (T=+2.0yr)', evArrX - 8, evArrY - 6);
      }

      // Moving observer's simultaneity line
      if (showReframe) {
        const simSlope = obsV;
        const simX2 = stMaxX;
        const simT2 = simSlope * simX2;
        ctx.strokeStyle = 'rgba(168,85,247,0.15)';
        ctx.lineWidth = 6;
        ctx.beginPath();
        ctx.moveTo(stOx, stOy);
        ctx.lineTo(stXtoX(simX2), stTtoY(simT2));
        ctx.stroke();
        ctx.strokeStyle = '#a855f7';
        ctx.lineWidth = 1.5;
        ctx.setLineDash([5, 3]);
        ctx.beginPath();
        ctx.moveTo(stOx, stOy);
        ctx.lineTo(stXtoX(simX2), stTtoY(simT2));
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#a855f7';
        ctx.font = '9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText("Moving observer's \"now\"", stXtoX(simX2) - 130, stTtoY(simT2) - 8);

        // Show the T' arrival time annotation
        const movArrY = stTtoY(tArriveMoving);
        ctx.strokeStyle = 'rgba(239,68,68,0.4)';
        ctx.lineWidth = 1;
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(evArrX, movArrY);
        ctx.lineTo(stOx, movArrY);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 9px system-ui';
        ctx.textAlign = 'right';
        ctx.fillText("T'=-0.21yr (-78 days)", stOx - 4, movArrY + 4);
      }

      // Reply line (AC → Earth, arriving at negative time)
      if (showReplyLine) {
        const replyFrac = phase === 'reply' ? frac : 1;
        const rStartX = evArrX;
        const rStartY = evArrY;
        const rEndX = evReplyX;
        const rEndY = evReplyY;
        const curX = lerp(rStartX, rEndX, replyFrac);
        const curY = lerp(rStartY, rEndY, replyFrac);
        // Glow
        ctx.strokeStyle = 'rgba(239,68,68,0.2)';
        ctx.lineWidth = 6;
        ctx.beginPath(); ctx.moveTo(rStartX, rStartY); ctx.lineTo(curX, curY); ctx.stroke();
        // Dashed core
        ctx.strokeStyle = '#ef4444';
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath(); ctx.moveTo(rStartX, rStartY); ctx.lineTo(curX, curY); ctx.stroke();
        ctx.setLineDash([]);
        // Pulse
        if (phase === 'reply') {
          const pg = ctx.createRadialGradient(curX, curY, 0, curX, curY, 8);
          pg.addColorStop(0, '#fff');
          pg.addColorStop(0.4, '#ef4444');
          pg.addColorStop(1, 'transparent');
          ctx.fillStyle = pg;
          ctx.fillRect(curX - 10, curY - 10, 20, 20);
        }
        // Label
        if (replyFrac > 0.3) {
          ctx.fillStyle = '#ef4444';
          ctx.font = '9px system-ui';
          ctx.textAlign = 'center';
          const rlx = (rStartX + rEndX) / 2;
          const rly = (rStartY + rEndY) / 2;
          ctx.fillText('"DON\'T SEND" (2.185c)', rlx - 40, rly - 5);
        }
      }

      // Reply arrival marker (below T=0!)
      if (showParadox) {
        ctx.beginPath();
        ctx.arc(evReplyX, evReplyY, 6, 0, Math.PI * 2);
        ctx.fillStyle = '#ef4444';
        ctx.fill();
        ctx.fillStyle = '#ef4444';
        ctx.font = 'bold 9px system-ui';
        ctx.textAlign = 'left';
        ctx.fillText('REPLY ARRIVES', evReplyX + 10, evReplyY - 8);
        ctx.fillText('BEFORE SEND!', evReplyX + 10, evReplyY + 6);

        // Red zone below T=0
        const zoneAlpha = 0.08 * (0.6 + 0.4 * Math.sin(ts * 0.004));
        ctx.fillStyle = `rgba(239,68,68,${zoneAlpha})`;
        ctx.fillRect(stOx, stOy, stPlotW, stTtoY(Math.max(tArriveMoving, -stMaxTdown)) - stOy);
      }

      // Causal loop highlight
      if (showLoop) {
        const loopPulse = 0.5 + 0.5 * Math.sin(ts * 0.005);
        // Highlight the triangle formed by send→arrive→reply-arrive
        ctx.strokeStyle = `rgba(239,68,68,${0.4 + 0.3 * loopPulse})`;
        ctx.lineWidth = 3;
        ctx.setLineDash([]);
        ctx.beginPath();
        ctx.moveTo(evSendX, evSendY);
        ctx.lineTo(evArrX, evArrY);
        ctx.lineTo(evReplyX, evReplyY);
        ctx.closePath();
        ctx.stroke();
        ctx.fillStyle = `rgba(239,68,68,${0.04 + 0.03 * loopPulse})`;
        ctx.fill();

        // PARADOX label
        ctx.fillStyle = `rgba(239,68,68,${0.7 + 0.3 * loopPulse})`;
        ctx.font = 'bold 14px system-ui';
        ctx.textAlign = 'center';
        ctx.fillText('CAUSAL LOOP', (evSendX + evArrX) / 2, (evSendY + evArrY + evReplyY) / 3 + 4);
      }

      ctx.restore(); // end spacetime clip

      // ---- Update readouts ----
      if (running || finished || simTime > 0) {
        const phaseEl = document.getElementById('px-phase');
        phaseEl.textContent = label;
        phaseEl.style.color = showParadox ? '#ef4444' : showReframe ? '#a855f7' : '#06b6d4';

        // Earth clock shows simulation progress through Earth time
        let earthT = 0;
        if (phase === 'send') earthT = frac * tArriveEarth;
        else if (idx >= 1 && idx < 3) earthT = tArriveEarth;
        else if (phase === 'reply') earthT = tArriveEarth + frac * tArriveMoving;
        else if (idx >= 4) earthT = tArriveEarth + tArriveMoving;
        document.getElementById('px-earth-t').textContent = 'T = ' + earthT.toFixed(2) + ' yr';

        // AC clock
        let acT = 0;
        if (idx >= 1) acT = tArriveEarth;
        document.getElementById('px-ac-t').textContent = 'T = ' + acT.toFixed(2) + ' yr';

        // Moving frame
        let movT = 0;
        if (idx >= 2) movT = tArriveMoving;
        const movTEl = document.getElementById('px-moving-t');
        movTEl.textContent = "T\u2032 = " + movT.toFixed(2) + ' yr';
        movTEl.className = 'value ' + (movT < 0 ? 'red' : 'purple');

        // Message content
        const msgEl = document.getElementById('px-msg');
        if (phase === 'send') { msgEl.textContent = '"HELLO"'; msgEl.className = 'value cyan'; msgEl.style.fontSize = '1rem'; }
        else if (phase === 'arrive') { msgEl.textContent = '"HELLO" received'; msgEl.className = 'value cyan'; msgEl.style.fontSize = '1rem'; }
        else if (phase === 'reframe') { msgEl.textContent = 'Frame shift...'; msgEl.className = 'value purple'; msgEl.style.fontSize = '1rem'; }
        else if (phase === 'reply') { msgEl.textContent = '"DON\'T SEND"'; msgEl.className = 'value red'; msgEl.style.fontSize = '1rem'; }
        else if (showParadox) { msgEl.textContent = '"DON\'T SEND"'; msgEl.className = 'value red'; msgEl.style.fontSize = '1rem'; }

        // Paradox
        const pxEl = document.getElementById('px-paradox');
        if (showLoop) {
          const pPulse = Math.sin(ts * 0.004) > 0;
          pxEl.textContent = pPulse ? 'PARADOX!' : 'CAUSAL LOOP';
          pxEl.style.color = '#ef4444';
        } else if (showParadox) {
          pxEl.textContent = 'Time reversed!';
          pxEl.style.color = '#ef4444';
        } else if (showReframe) {
          pxEl.textContent = 'Negative time...';
          pxEl.style.color = '#f59e0b';
        } else {
          pxEl.textContent = 'None yet';
          pxEl.style.color = '#22c55e';
        }
      }

      requestAnimationFrame(draw);
    }
    requestAnimationFrame(draw);
  })();
})();

// ==================== SPACETIME CURVATURE 3D ====================
(function initCurvature() {
  if (typeof THREE === 'undefined') {
    // Three.js might not have loaded yet (defer). Wait for it.
    if (document.readyState === 'complete') return;
    window.addEventListener('load', function() {
      if (typeof THREE !== 'undefined') initCurvatureScene();
    });
    return;
  }
  initCurvatureScene();

  function initCurvatureScene() {
    const container = document.getElementById('curvature-container');
    if (!container) return;

    // ---- Scene setup ----
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x060a14, 0.012);

    const camera = new THREE.PerspectiveCamera(55, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 28, 38);
    camera.lookAt(0, -3, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.setClearColor(0x060a14);
    container.appendChild(renderer.domElement);

    // OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.08;
    controls.minDistance = 10;
    controls.maxDistance = 80;
    controls.maxPolarAngle = Math.PI; // Allow full rotation in 3D mode
    controls.target.set(0, -3, 0);

    // Lighting
    scene.add(new THREE.AmbientLight(0x334466, 0.6));
    const dirLight = new THREE.DirectionalLight(0xaabbff, 0.8);
    dirLight.position.set(10, 20, 10);
    scene.add(dirLight);
    const pointLight = new THREE.PointLight(0x3b82f6, 0.4, 60);
    pointLight.position.set(0, 15, 0);
    scene.add(pointLight);

    // Resize
    const onResize = () => {
      const w = container.clientWidth, h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    };
    window.addEventListener('resize', onResize);

    // ---- Grid (spacetime fabric) ----
    const GRID_SIZE = 40;
    const GRID_SEG = 60;
    const gridGeo = new THREE.PlaneGeometry(GRID_SIZE, GRID_SIZE, GRID_SEG, GRID_SEG);
    gridGeo.rotateX(-Math.PI / 2);

    const origPos = new Float32Array(gridGeo.attributes.position.array);
    const vertCount = gridGeo.attributes.position.count;
    const colors = new Float32Array(vertCount * 3);
    // Init colors to blue (flat space)
    for (let i = 0; i < vertCount; i++) {
      colors[i * 3] = 0.2; colors[i * 3 + 1] = 0.4; colors[i * 3 + 2] = 1.0;
    }
    gridGeo.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    const gridMat = new THREE.MeshPhongMaterial({
      vertexColors: true, transparent: true, opacity: 0.7,
      side: THREE.DoubleSide, shininess: 30, specular: new THREE.Color(0x112244)
    });
    const gridMesh = new THREE.Mesh(gridGeo, gridMat);
    scene.add(gridMesh);

    // Wireframe sharing same position buffer
    const n = GRID_SEG + 1;
    const wireIndices = [];
    for (let j = 0; j < n; j++) {
      for (let i = 0; i < GRID_SEG; i++) {
        wireIndices.push(j * n + i, j * n + i + 1);
        wireIndices.push(i * n + j, (i + 1) * n + j);
      }
    }
    const wireGeo = new THREE.BufferGeometry();
    wireGeo.setAttribute('position', gridGeo.attributes.position);
    wireGeo.setIndex(wireIndices);
    const wireMat = new THREE.LineBasicMaterial({ color: 0x3b82f6, transparent: true, opacity: 0.18 });
    const wireframe = new THREE.LineSegments(wireGeo, wireMat);
    scene.add(wireframe);

    // ---- State ----
    const masses = [];
    const particles = [];
    const MAX_MASSES = 5;
    const MAX_PARTICLES = 12;
    const TRAIL_LEN = 300;
    const massGroup = new THREE.Group();
    const particleGroup = new THREE.Group();
    const straightGroup = new THREE.Group();
    scene.add(massGroup);
    scene.add(particleGroup);
    scene.add(straightGroup);

    let currentMode = 'camera';
    let crossSectionMode = false;
    let showStraightness = false;
    let showCrossSections = true;
    let view3D = true;
    let mouseDownPos = null;
    let paused = false;
    let simSpeed = 1.0;
    let simElapsed = 0;
    let showTrails = true;
    let showForces = false;
    let showFlatRef = false;
    let curvatureScale = 5.0;
    let followTarget = null;
    let cameraMode = 'free';
    // Physics sub-step size moved to PHYSICS_DT in stepParticles

    // ---- 3D Spherical shells ----
    const sphereGroup = new THREE.Group();
    sphereGroup.visible = false;
    scene.add(sphereGroup);
    const shellRadii = [8, 14, 20];
    const shellDetail = 3;
    const shells = [];
    const shellOrigPositions = [];
    // Distinct colors per shell: inner=red, middle=orange, outer=blue
    const shellBaseColors = [
      { r: 1.0, g: 0.15, b: 0.1 },   // inner: deep red
      { r: 1.0, g: 0.6, b: 0.1 },    // middle: orange/amber
      { r: 0.2, g: 0.5, b: 1.0 }     // outer: light blue
    ];
    const shellWireColors = [0xff3333, 0xf59e0b, 0x3b82f6];
    const shellOpacities = [0.05, 0.08, 0.07];
    const shellWireOpacities = [0.20, 0.22, 0.16];

    for (let si = 0; si < shellRadii.length; si++) {
      const r = shellRadii[si];
      const bc = shellBaseColors[si];
      const geo = new THREE.IcosahedronGeometry(r, shellDetail);
      const vc = geo.attributes.position.count;
      const cols = new Float32Array(vc * 3);
      for (let i = 0; i < vc; i++) { cols[i*3]=bc.r; cols[i*3+1]=bc.g; cols[i*3+2]=bc.b; }
      geo.setAttribute('color', new THREE.BufferAttribute(cols, 3));
      const mat = new THREE.MeshPhongMaterial({
        vertexColors: true, transparent: true, opacity: shellOpacities[si],
        side: THREE.DoubleSide, shininess: 20, depthWrite: false
      });
      const mesh = new THREE.Mesh(geo, mat);
      const wGeo = new THREE.WireframeGeometry(geo);
      const wMat = new THREE.LineBasicMaterial({ color: shellWireColors[si], transparent: true, opacity: shellWireOpacities[si] });
      const wire = new THREE.LineSegments(wGeo, wMat);
      sphereGroup.add(mesh);
      sphereGroup.add(wire);
      shells.push({ geo, mesh, wire, wGeo, radius: r, baseColor: bc });
      shellOrigPositions.push(new Float32Array(geo.attributes.position.array));
    }

    // ---- Flat space reference shells (ghost wireframes, undeformed) ----
    const flatRefGroup = new THREE.Group();
    flatRefGroup.visible = false;
    scene.add(flatRefGroup);
    for (let si = 0; si < shellRadii.length; si++) {
      const r = shellRadii[si];
      const refGeo = new THREE.IcosahedronGeometry(r, shellDetail);
      const refWGeo = new THREE.WireframeGeometry(refGeo);
      const refWMat = new THREE.LineBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.08 });
      const refWire = new THREE.LineSegments(refWGeo, refWMat);
      flatRefGroup.add(refWire);
      refGeo.dispose();  // Only need the wireframe
    }

    function updateSphereShells() {
      for (let si = 0; si < shells.length; si++) {
        const sh = shells[si];
        const bc = sh.baseColor;
        const pos = sh.geo.attributes.position.array;
        const orig = shellOrigPositions[si];
        const col = sh.geo.attributes.color.array;
        const vc = sh.geo.attributes.position.count;
        for (let i = 0; i < vc; i++) {
          const ix = i * 3;
          let ox = orig[ix], oy = orig[ix+1], oz = orig[ix+2];
          let totalPull = 0;
          let px = ox, py = oy, pz = oz;
          for (const m of masses) {
            const dx = ox - m.x, dy = oy, dz = oz - m.z;
            const r = Math.max(Math.sqrt(dx*dx + dy*dy + dz*dz), 0.5);
            // Radial pull: vertices compress inward toward mass (∝ M/r)
            // curvatureScale amplifies the effect for educational clarity
            const pull = m.strength / r * curvatureScale;
            totalPull += m.strength / r;
            px -= (dx / r) * pull;
            py -= (dy / r) * pull;
            pz -= (dz / r) * pull;
          }
          // Clamp: don't let vertices collapse past the mass center
          for (const m of masses) {
            const cdx = px - m.x, cdy = py, cdz = pz - m.z;
            const cr = Math.sqrt(cdx*cdx + cdy*cdy + cdz*cdz);
            if (cr < 0.8) {
              px = m.x + cdx / cr * 0.8;
              py = cdy / cr * 0.8;
              pz = m.z + cdz / cr * 0.8;
            }
          }
          pos[ix] = px; pos[ix+1] = py; pos[ix+2] = pz;
          // Blend from shell's base color toward deep red near masses
          const phi = Math.min(totalPull * 0.08, 0.499);
          const tau = Math.sqrt(1 - 2 * phi);
          col[ix]   = lerp(1.0, bc.r, tau);
          col[ix+1] = lerp(0.1, bc.g, tau);
          col[ix+2] = lerp(0.05, bc.b, tau);
        }
        sh.geo.attributes.position.needsUpdate = true;
        sh.geo.attributes.color.needsUpdate = true;
        sh.geo.computeVertexNormals();
        // Rebuild wireframe
        sh.wire.geometry.dispose();
        sh.wire.geometry = new THREE.WireframeGeometry(sh.geo);
      }
    }

    // ---- Cross-section rings (3 orthogonal planes) ----
    const crossRingsGroup = new THREE.Group();
    crossRingsGroup.visible = false;
    scene.add(crossRingsGroup);
    const RING_PTS = 120;
    const RING_R = 16;
    const ringColors = [0xf59e0b, 0x06b6d4, 0xa855f7]; // XZ, XY, YZ
    const ringLabels = ['XZ (horizontal)', 'XY (vertical)', 'YZ (vertical)'];
    const crossRings = [];

    for (let ri = 0; ri < 3; ri++) {
      const pts = new Float32Array((RING_PTS + 1) * 3);
      const geo = new THREE.BufferGeometry();
      geo.setAttribute('position', new THREE.BufferAttribute(pts, 3));
      const mat = new THREE.LineBasicMaterial({ color: ringColors[ri], transparent: true, opacity: 0.6, linewidth: 2 });
      const line = new THREE.LineLoop(geo, mat);
      crossRingsGroup.add(line);
      crossRings.push({ geo, pts, line });
    }

    function updateCrossRings() {
      if (!showCrossSections || !view3D) { crossRingsGroup.visible = false; return; }
      crossRingsGroup.visible = true;
      for (let ri = 0; ri < 3; ri++) {
        const ring = crossRings[ri];
        const pts = ring.pts;
        for (let i = 0; i <= RING_PTS; i++) {
          const angle = (i / RING_PTS) * Math.PI * 2;
          let x, y, z;
          if (ri === 0) { x = RING_R * Math.cos(angle); y = 0; z = RING_R * Math.sin(angle); }
          else if (ri === 1) { x = RING_R * Math.cos(angle); y = RING_R * Math.sin(angle); z = 0; }
          else { x = 0; y = RING_R * Math.sin(angle); z = RING_R * Math.cos(angle); }
          // Pull toward masses
          for (const m of masses) {
            const dx = x - m.x, dy2 = y, dz = z - m.z;
            const r = Math.max(Math.sqrt(dx*dx + dy2*dy2 + dz*dz), 0.5);
            const pull = m.strength / (r * r) * 3.5;
            x -= (dx / r) * pull;
            y -= (dy2 / r) * pull;
            z -= (dz / r) * pull;
          }
          const ix = i * 3;
          pts[ix] = x; pts[ix+1] = y; pts[ix+2] = z;
        }
        ring.geo.attributes.position.needsUpdate = true;
      }
    }

    // ---- 3D Axis lines and labels ----
    const axisGroup = new THREE.Group();
    axisGroup.visible = false;
    scene.add(axisGroup);
    const AXIS_LEN = 22;
    const axisColors = [0xef4444, 0x22c55e, 0x3b82f6]; // X=red, Y=green, Z=blue
    const axisNames = ['X', 'Y', 'Z'];
    const axisDirs = [
      new THREE.Vector3(1, 0, 0),
      new THREE.Vector3(0, 1, 0),
      new THREE.Vector3(0, 0, 1)
    ];
    for (let ai = 0; ai < 3; ai++) {
      const dir = axisDirs[ai];
      const pts = [
        new THREE.Vector3(-dir.x * AXIS_LEN, -dir.y * AXIS_LEN, -dir.z * AXIS_LEN),
        new THREE.Vector3(dir.x * AXIS_LEN, dir.y * AXIS_LEN, dir.z * AXIS_LEN)
      ];
      const geo = new THREE.BufferGeometry().setFromPoints(pts);
      const mat = new THREE.LineDashedMaterial({ color: axisColors[ai], transparent: true, opacity: 0.5, dashSize: 0.8, gapSize: 0.4 });
      const line = new THREE.Line(geo, mat);
      line.computeLineDistances();
      axisGroup.add(line);
      // Arrowhead cone at positive end
      const coneGeo = new THREE.ConeGeometry(0.4, 1.2, 8);
      const coneMat = new THREE.MeshBasicMaterial({ color: axisColors[ai], transparent: true, opacity: 0.6 });
      const cone = new THREE.Mesh(coneGeo, coneMat);
      cone.position.set(dir.x * AXIS_LEN, dir.y * AXIS_LEN, dir.z * AXIS_LEN);
      // Rotate cone to point along axis
      if (ai === 0) cone.rotation.z = -Math.PI / 2; // X axis
      else if (ai === 2) cone.rotation.x = Math.PI / 2; // Z axis
      // Y axis: default cone orientation is fine
      axisGroup.add(cone);
    }

    function updateAxisLabels() {
      if (!view3D) return;
      var lc = document.getElementById('curv-labels');
      if (!lc) return;
      for (var ai = 0; ai < 3; ai++) {
        var dir = axisDirs[ai];
        var pos3 = new THREE.Vector3(dir.x * (AXIS_LEN + 2.5), dir.y * (AXIS_LEN + 2.5), dir.z * (AXIS_LEN + 2.5));
        var v = pos3.clone().project(camera);
        if (v.z > 1) continue;
        var cx = (v.x * 0.5 + 0.5) * container.clientWidth;
        var cy = (-v.y * 0.5 + 0.5) * container.clientHeight;
        var el = document.createElement('div');
        el.textContent = axisNames[ai];
        var hex = '#' + axisColors[ai].toString(16).padStart(6, '0');
        el.style.cssText = 'position:absolute;left:' + cx + 'px;top:' + cy + 'px;transform:translate(-50%,-50%);color:' + hex + ';font-size:16px;font-weight:bold;font-family:monospace;pointer-events:none;text-shadow:0 0 8px ' + hex + ',0 0 15px rgba(0,0,0,0.9);';
        lc.appendChild(el);
      }
    }

    // ---- Grid deformation ----
    function updateGrid() {
      const pos = gridGeo.attributes.position.array;
      const col = gridGeo.attributes.color.array;
      for (let i = 0; i < vertCount; i++) {
        const ix = i * 3;
        const vx = origPos[ix], vz = origPos[ix + 2];
        let dy = 0, totalPot = 0;
        for (const m of masses) {
          const dx = vx - m.x, dz = vz - m.z;
          const r = Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
          dy -= m.strength / r * 1.5;
          totalPot += m.strength / r;
        }
        dy = Math.max(dy, -25);
        pos[ix + 1] = dy;
        // Color: time dilation τ = sqrt(1 - 2Φ), Φ normalized
        const phi = Math.min(totalPot * 0.08, 0.499);
        const tau = Math.sqrt(1 - 2 * phi);
        col[ix]     = lerp(1.0, 0.15, tau);
        col[ix + 1] = lerp(0.12, 0.35, tau);
        col[ix + 2] = lerp(0.05, 1.0, tau);
      }
      gridGeo.attributes.position.needsUpdate = true;
      gridGeo.attributes.color.needsUpdate = true;
      gridGeo.computeVertexNormals();
    }

    // ---- Mass management ----
    function addMass(x, z, strength, isBlackHole, options) {
      if (masses.length >= MAX_MASSES) return;
      const opts = options || {};
      const radius = opts.radius || Math.max(0.3, 0.25 + Math.pow(strength, 0.6) * 0.25);
      const bodyColor = opts.color || (isBlackHole ? 0x000000 : 0xf59e0b);
      const emissiveColor = opts.emissive || (isBlackHole ? 0x110000 : bodyColor);
      const sGeo = new THREE.SphereGeometry(radius, 20, 20);
      const sMat = new THREE.MeshPhongMaterial({
        color: bodyColor,
        emissive: emissiveColor,
        emissiveIntensity: isBlackHole ? 0.1 : 0.35,
        transparent: true, opacity: 0.9
      });
      const sphere = new THREE.Mesh(sGeo, sMat);
      // Glow
      const glowColor = isBlackHole ? 0xef4444 : bodyColor;
      const gGeo = new THREE.SphereGeometry(radius * 2.2, 16, 16);
      const gMat = new THREE.MeshBasicMaterial({
        color: glowColor,
        transparent: true, opacity: 0.12
      });
      const glow = new THREE.Mesh(gGeo, gMat);
      const mass = {
        x, z, strength, mesh: sphere, glowMesh: glow, extras: [],
        dynamic: opts.dynamic || false,
        vx: opts.vx || 0, vz: opts.vz || 0,
        label: opts.label || null,
        bodyColor: bodyColor,
        trail: null, trailGeo: null, trailPos: null, trailIdx: 0
      };
      // Dynamic mass trail
      if (opts.dynamic) {
        mass.trailPos = new Float32Array(TRAIL_LEN * 3);
        var initY = gridYAt(x, z);
        for (var ti = 0; ti < TRAIL_LEN; ti++) {
          mass.trailPos[ti*3] = x; mass.trailPos[ti*3+1] = initY; mass.trailPos[ti*3+2] = z;
        }
        var tGeo = new THREE.BufferGeometry();
        tGeo.setAttribute('position', new THREE.BufferAttribute(mass.trailPos, 3));
        var tMat = new THREE.LineBasicMaterial({ color: bodyColor, transparent: true, opacity: 0.4 });
        mass.trail = new THREE.Line(tGeo, tMat);
        mass.trailGeo = tGeo;
        if (showTrails) mass.trail.visible = true;
        massGroup.add(mass.trail);
      }
      // Black hole accretion ring
      if (isBlackHole) {
        const ringGeo = new THREE.TorusGeometry(radius * 2.5, 0.2, 8, 32);
        ringGeo.rotateX(Math.PI / 2);
        const ringMat = new THREE.MeshBasicMaterial({ color: 0xf59e0b, transparent: true, opacity: 0.5 });
        const ring = new THREE.Mesh(ringGeo, ringMat);
        mass.extras.push(ring);
        massGroup.add(ring);
      }
      masses.push(mass);
      massGroup.add(sphere);
      massGroup.add(glow);
      updateGrid();
      updateMassPositions();
      updateReadouts();
    }

    function updateMassPositions() {
      for (const mass of masses) {
        let dy = 0;
        if (!view3D) {
          // 2D mode: masses sit on the deformed surface
          for (const m of masses) {
            const dx = mass.x - m.x, dz = mass.z - m.z;
            const r = Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
            dy -= m.strength / r;
          }
          dy = Math.max(dy, -25);
        }
        // 3D mode: masses stay at Y=0 (center of spherical shells)
        mass.mesh.position.set(mass.x, dy, mass.z);
        mass.glowMesh.position.set(mass.x, dy, mass.z);
        for (const e of mass.extras) e.position.set(mass.x, dy, mass.z);
      }
    }

    function clearMasses() {
      for (const m of masses) {
        massGroup.remove(m.mesh); massGroup.remove(m.glowMesh);
        m.mesh.geometry.dispose(); m.mesh.material.dispose();
        m.glowMesh.geometry.dispose(); m.glowMesh.material.dispose();
        for (const e of m.extras) {
          massGroup.remove(e); e.geometry.dispose(); e.material.dispose();
        }
        if (m.trail) {
          massGroup.remove(m.trail); m.trailGeo.dispose(); m.trail.material.dispose();
        }
      }
      masses.length = 0;
      followTarget = null;
      updateGrid();
      updateReadouts();
    }

    // ---- Helpers ----
    function potentialAt(x, z) {
      let pot = 0;
      for (const m of masses) {
        const dx = x - m.x, dz = z - m.z;
        pot += m.strength / Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
      }
      return pot;
    }

    function nearestMass(x, z) {
      let best = null, bd = Infinity;
      for (const m of masses) {
        const d = Math.sqrt((x - m.x) ** 2 + (z - m.z) ** 2);
        if (d < bd) { bd = d; best = m; }
      }
      return best;
    }

    function gridYAt(x, z) {
      let dy = 0;
      for (const m of masses) {
        const dx = x - m.x, dz = z - m.z;
        dy -= m.strength / Math.max(Math.sqrt(dx * dx + dz * dz), 0.3);
      }
      return Math.max(dy, -18);
    }

    // ---- Particle system ----
    var initialEnergy = null; // For energy conservation tracking

    function addParticle(px, py_in, pz, vx, vy_in, vz, color, label) {
      if (particles.length >= MAX_PARTICLES) removeParticle(0);
      const c = color || 0x06b6d4;
      const geo = new THREE.SphereGeometry(0.3, 10, 10);
      const mat = new THREE.MeshBasicMaterial({ color: c });
      const mesh = new THREE.Mesh(geo, mat);
      const gGeo = new THREE.SphereGeometry(0.6, 8, 8);
      const gMat = new THREE.MeshBasicMaterial({ color: c, transparent: true, opacity: 0.2 });
      const glowMesh = new THREE.Mesh(gGeo, gMat);
      const trailPos = new Float32Array(TRAIL_LEN * 3);
      const py = view3D ? (py_in || 0) : gridYAt(px, pz) + 0.35;
      const vy = view3D ? (vy_in || 0) : 0;
      for (let i = 0; i < TRAIL_LEN; i++) {
        trailPos[i*3] = px; trailPos[i*3+1] = py; trailPos[i*3+2] = pz;
      }
      const tGeo = new THREE.BufferGeometry();
      tGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
      const tMat = new THREE.LineBasicMaterial({ color: c, transparent: true, opacity: 0.55 });
      const trail = new THREE.Line(tGeo, tMat);
      trail.visible = showTrails;
      const p = {
        x: px, y: py, z: pz,
        vx: vx, vy: vy, vz: vz,
        mesh, glowMesh, trail, trailGeo: tGeo, trailPos,
        trailIdx: 0, totalAngle: 0, lastAngle: null,
        orbitTimer: 0, alive: true, startX: px, startY: py, startZ: pz,
        label: label || null
      };
      particles.push(p);
      particleGroup.add(mesh); particleGroup.add(glowMesh); particleGroup.add(trail);
      initialEnergy = computeTotalEnergy();
      updateReadouts();
    }

    function rainParticles() {
      clearParticles();
      if (masses.length === 0) return;
      const m = masses[0];
      const dist = 12;
      const dirs = [
        [dist,0,0], [-dist,0,0], [0,dist,0], [0,-dist,0], [0,0,dist], [0,0,-dist]
      ];
      const rainColors = [0xef4444, 0x3b82f6, 0x22c55e, 0xf59e0b, 0xa855f7, 0x06b6d4];
      dirs.forEach((d, i) => {
        addParticle(m.x + d[0], d[1], m.z + d[2], 0, 0, 0, rainColors[i]);
      });
    }

    function removeParticle(i) {
      const p = particles[i];
      particleGroup.remove(p.mesh); particleGroup.remove(p.glowMesh); particleGroup.remove(p.trail);
      p.mesh.geometry.dispose(); p.mesh.material.dispose();
      p.glowMesh.geometry.dispose(); p.glowMesh.material.dispose();
      p.trailGeo.dispose(); p.trail.material.dispose();
      particles.splice(i, 1);
    }

    function clearParticles() {
      while (particles.length > 0) removeParticle(0);
      updateReadouts();
    }

    // Compute gravitational acceleration at position (px, py, pz)
    function gravAccel(px, py, pz) {
      var ax = 0, ay = 0, az = 0;
      for (var i = 0; i < masses.length; i++) {
        var m = masses[i];
        var dx = px - m.x;
        var dy = view3D ? py : 0;
        var dz = pz - m.z;
        var r2 = dx * dx + dy * dy + dz * dz;
        var r = Math.sqrt(r2);
        if (r < 0.15) r = 0.15; // soft minimum to prevent singularity
        var f = m.strength / (r * r * r); // GM/r³
        ax -= f * dx;
        if (view3D) ay -= f * dy;
        az -= f * dz;
      }
      return { x: ax, y: ay, z: az };
    }

    // Compute total energy (kinetic + potential) for conservation check
    function computeTotalEnergy() {
      var E = 0;
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        if (!p.alive) continue;
        // Kinetic: ½v²
        E += 0.5 * (p.vx * p.vx + p.vy * p.vy + p.vz * p.vz);
        // Potential: -strength/r for each mass
        for (var j = 0; j < masses.length; j++) {
          var m = masses[j];
          var dx = p.x - m.x;
          var dy = view3D ? p.y : 0;
          var dz = p.z - m.z;
          var r = Math.sqrt(dx * dx + dy * dy + dz * dz);
          if (r < 0.15) r = 0.15;
          E -= m.strength / r;
        }
      }
      return E;
    }

    // Velocity-Verlet integrator with fixed sub-steps
    var PHYSICS_DT = 0.004; // Fixed sub-step size (small = accurate)

    function stepParticles(dt) {
      var remaining = dt;
      while (remaining > 1e-8) {
        var h = Math.min(remaining, PHYSICS_DT);
        for (var i = 0; i < particles.length; i++) {
          var p = particles[i];
          if (!p.alive) continue;

          // 1. Compute acceleration at current position
          var a1 = gravAccel(p.x, p.y, p.z);

          // 2. Half-step velocity
          p.vx += 0.5 * a1.x * h;
          if (view3D) p.vy += 0.5 * a1.y * h;
          p.vz += 0.5 * a1.z * h;

          // 3. Full-step position
          p.x += p.vx * h;
          if (view3D) p.y += p.vy * h;
          p.z += p.vz * h;

          // 4. Compute acceleration at new position
          var a2 = gravAccel(p.x, p.y, p.z);

          // 5. Half-step velocity with new acceleration
          p.vx += 0.5 * a2.x * h;
          if (view3D) p.vy += 0.5 * a2.y * h;
          p.vz += 0.5 * a2.z * h;
        }
        remaining -= h;
      }

      // Update visuals, trails, bounds checks
      for (var i = 0; i < particles.length; i++) {
        var p = particles[i];
        if (!p.alive) continue;

        var py = view3D ? p.y : gridYAt(p.x, p.z) + 0.35;
        if (!view3D) p.y = 0; // Keep Y at 0 for physics in 2D mode
        p.mesh.position.set(p.x, py, p.z);
        p.glowMesh.position.set(p.x, py, p.z);

        // Trail (ring buffer → reorder oldest-to-newest for Line rendering)
        p.trailIdx = (p.trailIdx + 1) % TRAIL_LEN;
        if (!p.trailRing) p.trailRing = new Float32Array(TRAIL_LEN * 3);
        var ti = p.trailIdx * 3;
        p.trailRing[ti] = p.x; p.trailRing[ti + 1] = py; p.trailRing[ti + 2] = p.z;
        // Copy ring buffer in order: oldest (trailIdx+1) → newest (trailIdx)
        var start = (p.trailIdx + 1) % TRAIL_LEN;
        var dst = p.trailPos;
        var src = p.trailRing;
        for (var ri = 0; ri < TRAIL_LEN; ri++) {
          var si = ((start + ri) % TRAIL_LEN) * 3;
          var di = ri * 3;
          dst[di] = src[si]; dst[di+1] = src[si+1]; dst[di+2] = src[si+2];
        }
        p.trailGeo.attributes.position.needsUpdate = true;

        // Orbital angle tracking
        var nm = nearestMass(p.x, p.z);
        if (nm) {
          var angle = Math.atan2(p.z - nm.z, p.x - nm.x);
          if (p.lastAngle !== null) {
            var da = angle - p.lastAngle;
            if (da > Math.PI) da -= 2 * Math.PI;
            if (da < -Math.PI) da += 2 * Math.PI;
            p.totalAngle += Math.abs(da);
          }
          p.lastAngle = angle;
          p.orbitTimer += dt;
        }

        // Kill if out of bounds
        var hg = GRID_SIZE / 2 + 5;
        if (Math.abs(p.x) > hg || Math.abs(p.z) > hg) p.alive = false;
        if (view3D && Math.abs(p.y) > hg) p.alive = false;

        // Kill if absorbed by mass
        for (var j = 0; j < masses.length; j++) {
          var m = masses[j];
          var dy2 = view3D ? p.y * p.y : 0;
          var dr = Math.sqrt((p.x - m.x) * (p.x - m.x) + dy2 + (p.z - m.z) * (p.z - m.z));
          if (dr < 0.2) p.alive = false;
        }
      }
      for (var i = particles.length - 1; i >= 0; i--) {
        if (!particles[i].alive) removeParticle(i);
      }
    }

    // ---- Dynamic mass stepping (velocity-Verlet) ----
    function massAccel(m) {
      var ax = 0, az = 0;
      for (var i = 0; i < masses.length; i++) {
        var other = masses[i];
        if (other === m) continue;
        var dx = m.x - other.x, dz = m.z - other.z;
        var r2 = dx * dx + dz * dz;
        var r = Math.sqrt(r2);
        if (r < 0.3) r = 0.3;
        var r3 = r * r * r;
        ax -= other.strength * dx / r3;
        az -= other.strength * dz / r3;
      }
      return { x: ax, z: az };
    }

    function stepDynamicMasses(dt) {
      var dynMasses = masses.filter(function(m) { return m.dynamic; });
      if (dynMasses.length === 0) return;
      var remaining = dt;
      while (remaining > 1e-8) {
        var h = Math.min(remaining, PHYSICS_DT);
        for (var mi = 0; mi < dynMasses.length; mi++) {
          var m = dynMasses[mi];
          // 1. Acceleration at current position
          var a1 = massAccel(m);
          // 2. Half-step velocity
          m.vx += 0.5 * a1.x * h;
          m.vz += 0.5 * a1.z * h;
          // 3. Full-step position
          m.x += m.vx * h;
          m.z += m.vz * h;
          // 4. Acceleration at new position
          var a2 = massAccel(m);
          // 5. Half-step velocity with new acceleration
          m.vx += 0.5 * a2.x * h;
          m.vz += 0.5 * a2.z * h;
        }
        remaining -= h;
      }
      // Update trails
      for (var mi = 0; mi < dynMasses.length; mi++) {
        var m = dynMasses[mi];
        if (m.trail && m.trailPos) {
          m.trailIdx = (m.trailIdx + 1) % TRAIL_LEN;
          var ti = m.trailIdx * 3;
          var my = view3D ? 0 : gridYAt(m.x, m.z);
          if (!m.trailRing) m.trailRing = new Float32Array(TRAIL_LEN * 3);
          m.trailRing[ti] = m.x; m.trailRing[ti + 1] = my; m.trailRing[ti + 2] = m.z;
          // Copy ring buffer in order: oldest → newest
          var start = (m.trailIdx + 1) % TRAIL_LEN;
          var dst = m.trailPos, src = m.trailRing;
          for (var ri = 0; ri < TRAIL_LEN; ri++) {
            var si = ((start + ri) % TRAIL_LEN) * 3;
            var di = ri * 3;
            dst[di] = src[si]; dst[di+1] = src[si+1]; dst[di+2] = src[si+2];
          }
          m.trailGeo.attributes.position.needsUpdate = true;
        }
      }
      updateGrid();
      updateMassPositions();
    }

    // ---- Labels overlay ----
    var labelContainer = document.getElementById('curv-labels');
    function updateLabels() {
      labelContainer.innerHTML = '';
      var allBodies = [];
      for (var i = 0; i < masses.length; i++) {
        var m = masses[i];
        if (m.label) allBodies.push({ pos: m.mesh.position, label: m.label, color: m.bodyColor });
      }
      for (var j = 0; j < particles.length; j++) {
        var p = particles[j];
        if (p.label) allBodies.push({ pos: p.mesh.position, label: p.label, color: p.mesh.material.color.getHex() });
      }
      for (var k = 0; k < allBodies.length; k++) {
        var body = allBodies[k];
        var v = body.pos.clone().project(camera);
        if (v.z > 1) continue;
        var cx = (v.x * 0.5 + 0.5) * container.clientWidth;
        var cy = (-v.y * 0.5 + 0.5) * container.clientHeight;
        var el = document.createElement('div');
        el.textContent = body.label;
        var hex = '#' + (body.color || 0xffffff).toString(16).padStart(6, '0');
        el.style.cssText = 'position:absolute;left:' + cx + 'px;top:' + (cy - 22) + 'px;transform:translateX(-50%);color:' + hex + ';font-size:0.75rem;font-weight:600;text-shadow:0 0 6px rgba(0,0,0,0.9);white-space:nowrap;';
        labelContainer.appendChild(el);
      }
      // Add axis labels in 3D mode
      if (view3D) updateAxisLabels();
    }

    // ---- Force vectors ----
    var forceGroup = new THREE.Group();
    scene.add(forceGroup);

    // ---- Animated force field (flowing arrows toward masses) ----
    var fieldArrowGeo = new THREE.ConeGeometry(0.12, 0.4, 4);
    fieldArrowGeo.rotateX(Math.PI / 2);  // point along +Z so lookAt(mass) aims tip toward mass
    var FIELD_POOL_SIZE = 600;
    var fieldArrows = [];
    var fieldExtraObjects = [];  // ArrowHelpers for per-object force vectors
    var fieldPhase = 0;

    // Pre-create arrow pool
    for (var _fai = 0; _fai < FIELD_POOL_SIZE; _fai++) {
      var _fmat = new THREE.MeshBasicMaterial({ color: 0xff4444, transparent: true, opacity: 0.3, depthWrite: false });
      var _farrow = new THREE.Mesh(fieldArrowGeo, _fmat);
      _farrow.visible = false;
      forceGroup.add(_farrow);
      fieldArrows.push(_farrow);
    }

    function clearForceVectors() {
      // Hide all pooled arrows
      for (var i = 0; i < fieldArrows.length; i++) fieldArrows[i].visible = false;
      // Remove and dispose extra objects (ArrowHelpers for per-object vectors)
      for (var j = 0; j < fieldExtraObjects.length; j++) {
        var obj = fieldExtraObjects[j];
        forceGroup.remove(obj);
        if (obj.line) { obj.line.material.dispose(); obj.line.geometry.dispose(); }
        if (obj.cone) { obj.cone.material.dispose(); obj.cone.geometry.dispose(); }
      }
      fieldExtraObjects.length = 0;
    }

    function updateForceVectors() {
      clearForceVectors();
      if (!showForces || masses.length === 0) return;
      fieldPhase += 0.02;

      var ai = 0;  // arrow index into pool
      var layerRadii = [3, 6, 9, 13, 18];
      var goldenAngle = Math.PI * (1 + Math.sqrt(5));

      for (var mi = 0; mi < masses.length; mi++) {
        var m = masses[mi];
        var mx = m.x, my = view3D ? 0 : gridYAt(m.x, m.z), mz = m.z;

        for (var li = 0; li < layerRadii.length; li++) {
          var baseR = layerRadii[li];
          var arrowsInLayer = 8 + li * 4;  // 8, 12, 16, 20, 24

          for (var aj = 0; aj < arrowsInLayer && ai < FIELD_POOL_SIZE; aj++) {
            // Fibonacci sphere distribution
            var phi = Math.acos(1 - 2 * (aj + 0.5) / arrowsInLayer);
            var theta = goldenAngle * aj;

            // Flow animation: arrow slides inward over time
            var flowSpeed = 0.3 + m.strength * 0.5 / (baseR * baseR);
            var phase = (fieldPhase * flowSpeed + aj * 0.37 + mi * 1.7) % 1.0;
            // Flow from outer edge (phase=0) to inner (phase=1) within layer band
            var rMin = baseR * 0.4, rMax = baseR * 1.0;
            var r = rMax - (rMax - rMin) * phase;

            var sx = Math.sin(phi) * Math.cos(theta);
            var sy = Math.sin(phi) * Math.sin(theta);
            var sz = Math.cos(phi);

            var px = mx + sx * r;
            var py2 = view3D ? (my + sy * r) : (my + 0.3);
            var pz = mz + sz * r;

            // Distance-based appearance (0=close/strong, 1=far/weak)
            var distNorm = Math.min(1, r / 20);
            var strength01 = 1 - distNorm;

            var arrow = fieldArrows[ai++];
            arrow.visible = true;
            arrow.position.set(px, py2, pz);
            arrow.lookAt(mx, my, mz);

            // Color: deep red (close) → pale red (far)
            var cr = 0.8 + 0.2 * strength01;
            var cg = 0.15 + 0.35 * (1 - strength01);
            var cb = 0.1 + 0.3 * (1 - strength01);
            arrow.material.color.setRGB(cr, cg, cb);

            // Opacity: bright close, dim far, with phase fade-in/out
            var phaseFade = 1 - Math.abs(phase - 0.5) * 2;
            arrow.material.opacity = (0.1 + strength01 * 0.5) * (0.3 + 0.7 * phaseFade);

            // Scale: larger close, smaller far
            var s = 0.3 + strength01 * 0.7;
            arrow.scale.set(s, s, s);
          }
        }
      }

      // Hide remaining unused arrows
      for (; ai < FIELD_POOL_SIZE; ai++) fieldArrows[ai].visible = false;

      // ---- Per-object force vectors (bright yellow arrows on particles) ----
      for (var pi = 0; pi < particles.length; pi++) {
        var p = particles[pi];
        if (!p.alive) continue;
        var ppy = view3D ? p.y : gridYAt(p.x, p.z) + 0.5;
        var netFx = 0, netFy = 0, netFz = 0;
        for (var mj = 0; mj < masses.length; mj++) {
          var mm = masses[mj];
          var dx = p.x - mm.x, dy = ppy - (view3D ? 0 : gridYAt(mm.x, mm.z)), dz = p.z - mm.z;
          var dr = Math.max(Math.sqrt(dx*dx + dy*dy + dz*dz), 0.2);
          var fMag = mm.strength / (dr * dr);
          netFx -= fMag * dx / dr; netFy -= fMag * dy / dr; netFz -= fMag * dz / dr;
        }
        var netMag = Math.sqrt(netFx*netFx + netFy*netFy + netFz*netFz);
        if (netMag < 0.001) continue;
        var dir = new THREE.Vector3(netFx/netMag, netFy/netMag, netFz/netMag);
        var origin = new THREE.Vector3(p.x, ppy, p.z);
        var arrowLen = Math.min(4, 0.5 + netMag * 3);
        var forceArrow = new THREE.ArrowHelper(dir, origin, arrowLen, 0xef4444, 0.3, 0.2);
        forceArrow.line.material.transparent = true;
        forceArrow.line.material.opacity = 0.9;
        forceArrow.cone.material.transparent = true;
        forceArrow.cone.material.opacity = 0.9;
        forceGroup.add(forceArrow);
        fieldExtraObjects.push(forceArrow);
      }

      // Per-object force vectors for dynamic masses
      for (var di = 0; di < masses.length; di++) {
        var dm = masses[di];
        if (!dm.dynamic) continue;
        var dmy = view3D ? 0 : gridYAt(dm.x, dm.z);
        var dnFx = 0, dnFy = 0, dnFz = 0;
        for (var dk = 0; dk < masses.length; dk++) {
          if (dk === di) continue;
          var om = masses[dk];
          var ddx = dm.x - om.x, ddy = dmy - (view3D ? 0 : gridYAt(om.x, om.z)), ddz = dm.z - om.z;
          var ddr = Math.max(Math.sqrt(ddx*ddx + ddy*ddy + ddz*ddz), 0.2);
          var dfMag = om.strength / (ddr * ddr);
          dnFx -= dfMag * ddx / ddr; dnFy -= dfMag * ddy / ddr; dnFz -= dfMag * ddz / ddr;
        }
        var dnMag = Math.sqrt(dnFx*dnFx + dnFy*dnFy + dnFz*dnFz);
        if (dnMag < 0.001) continue;
        var ddir = new THREE.Vector3(dnFx/dnMag, dnFy/dnMag, dnFz/dnMag);
        var dorigin = new THREE.Vector3(dm.x, dmy, dm.z);
        var darrowLen = Math.min(4, 0.5 + dnMag * 3);
        var dArrow = new THREE.ArrowHelper(ddir, dorigin, darrowLen, 0xef4444, 0.3, 0.2);
        dArrow.line.material.transparent = true;
        dArrow.line.material.opacity = 0.9;
        dArrow.cone.material.transparent = true;
        dArrow.cone.material.opacity = 0.9;
        forceGroup.add(dArrow);
        fieldExtraObjects.push(dArrow);
      }
    }

    // ---- Presets ----
    const PRESETS = {
      earth:     [{ x: 0, z: 0, strength: 1.5, bh: false, label: 'Earth', color: 0x3b82f6 }],
      sun:       [{ x: 0, z: 0, strength: 5.0, bh: false, label: 'Sun', color: 0xf59e0b }],
      blackhole: [{ x: 0, z: 0, strength: 15.0, bh: true, label: 'Black Hole', color: 0x000000 }],
      binary:    [{ x: -5, z: 0, strength: 4.0, bh: false, label: 'Star A', color: 0xf59e0b }, { x: 5, z: 0, strength: 4.0, bh: false, label: 'Star B', color: 0xef4444 }]
    };

    function loadPreset(name) {
      clearMasses(); clearParticles();
      simElapsed = 0; initialEnergy = null;
      const preset = PRESETS[name];
      if (!preset) return;
      for (const p of preset) addMass(p.x, p.z, p.strength, p.bh, { label: p.label, color: p.color });
      document.getElementById('curv-mass-slider').value = preset[0].strength * 10;
      document.getElementById('curv-mass-label').textContent = preset[0].strength.toFixed(1);
    }

    // ---- Cross-section ----
    const csPoints = [];
    for (let i = 0; i < n; i++) csPoints.push(new THREE.Vector3(0, 0, 0));
    const csGeo = new THREE.BufferGeometry().setFromPoints(csPoints);
    const csLine = new THREE.Line(csGeo, new THREE.LineBasicMaterial({ color: 0xf59e0b, linewidth: 2 }));
    csLine.visible = false;
    scene.add(csLine);

    function updateCrossSection() {
      if (!crossSectionMode) { csLine.visible = false; return; }
      csLine.visible = true;
      const pos = gridGeo.attributes.position.array;
      const lp = csGeo.attributes.position.array;
      const mid = Math.floor(n / 2);
      for (let i = 0; i < n; i++) {
        const idx = (mid * n + i) * 3;
        lp[i * 3] = pos[idx]; lp[i * 3 + 1] = pos[idx + 1]; lp[i * 3 + 2] = pos[idx + 2];
      }
      csGeo.attributes.position.needsUpdate = true;
    }

    // ---- Geodesic straightness ----
    function updateStraightnessVis() {
      while (straightGroup.children.length > 0) {
        const ch = straightGroup.children[0];
        straightGroup.remove(ch);
        if (ch.geometry) ch.geometry.dispose();
        if (ch.material) ch.material.dispose();
      }
      if (!showStraightness || particles.length === 0) return;
      for (const p of particles) {
        // Flat-space straight line
        const sy = view3D ? (p.startY || 0) : 0.15;
        const ey = view3D ? p.y : 0.15;
        const flatGeo = new THREE.BufferGeometry().setFromPoints([
          new THREE.Vector3(p.startX, sy, p.startZ),
          new THREE.Vector3(p.x, ey, p.z)
        ]);
        const flatMat = new THREE.LineDashedMaterial({
          color: 0xef4444, dashSize: 0.5, gapSize: 0.3, transparent: true, opacity: 0.6
        });
        const flatLine = new THREE.Line(flatGeo, flatMat);
        flatLine.computeLineDistances();
        straightGroup.add(flatLine);
        // Geodesic highlight (trail on curved surface)
        const geoPoints = [];
        for (let i = 0; i < TRAIL_LEN; i++) {
          const idx = i * 3;  // trailPos is already ordered oldest→newest
          geoPoints.push(new THREE.Vector3(
            p.trailPos[idx], p.trailPos[idx + 1] + 0.15, p.trailPos[idx + 2]
          ));
        }
        const geodGeo = new THREE.BufferGeometry().setFromPoints(geoPoints);
        const geodMat = new THREE.LineBasicMaterial({ color: 0x22c55e, transparent: true, opacity: 0.6 });
        straightGroup.add(new THREE.Line(geodGeo, geodMat));
      }
    }

    // ---- Raycasting ----
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    const gridPlane = new THREE.Plane(new THREE.Vector3(0, 1, 0), 0);

    container.addEventListener('mousedown', (e) => {
      mouseDownPos = { x: e.clientX, y: e.clientY };
    });

    container.addEventListener('click', (e) => {
      // Camera mode: do nothing (OrbitControls handles interaction)
      if (currentMode === 'camera') return;
      if (currentMode === 'rain') { rainParticles(); return; }
      // Ignore drags (OrbitControls)
      if (mouseDownPos) {
        const dx = e.clientX - mouseDownPos.x, dy = e.clientY - mouseDownPos.y;
        if (dx * dx + dy * dy > 25) return;
      }
      const rect = container.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = new THREE.Vector3();
      if (!raycaster.ray.intersectPlane(gridPlane, hit)) return;
      const hg = GRID_SIZE / 2;
      const ix = clamp(hit.x, -hg, hg), iz = clamp(hit.z, -hg, hg);

      if (currentMode === 'place') {
        const str = parseFloat(document.getElementById('curv-mass-slider').value) / 10;
        addMass(ix, iz, str, false);
        if (view3D) { updateSphereShells(); updateCrossRings(); }
      } else if (currentMode === 'drop') {
        const py = view3D ? 12 : 0;
        addParticle(ix, py, iz, 0, 0, 0);
      } else if (currentMode === 'orbit' || currentMode === 'orbits') {
        const speed = parseFloat(document.getElementById('curv-launch-speed').value) / 100;
        const inclDeg = parseFloat(document.getElementById('curv-inclination').value);
        const incl = inclDeg * Math.PI / 180;
        const nm = nearestMass(ix, iz);
        if (nm) {
          const dx = ix - nm.x, dz = iz - nm.z;
          const d = Math.max(Math.sqrt(dx * dx + dz * dz), 0.1);
          const vCirc = Math.sqrt(nm.strength / d);
          const spd = speed * 2 * vCirc;
          const ci = Math.cos(incl), si = Math.sin(incl);
          const hx = -dz / d, hz = dx / d;
          addParticle(ix, 0, iz, hx * spd * ci, spd * si, hz * spd * ci);
        } else {
          addParticle(ix, 0, iz, speed * 2, 0, 0);
        }
      }
    });

    // Tooltip on hover
    container.addEventListener('mousemove', (e) => {
      const rect = container.getBoundingClientRect();
      mouse.x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((e.clientY - rect.top) / rect.height) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      const hit = new THREE.Vector3();
      if (raycaster.ray.intersectPlane(gridPlane, hit)) {
        const pot = potentialAt(hit.x, hit.z);
        const phi = Math.min(pot * 0.08, 0.499);
        const tau = Math.sqrt(Math.max(0, 1 - 2 * phi));
        const tip = document.getElementById('curv-tooltip');
        if (masses.length > 0) {
          tip.style.display = 'block';
          document.getElementById('curv-tip-potential').textContent = pot.toFixed(3);
          document.getElementById('curv-tip-dilation').textContent = tau.toFixed(4);
          document.getElementById('curv-dilation').textContent = tau.toFixed(4);
        } else {
          tip.style.display = 'none';
        }
      }
    });
    container.addEventListener('mouseleave', () => {
      document.getElementById('curv-tooltip').style.display = 'none';
    });

    // ---- Controls wiring ----
    // ---- Mode system (camera is default — no accidental placement) ----
    var modeMap = { 'curv-mode-place': 'place', 'curv-mode-drop': 'drop', 'curv-mode-orbit': 'orbit', 'curv-mode-rain': 'rain', 'curv-mode-orbits': 'orbits' };
    var modeIds = Object.keys(modeMap);
    var allModeIds = ['curv-mode-camera'].concat(modeIds);

    function setMode(mode) {
      currentMode = mode;
      // Update button active states
      allModeIds.forEach(function(bid) {
        var el = document.getElementById(bid);
        if (el) el.classList.toggle('active', bid === 'curv-mode-' + mode);
      });
      // Inclination slider for orbit modes
      document.getElementById('curv-inclination-group').style.display = (mode === 'orbit' || mode === 'orbits') ? 'block' : 'none';
      // Orbital presets for orbits mode
      document.getElementById('curv-orbit-presets').style.display = mode === 'orbits' ? 'flex' : 'none';
      if (mode !== 'orbits') {
        document.getElementById('curv-orbit-info').style.display = 'none';
        document.getElementById('curv-orbit-info').textContent = '';
      }
      // Cursor
      if (mode === 'camera' || mode === 'rain') {
        container.style.cursor = 'grab';
      } else {
        container.style.cursor = mode === 'place' ? 'crosshair' : mode === 'drop' ? 'pointer' : 'cell';
      }
      // Rain fires immediately
      if (mode === 'rain') { rainParticles(); setMode('camera'); return; }
      // Mode indicator
      updateModeIndicator();
    }

    function updateModeIndicator() {
      var el = document.getElementById('curv-mode-indicator');
      if (!el) return;
      var labels = { camera: 'Camera Controls', place: 'Click to Place Mass', drop: 'Click to Drop Particle', orbit: 'Click to Launch Orbit', orbits: 'Click to Launch Orbital Plane' };
      var colors = { camera: '#22c55e', place: '#f59e0b', drop: '#3b82f6', orbit: '#8b5cf6', orbits: '#8b5cf6' };
      el.textContent = labels[currentMode] || 'Camera Controls';
      el.style.color = colors[currentMode] || '#22c55e';
      el.style.borderColor = colors[currentMode] || '#22c55e';
      // Container border glow for placement modes
      if (currentMode !== 'camera') {
        container.style.boxShadow = 'inset 0 0 20px ' + (colors[currentMode] || '#f59e0b') + '33';
      } else {
        container.style.boxShadow = 'none';
      }
    }

    // Camera button
    document.getElementById('curv-mode-camera').addEventListener('click', function() { setMode('camera'); });

    // Action mode buttons — clicking an active mode toggles back to camera
    Object.entries(modeMap).forEach(function(entry) {
      var id = entry[0], mode = entry[1];
      document.getElementById(id).addEventListener('click', function() {
        if (currentMode === mode) { setMode('camera'); }
        else { setMode(mode); }
      });
    });

    // ---- Presets ----
    ['earth', 'sun', 'blackhole', 'binary'].forEach(name => {
      const btn = document.getElementById('curv-preset-' + (name === 'blackhole' ? 'bh' : name));
      if (btn) btn.addEventListener('click', () => {
        deactivateAllPresets();
        btn.classList.add('active');
        loadPreset(name);
        setMode('camera');
        if (view3D) { updateSphereShells(); updateCrossRings(); }
      });
    });

    document.getElementById('curv-clear').addEventListener('click', () => {
      clearMasses(); clearParticles();
      document.querySelectorAll('#sec-curvature [data-preset]').forEach(b => b.classList.remove('active'));
      setMode('camera');
      if (view3D) { updateSphereShells(); updateCrossRings(); }
    });

    // ---- Sliders ----
    document.getElementById('curv-mass-slider').addEventListener('input', (e) => {
      document.getElementById('curv-mass-label').textContent = (e.target.value / 10).toFixed(1);
    });
    document.getElementById('curv-launch-speed').addEventListener('input', (e) => {
      document.getElementById('curv-speed-label').innerHTML = (e.target.value / 100 * 2).toFixed(1) + 'x v<sub>circ</sub>';
    });
    document.getElementById('curv-inclination').addEventListener('input', (e) => {
      document.getElementById('curv-incl-label').textContent = e.target.value + '\u00B0';
    });

    // ---- 2D / 3D view toggle ----
    function switchView(to3D) {
      view3D = to3D;
      document.getElementById('curv-view-2d').classList.toggle('active', !to3D);
      document.getElementById('curv-view-3d').classList.toggle('active', to3D);
      // 2D elements
      gridMesh.visible = !to3D && document.getElementById('curv-show-grid').checked;
      wireframe.visible = !to3D && document.getElementById('curv-show-grid').checked;
      csLine.visible = false;
      // 3D elements
      sphereGroup.visible = to3D;
      crossRingsGroup.visible = to3D && showCrossSections;
      axisGroup.visible = to3D;
      flatRefGroup.visible = to3D && showFlatRef;
      var hint3D = document.getElementById('curv-3d-hint');
      if (hint3D) hint3D.style.display = to3D ? 'block' : 'none';
      var shellLeg = document.getElementById('curv-shell-legend');
      if (shellLeg) shellLeg.style.display = to3D ? 'block' : 'none';
      if (to3D) {
        updateSphereShells();
        updateCrossRings();
        updateMassPositions();
        camera.position.set(15, 18, 35);
        controls.target.set(0, 0, 0);
      } else {
        updateMassPositions();
        camera.position.set(0, 28, 38);
        controls.target.set(0, -3, 0);
      }
      clearParticles();
    }
    document.getElementById('curv-view-2d').addEventListener('click', () => switchView(false));
    document.getElementById('curv-view-3d').addEventListener('click', () => switchView(true));

    // ---- Checkboxes ----
    document.getElementById('curv-cross-sections').addEventListener('change', (e) => {
      showCrossSections = e.target.checked;
      crossRingsGroup.visible = view3D && showCrossSections;
    });
    document.getElementById('curv-straightness').addEventListener('change', (e) => {
      showStraightness = e.target.checked;
      if (!showStraightness) {
        while (straightGroup.children.length > 0) {
          const ch = straightGroup.children[0];
          straightGroup.remove(ch);
          if (ch.geometry) ch.geometry.dispose();
          if (ch.material) ch.material.dispose();
        }
      }
    });
    document.getElementById('curv-show-grid').addEventListener('change', (e) => {
      gridMesh.visible = !view3D && e.target.checked;
      wireframe.visible = !view3D && e.target.checked;
    });

    // ---- Readouts ----
    function updateReadouts() {
      document.getElementById('curv-mass-count').textContent = masses.length;
      document.getElementById('curv-particle-count').textContent = particles.length;
      var altEl = document.getElementById('curv-altitude');
      var escEl = document.getElementById('curv-escape-vel');
      if (particles.length > 0) {
        var p = particles[particles.length - 1];
        var spd = Math.sqrt(p.vx * p.vx + (p.vy || 0) * (p.vy || 0) + p.vz * p.vz);
        document.getElementById('curv-particle-vel').textContent = spd.toFixed(3);
        if (p.totalAngle > 2 * Math.PI && p.orbitTimer > 0) {
          var period = p.orbitTimer * (2 * Math.PI) / p.totalAngle;
          document.getElementById('curv-orbit-period').textContent = period.toFixed(2) + 's';
        } else {
          document.getElementById('curv-orbit-period').innerHTML = '&mdash;';
        }
        var nm = nearestMass(p.x, p.z);
        if (nm) {
          var alt = Math.sqrt((p.x - nm.x) * (p.x - nm.x) + (p.z - nm.z) * (p.z - nm.z));
          altEl.textContent = alt.toFixed(2);
          var vEsc = Math.sqrt(2 * nm.strength / Math.max(alt, 0.1));
          escEl.textContent = vEsc.toFixed(3);
        } else {
          altEl.innerHTML = '&mdash;';
          escEl.innerHTML = '&mdash;';
        }
      } else {
        document.getElementById('curv-particle-vel').textContent = '0.000';
        document.getElementById('curv-orbit-period').innerHTML = '&mdash;';
        altEl.innerHTML = '&mdash;';
        escEl.innerHTML = '&mdash;';
      }
      // Elapsed time
      var etEl = document.getElementById('curv-elapsed-time');
      if (etEl) {
        if (simElapsed < 60) etEl.textContent = simElapsed.toFixed(1) + 's';
        else if (simElapsed < 3600) etEl.textContent = (simElapsed / 60).toFixed(1) + ' min';
        else etEl.textContent = (simElapsed / 3600).toFixed(2) + ' hr';
      }
      // Energy conservation drift
      var edEl = document.getElementById('curv-energy-drift');
      if (edEl && particles.length > 0 && initialEnergy !== null && initialEnergy !== 0) {
        var currentE = computeTotalEnergy();
        var drift = Math.abs((currentE - initialEnergy) / initialEnergy) * 100;
        edEl.textContent = drift.toFixed(4) + '%';
        edEl.style.color = drift < 0.01 ? '#22c55e' : drift < 0.1 ? '#f59e0b' : '#ef4444';
      } else if (edEl) {
        edEl.innerHTML = '&mdash;';
        edEl.style.color = '#22c55e';
      }
    }

    // ---- Orbital plane presets ----
    function hslToHex(h, s, l) {
      s /= 100; l /= 100;
      const k = n => (n + h / 30) % 12;
      const a = s * Math.min(l, 1 - l);
      const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
      return (Math.round(f(0) * 255) << 16) + (Math.round(f(8) * 255) << 8) + Math.round(f(4) * 255);
    }

    const orbitalPresets = {
      '3plane': {
        massStrength: 5.0,
        info: 'Three identical orbits in perpendicular planes. Same mass, same distance, same speed \u2014 only the orientation differs. All are equally stable, proving gravity has no preferred direction.',
        orbits: [
          { distance: 8, inclination: 0,              azimuth: 0,            color: 0x06b6d4 },
          { distance: 8, inclination: Math.PI / 2,    azimuth: Math.PI / 2,  color: 0xef4444 },
          { distance: 8, inclination: Math.PI / 4,    azimuth: Math.PI,      color: 0x22c55e },
        ]
      },
      'solar': {
        massStrength: 5.0,
        info: 'Planets orbit mostly near the ecliptic plane, but Pluto\u2019s 17\u00B0 tilt and comets at extreme angles show gravity works identically in every orientation. The ecliptic is not special \u2014 it\u2019s just where the dust happened to settle.',
        orbits: [
          { distance: 6,  inclination: 7    * Math.PI / 180, azimuth: 0,               color: 0x9ca3af },
          { distance: 8,  inclination: 0,                    azimuth: Math.PI / 3,      color: 0x3b82f6 },
          { distance: 10, inclination: 1.85 * Math.PI / 180, azimuth: 2 * Math.PI / 3, color: 0xef4444 },
          { distance: 13, inclination: 17   * Math.PI / 180, azimuth: Math.PI,          color: 0xa855f7 },
          { distance: 15, inclination: 62   * Math.PI / 180, azimuth: 4 * Math.PI / 3, color: 0xf59e0b },
        ]
      },
      'globular': {
        massStrength: 8.0,
        info: 'Stars in a globular cluster orbit in every direction \u2014 no preferred plane. This is gravity\u2019s natural state: truly spherically symmetric. Every orientation is equally valid.',
        orbits: null
      }
    };

    function generateGlobularOrbits() {
      const orbits = [];
      const count = 8;
      const hueStep = 360 / count;
      for (let i = 0; i < count; i++) {
        const t = (i + 0.5) / count;
        const inclination = Math.acos(2 * t - 1);
        const azimuth = i * 2.3998;
        const distance = 7 + (i % 3) * 2.5;
        orbits.push({ distance, inclination, azimuth, color: hslToHex(i * hueStep, 80, 60) });
      }
      return orbits;
    }

    function launchOrbitalPreset(name) {
      const preset = orbitalPresets[name];
      if (!preset) return;
      clearMasses();
      clearParticles();
      addMass(0, 0, preset.massStrength, name === 'globular');
      // Switch to 3D before adding particles (switchView clears particles)
      if (!view3D) switchView(true);
      document.getElementById('curv-mass-slider').value = preset.massStrength * 10;
      document.getElementById('curv-mass-label').textContent = preset.massStrength.toFixed(1);
      document.querySelectorAll('#sec-curvature [data-preset]').forEach(b => b.classList.remove('active'));
      updateSphereShells();
      updateCrossRings();
      const orbits = name === 'globular' ? generateGlobularOrbits() : preset.orbits;
      for (const orb of orbits) {
        const px = orb.distance * Math.cos(orb.azimuth);
        const pz = orb.distance * Math.sin(orb.azimuth);
        const d = orb.distance;
        const hx = -pz / d, hz = px / d;
        const spd = Math.sqrt(preset.massStrength / d);
        const ci = Math.cos(orb.inclination), si = Math.sin(orb.inclination);
        addParticle(px, 0, pz, hx * spd * ci, spd * si, hz * spd * ci, orb.color);
      }
      document.getElementById('curv-orbit-info').textContent = preset.info;
      document.getElementById('curv-orbit-info').style.display = 'block';
    }

    ['3plane', 'solar', 'globular'].forEach(name => {
      document.getElementById('curv-orbpreset-' + name).addEventListener('click', () => {
        document.querySelectorAll('#curv-orbit-presets .tab-btn').forEach(b => b.classList.remove('active'));
        document.getElementById('curv-orbpreset-' + name).classList.add('active');
        launchOrbitalPreset(name);
      });
    });

    // ---- Simulation presets ----
    var SCENARIOS = {
      iss: {
        name: 'ISS Orbiting Earth',
        description: 'ISS orbits at 408 km altitude in ~90 minutes. Scaled to our grid: Earth at center, ISS in circular orbit.',
        setup: function() {
          clearMasses(); clearParticles(); simElapsed = 0;
          addMass(0, 0, 3.0, false, { color: 0x3b82f6, label: 'Earth', radius: 1.2 });
          var d = 6, vCirc = Math.sqrt(3.0 / d);
          addParticle(d, 0, 0, 0, 0, vCirc, 0x06b6d4, 'ISS');
          setSimSpeed(1.0);
        }
      },
      moon: {
        name: 'Moon Orbiting Earth',
        description: 'The Moon orbits Earth at 384,400 km (27.3-day period). Scaled with a larger orbit distance.',
        setup: function() {
          clearMasses(); clearParticles(); simElapsed = 0;
          addMass(0, 0, 2.0, false, { color: 0x3b82f6, label: 'Earth', radius: 1.0 });
          var d = 12, vCirc = Math.sqrt(2.0 / d);
          addParticle(d, 0, 0, 0, 0, vCirc, 0x9ca3af, 'Moon');
          setSimSpeed(1.0);
        }
      },
      earthsun: {
        name: 'Earth Orbiting Sun',
        description: 'Earth orbits the Sun at ~150 million km (1 year period). The Sun contains 99.86% of the solar system\'s mass.',
        setup: function() {
          clearMasses(); clearParticles(); simElapsed = 0;
          addMass(0, 0, 5.0, false, { color: 0xf59e0b, label: 'Sun', radius: 1.5 });
          var d = 10, vCirc = Math.sqrt(5.0 / d);
          addParticle(d, 0, 0, 0, 0, vCirc, 0x3b82f6, 'Earth');
          setSimSpeed(1.0);
        }
      },
      binarystar: {
        name: 'Binary Star System',
        description: 'Two equal-mass stars orbit their common center of mass. Watch the grid deform dynamically as both stars move!',
        setup: function() {
          clearMasses(); clearParticles(); simElapsed = 0;
          var sep = 5, str = 4.0;
          var vOrbit = Math.sqrt(str / (2 * sep));
          addMass(sep, 0, str, false, { color: 0xf59e0b, label: 'Star A', dynamic: true, vx: 0, vz: vOrbit });
          addMass(-sep, 0, str, false, { color: 0xef4444, label: 'Star B', dynamic: true, vx: 0, vz: -vOrbit });
          updateGrid();
          setSimSpeed(1.0);
        }
      },
      figure8: {
        name: 'Figure-8 Three-Body',
        description: 'The famous Chenciner-Montgomery stable 3-body orbit. Three equal masses trace a figure-8 path — incredibly rare and beautiful!',
        setup: function() {
          clearMasses(); clearParticles(); simElapsed = 0;
          var scale = 5.0, str = 3.0;
          var vScale = Math.sqrt(str / scale);
          var vx3 = 0.347111 * vScale, vz3 = 0.532728 * vScale;
          addMass(-scale, 0, str, false, { color: 0xef4444, label: 'A', dynamic: true, vx: vz3, vz: vx3 });
          addMass(scale, 0, str, false, { color: 0x22c55e, label: 'B', dynamic: true, vx: vz3, vz: vx3 });
          addMass(0, 0, str, false, { color: 0x3b82f6, label: 'C', dynamic: true, vx: -2 * vz3, vz: -2 * vx3 });
          updateGrid();
          setSimSpeed(0.5);
        }
      }
    };

    // Logarithmic speed mapping: slider 0-100 → speed 0.1x-10x
    function sliderToSpeed(v) { return 0.1 * Math.pow(100, v / 100); }
    function speedToSlider(s) { return 100 * Math.log(s / 0.1) / Math.log(100); }
    function formatSpeed(s) { return s >= 10 ? Math.round(s) + 'x' : s.toFixed(1) + 'x'; }

    function setSimSpeed(val) {
      simSpeed = val;
      document.getElementById('curv-sim-speed').value = Math.round(speedToSlider(val));
      document.getElementById('curv-sim-speed-label').textContent = formatSpeed(val);
    }

    function deactivateAllPresets() {
      document.querySelectorAll('#sec-curvature [data-preset]').forEach(function(b) { b.classList.remove('active'); });
      document.querySelectorAll('#sec-curvature [data-scenario]').forEach(function(b) { b.classList.remove('active'); });
      document.getElementById('curv-scenario-info').style.display = 'none';
      document.getElementById('curv-orbit-info').style.display = 'none';
    }

    // Wire simulation buttons
    Object.keys(SCENARIOS).forEach(function(name) {
      var btn = document.getElementById('curv-scenario-' + name);
      if (!btn) return;
      btn.addEventListener('click', function() {
        deactivateAllPresets();
        btn.classList.add('active');
        paused = false;
        document.getElementById('curv-pause').textContent = 'Pause';
        document.getElementById('curv-pause').classList.remove('active');
        SCENARIOS[name].setup();
        setMode('camera');
        document.getElementById('curv-scenario-info').textContent = SCENARIOS[name].description;
        document.getElementById('curv-scenario-info').style.display = 'block';
        if (view3D) { updateSphereShells(); updateCrossRings(); }
      });
    });

    // ---- Simulation control wiring ----
    document.getElementById('curv-pause').addEventListener('click', function() {
      paused = !paused;
      document.getElementById('curv-pause').textContent = paused ? 'Play' : 'Pause';
      document.getElementById('curv-pause').classList.toggle('active', paused);
    });

    document.getElementById('curv-step-fwd').addEventListener('click', function() {
      // Step forward one physics frame (0.016s at current sim speed)
      if (!paused) {
        paused = true;
        document.getElementById('curv-pause').textContent = 'Play';
        document.getElementById('curv-pause').classList.add('active');
      }
      var stepDt = 0.016 * simSpeed;
      simElapsed += stepDt;
      var hasDynamic = masses.some(function(m) { return m.dynamic; });
      if (hasDynamic) { stepDynamicMasses(stepDt); if (view3D) { updateSphereShells(); updateCrossRings(); } }
      if (masses.length > 0 && particles.length > 0) stepParticles(stepDt);
      updateReadouts();
    });

    document.getElementById('curv-reset-all').addEventListener('click', function() {
      clearMasses(); clearParticles();
      simElapsed = 0;
      initialEnergy = null;
      paused = false;
      document.getElementById('curv-pause').textContent = 'Pause';
      document.getElementById('curv-pause').classList.remove('active');
      deactivateAllPresets();
      setMode('camera');
      if (view3D) { updateSphereShells(); updateCrossRings(); }
    });

    document.getElementById('curv-sim-speed').addEventListener('input', function(e) {
      simSpeed = sliderToSpeed(parseFloat(e.target.value));
      document.getElementById('curv-sim-speed-label').textContent = formatSpeed(simSpeed);
    });

    // ---- Camera controls ----
    function updateCamButtons() {
      ['top', 'side', 'front', 'free', 'follow'].forEach(function(m) {
        document.getElementById('curv-cam-' + m).classList.toggle('active', cameraMode === m);
      });
    }

    document.getElementById('curv-cam-top').addEventListener('click', function() {
      cameraMode = 'top';
      camera.position.set(0, 50, 0.1);
      controls.target.set(0, 0, 0);
      updateCamButtons();
    });

    document.getElementById('curv-cam-side').addEventListener('click', function() {
      cameraMode = 'side';
      camera.position.set(0, 0, 50);
      controls.target.set(0, 0, 0);
      updateCamButtons();
    });

    document.getElementById('curv-cam-front').addEventListener('click', function() {
      cameraMode = 'front';
      camera.position.set(50, 0, 0);
      controls.target.set(0, 0, 0);
      updateCamButtons();
    });

    document.getElementById('curv-cam-free').addEventListener('click', function() {
      cameraMode = 'free';
      followTarget = null;
      updateCamButtons();
    });

    document.getElementById('curv-cam-follow').addEventListener('click', function() {
      var bodies = particles.slice();
      for (var i = 0; i < masses.length; i++) {
        if (masses[i].dynamic) bodies.push(masses[i]);
      }
      if (bodies.length === 0) return;
      var idx = bodies.indexOf(followTarget);
      followTarget = bodies[(idx + 1) % bodies.length];
      cameraMode = 'follow';
      updateCamButtons();
    });

    // ---- Trail toggle ----
    document.getElementById('curv-show-trails').addEventListener('change', function(e) {
      showTrails = e.target.checked;
      for (var i = 0; i < particles.length; i++) particles[i].trail.visible = showTrails;
      for (var j = 0; j < masses.length; j++) { if (masses[j].trail) masses[j].trail.visible = showTrails; }
    });

    // ---- Force vector toggle ----
    document.getElementById('curv-show-forces').addEventListener('change', function(e) {
      showForces = e.target.checked;
      if (!showForces) clearForceVectors();
    });

    // ---- Flat space reference toggle ----
    document.getElementById('curv-show-flat-ref').addEventListener('change', function(e) {
      showFlatRef = e.target.checked;
      flatRefGroup.visible = showFlatRef && view3D;
    });

    // ---- Curvature strength slider ----
    document.getElementById('curv-warp-slider').addEventListener('input', function(e) {
      curvatureScale = parseFloat(e.target.value) / 2;
      document.getElementById('curv-warp-label').textContent = curvatureScale.toFixed(1);
      if (view3D) { updateSphereShells(); updateCrossRings(); }
    });

    // ---- Fullscreen ----
    function toggleFullscreen() {
      var isFS = container.classList.toggle('curv-fullscreen');
      document.body.style.overflow = isFS ? 'hidden' : '';
      setTimeout(onResize, 50);
    }
    document.getElementById('curv-fullscreen').addEventListener('click', toggleFullscreen);
    document.getElementById('curv-fullscreen-close').addEventListener('click', toggleFullscreen);
    document.addEventListener('keydown', function(e) {
      if (e.key === 'Escape' && container.classList.contains('curv-fullscreen')) toggleFullscreen();
    });

    // ---- Keyboard shortcuts for mode switching ----
    document.addEventListener('keydown', function(e) {
      // Only respond when curvature section is visible (in viewport)
      var sec = document.getElementById('sec-curvature');
      var secRect = sec.getBoundingClientRect();
      if (secRect.bottom < 0 || secRect.top > window.innerHeight) return;
      // Don't intercept when typing in an input
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

      var key = e.key.toLowerCase();
      if (key === 'm') { setMode(currentMode === 'place' ? 'camera' : 'place'); }
      else if (key === 'p') { setMode(currentMode === 'drop' ? 'camera' : 'drop'); }
      else if (key === 'o') { setMode(currentMode === 'orbit' ? 'camera' : 'orbit'); }
      else if (key === 'escape' && currentMode !== 'camera') { setMode('camera'); }
    });

    // ---- Animation loop ----
    let prevTime = null;
    let frameCount = 0;

    function animate(timestamp) {
      requestAnimationFrame(animate);
      if (prevTime === null) prevTime = timestamp;
      const rawDt = Math.min((timestamp - prevTime) / 1000, 0.05);
      prevTime = timestamp;
      const dt = paused ? 0 : rawDt * simSpeed;
      simElapsed += dt;
      frameCount++;

      controls.update();

      // Step dynamic masses (must come before particles — they affect forces)
      var hasDynamic = masses.some(function(m) { return m.dynamic; });
      if (hasDynamic && dt > 0) {
        stepDynamicMasses(dt);
        if (view3D && frameCount % 2 === 0) { updateSphereShells(); updateCrossRings(); }
      }

      // Step particles
      if (masses.length > 0 && particles.length > 0 && dt > 0) stepParticles(dt);

      // Update visuals
      if (view3D) {
        if (!hasDynamic && frameCount % 4 === 0 && masses.length > 0) { updateSphereShells(); updateCrossRings(); }
      } else {
        updateCrossSection();
      }
      if (showStraightness && frameCount % 3 === 0) updateStraightnessVis();

      // Labels
      if (frameCount % 3 === 0) updateLabels();

      // Force vectors
      if (showForces && frameCount % 3 === 0) updateForceVectors();

      // Follow camera
      if (cameraMode === 'follow' && followTarget) {
        var fPos = followTarget.mesh.position;
        controls.target.set(fPos.x, fPos.y, fPos.z);
      }

      // Animate mass glow pulse
      for (const m of masses) {
        m.glowMesh.material.opacity = 0.08 + 0.06 * Math.sin(timestamp * 0.003);
        for (const e of m.extras) {
          e.rotation.z = timestamp * 0.0005;
          e.material.opacity = 0.35 + 0.15 * Math.sin(timestamp * 0.002);
        }
      }

      // Readouts every 6 frames
      if (frameCount % 6 === 0) updateReadouts();

      renderer.render(scene, camera);
    }

    // ---- Show/hide bottom panel when curvature section is in viewport ----
    var curvSection = document.getElementById('sec-curvature');
    var curvObserver = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        curvSection.classList.toggle('curv-section-active', entry.isIntersecting);
      });
    }, { threshold: 0.05 });
    curvObserver.observe(curvSection);

    // ---- Collapsible panel toggles ----
    ['curv-adv', 'curv-help'].forEach(function(prefix) {
      var toggle = document.getElementById(prefix + '-toggle');
      var body = document.getElementById(prefix + '-body');
      if (!toggle || !body) return;
      toggle.addEventListener('click', function() {
        var isOpen = body.classList.toggle('open');
        toggle.innerHTML = toggle.innerHTML.replace(/[\u25BC\u25B6]/, isOpen ? '\u25BC' : '\u25B6');
      });
    });

    // ---- Context-sensitive control visibility ----
    setInterval(function() {
      // Launch speed: visible only in orbit/orbits mode
      var lsg = document.getElementById('curv-launch-speed-group');
      if (lsg) lsg.style.display = (currentMode === 'orbit' || currentMode === 'orbits') ? 'block' : 'none';

      // Follow button: visible only when movable bodies exist
      var followBtn = document.getElementById('curv-cam-follow');
      if (followBtn) {
        var hasBody = particles.length > 0 || masses.some(function(m) { return m.dynamic; });
        followBtn.style.display = hasBody ? '' : 'none';
      }

      // Step +1: grayed out when playing (not paused)
      var stepBtn = document.getElementById('curv-step-fwd');
      if (stepBtn) {
        if (paused) { stepBtn.classList.remove('curv-disabled'); }
        else { stepBtn.classList.add('curv-disabled'); }
      }

      // Mass strength: hidden when a simulation (not manual preset) is active
      var msg = document.getElementById('curv-mass-slider-group');
      var activeScenario = document.querySelector('#sec-curvature [data-scenario].active');
      if (msg) msg.style.display = activeScenario ? 'none' : 'block';

      // Info overlay sync
      var infoTime = document.getElementById('curv-info-time');
      var infoDilation = document.getElementById('curv-info-dilation');
      var infoEnergy = document.getElementById('curv-info-energy');
      var infoScenario = document.getElementById('curv-info-scenario');
      if (infoTime) infoTime.textContent = document.getElementById('curv-elapsed-time').textContent;
      if (infoDilation) infoDilation.textContent = document.getElementById('curv-dilation').textContent;
      if (infoEnergy) infoEnergy.textContent = document.getElementById('curv-energy-drift').textContent;
      if (infoScenario) {
        var abtn = document.querySelector('#sec-curvature [data-scenario].active') ||
                   document.querySelector('#sec-curvature [data-preset].active');
        infoScenario.textContent = abtn ? abtn.textContent : 'Custom';
      }
      // Force info row — show peak force when forces visible
      var forceRow = document.getElementById('curv-info-force-row');
      var forceVal = document.getElementById('curv-info-force');
      if (forceRow) {
        forceRow.style.display = showForces ? 'flex' : 'none';
        if (showForces && forceVal && particles.length > 0 && masses.length > 0) {
          var peakF = 0;
          for (var fi = 0; fi < particles.length; fi++) {
            var fp = particles[fi];
            if (!fp.alive) continue;
            for (var fj = 0; fj < masses.length; fj++) {
              var fm = masses[fj];
              var fdx = fp.x - fm.x, fdz = fp.z - fm.z;
              var fdy = view3D ? fp.y : 0;
              var fr = Math.sqrt(fdx * fdx + fdy * fdy + fdz * fdz);
              if (fr < 0.2) fr = 0.2;
              var ff = fm.strength / (fr * fr);
              if (ff > peakF) peakF = ff;
            }
          }
          forceVal.textContent = peakF < 0.01 ? '~0' : peakF.toFixed(2);
        }
      }
    }, 200);

    // ---- Enhanced fullscreen: H key toggle + section class ----
    var secEl = document.getElementById('sec-curvature');
    document.getElementById('curv-fullscreen').addEventListener('click', function() {
      // Runs after existing toggleFullscreen handler
      setTimeout(function() {
        secEl.classList.toggle('curv-fs-active', container.classList.contains('curv-fullscreen'));
        if (!container.classList.contains('curv-fullscreen')) {
          secEl.classList.remove('curv-fs-controls-visible');
        }
      }, 10);
    });
    document.getElementById('curv-fullscreen-close').addEventListener('click', function() {
      setTimeout(function() {
        secEl.classList.remove('curv-fs-active', 'curv-fs-controls-visible');
      }, 10);
    });
    document.addEventListener('keydown', function(e) {
      if ((e.key === 'h' || e.key === 'H') && container.classList.contains('curv-fullscreen')) {
        secEl.classList.toggle('curv-fs-controls-visible');
      }
      if (e.key === 'Escape') {
        secEl.classList.remove('curv-fs-active', 'curv-fs-controls-visible');
      }
    });

    // Load default preset, set camera mode, and start
    loadPreset('earth');
    switchView(true);
    setMode('camera');
    requestAnimationFrame(animate);
  }
})();

// ==================== SPEED LIMIT (Explained Simply) ====================
(function initSpeedLimit() {
  // ---- Tab switching ----
  const tabBar = document.getElementById('speedlimit-tabs');
  if (!tabBar) return;
  let activeTab = 'sl-speedometer';
  tabBar.querySelectorAll('.tab-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      tabBar.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      const tgt = btn.getAttribute('data-tab');
      btn.closest('.card').querySelectorAll('.tab-content').forEach(tc => {
        tc.classList.toggle('active', tc.id === tgt);
      });
      activeTab = tgt;
    });
  });

  // ---- Canvas setup ----
  const s1 = setupCanvas('sl-canvas');
  const s2 = setupCanvas('sl-astro-canvas');
  const s3 = setupCanvas('sl-photon-canvas');
  const s4 = setupCanvas('sl-wall-canvas');
  const s5 = setupCanvas('sl-candle-canvas');

  // ---- Shared helpers ----
  function drawStars(ctx, w, h, seed, speed, ts) {
    const rng = (i) => ((seed * 9301 + i * 49297) % 233280) / 233280;
    for (let i = 0; i < 40; i++) {
      let sx = rng(i * 3) * w;
      const sy = rng(i * 3 + 1) * h;
      const sr = rng(i * 3 + 2) * 1.5 + 0.5;
      if (speed > 0 && ts) {
        sx = (sx + ts * speed * 0.05) % w;
      }
      ctx.fillStyle = `rgba(255,255,255,${0.3 + rng(i * 7) * 0.5})`;
      ctx.beginPath();
      ctx.arc(sx, sy, sr, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawClockFace(ctx, cx, cy, r, fraction) {
    // Outer ring
    ctx.strokeStyle = '#334466';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(cx, cy, r, 0, Math.PI * 2);
    ctx.stroke();
    // Tick marks
    for (let i = 0; i < 12; i++) {
      const a = (i / 12) * Math.PI * 2 - Math.PI / 2;
      const inner = r * 0.82;
      const outer = r * 0.95;
      ctx.strokeStyle = '#64748b';
      ctx.lineWidth = i % 3 === 0 ? 2.5 : 1;
      ctx.beginPath();
      ctx.moveTo(cx + Math.cos(a) * inner, cy + Math.sin(a) * inner);
      ctx.lineTo(cx + Math.cos(a) * outer, cy + Math.sin(a) * outer);
      ctx.stroke();
    }
    // Hour hand
    const ha = (fraction * Math.PI * 2) - Math.PI / 2;
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(ha) * r * 0.55, cy + Math.sin(ha) * r * 0.55);
    ctx.stroke();
    // Minute hand
    const ma = (fraction * 12 * Math.PI * 2) - Math.PI / 2;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    ctx.lineTo(cx + Math.cos(ma) * r * 0.75, cy + Math.sin(ma) * r * 0.75);
    ctx.stroke();
    ctx.lineCap = 'butt';
    // Center dot
    ctx.fillStyle = '#e2e8f0';
    ctx.beginPath();
    ctx.arc(cx, cy, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  function drawAstronaut(ctx, cx, cy, scale, motion) {
    const s = scale;
    // Helmet
    ctx.fillStyle = '#1e293b';
    ctx.beginPath();
    ctx.arc(cx, cy - 18 * s, 14 * s, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#64748b';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Visor
    ctx.fillStyle = motion > 0.95 ? '#fbbf24' : '#3b82f6';
    ctx.beginPath();
    ctx.arc(cx, cy - 18 * s, 9 * s, -0.5, Math.PI + 0.5);
    ctx.fill();
    // Body
    ctx.fillStyle = '#e2e8f0';
    ctx.beginPath();
    ctx.roundRect(cx - 10 * s, cy - 2 * s, 20 * s, 26 * s, 5 * s);
    ctx.fill();
    // Backpack
    ctx.fillStyle = '#94a3b8';
    ctx.fillRect(cx + 10 * s, cy, 6 * s, 18 * s);
    // Legs
    ctx.fillStyle = '#cbd5e1';
    ctx.fillRect(cx - 8 * s, cy + 24 * s, 7 * s, 14 * s);
    ctx.fillRect(cx + 1 * s, cy + 24 * s, 7 * s, 14 * s);
    // Boots
    ctx.fillStyle = '#475569';
    ctx.fillRect(cx - 9 * s, cy + 36 * s, 9 * s, 5 * s);
    ctx.fillRect(cx, cy + 36 * s, 9 * s, 5 * s);
  }

  // =============================================================
  //  TAB 1 — SPEEDOMETER OF SPACETIME
  // =============================================================
  let slBeta = 0;
  document.getElementById('sl-speed').addEventListener('input', (e) => {
    slBeta = e.target.value / 100;
    document.getElementById('sl-speed-label').textContent = slBeta.toFixed(2) + 'c';
  });

  function drawSpeedometer(ts) {
    const ctx = s1.ctx, w = s1.w, h = s1.h;
    ctx.clearRect(0, 0, w, h);

    // Background
    ctx.fillStyle = '#080c16';
    ctx.fillRect(0, 0, w, h);
    drawStars(ctx, w, h, 42, 0, 0);

    const cx = w / 2, cy = h / 2 + 20;
    const R = Math.min(w, h) * 0.38;
    const beta = slBeta;
    const timeFrac = Math.sqrt(Math.max(0, 1 - beta * beta));

    // Title
    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 18px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Your Spacetime Speedometer', cx, 32);

    // Quarter-circle arc
    ctx.save();
    ctx.translate(cx - R * 0.5, cy + R * 0.2);

    const ox = 0, oy = 0;
    // Axes
    ctx.strokeStyle = '#334466';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox + R * 1.15, oy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.lineTo(ox, oy - R * 1.15);
    ctx.stroke();

    // Axis labels
    ctx.fillStyle = '#94a3b8';
    ctx.font = '13px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('Speed through SPACE \u2192', ox + R * 0.6, oy + 28);
    ctx.save();
    ctx.translate(ox - 28, oy - R * 0.6);
    ctx.rotate(-Math.PI / 2);
    ctx.fillText('Speed through TIME \u2192', 0, 0);
    ctx.restore();

    // "c" labels at the ends
    ctx.fillStyle = '#64748b';
    ctx.font = 'italic 13px system-ui';
    ctx.fillText('c', ox + R + 12, oy + 5);
    ctx.textAlign = 'left';
    ctx.fillText('c', ox - 8, oy - R - 8);
    ctx.textAlign = 'center';

    // Draw the arc
    ctx.strokeStyle = 'rgba(255,255,255,0.15)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(ox, oy, R, -Math.PI / 2, 0);
    ctx.stroke();

    // Filled arc glow
    const arcGrad = ctx.createLinearGradient(ox, oy - R, ox + R, oy);
    arcGrad.addColorStop(0, 'rgba(245,158,11,0.08)');
    arcGrad.addColorStop(1, 'rgba(6,182,212,0.08)');
    ctx.fillStyle = arcGrad;
    ctx.beginPath();
    ctx.moveTo(ox, oy);
    ctx.arc(ox, oy, R, -Math.PI / 2, 0);
    ctx.closePath();
    ctx.fill();

    // Dot position on arc
    const dotX = ox + beta * R;
    const dotY = oy - timeFrac * R;

    // Projection lines
    // Space (horizontal) — cyan
    if (beta > 0.005) {
      ctx.strokeStyle = '#06b6d4';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(dotX, oy);
      ctx.stroke();
      // Bar fill
      ctx.fillStyle = 'rgba(6,182,212,0.15)';
      ctx.fillRect(ox, oy - 6, beta * R, 6);
    }
    // Time (vertical) — amber
    if (timeFrac > 0.005) {
      ctx.strokeStyle = '#f59e0b';
      ctx.lineWidth = 4;
      ctx.beginPath();
      ctx.moveTo(ox, oy);
      ctx.lineTo(ox, dotY);
      ctx.stroke();
      ctx.fillStyle = 'rgba(245,158,11,0.15)';
      ctx.fillRect(ox - 6, dotY, 6, timeFrac * R);
    }

    // Dashed lines from dot to axes
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(dotX, dotY);
    ctx.lineTo(dotX, oy);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(dotX, dotY);
    ctx.lineTo(ox, dotY);
    ctx.stroke();
    ctx.setLineDash([]);

    // The dot
    ctx.fillStyle = '#fff';
    ctx.shadowColor = '#fff';
    ctx.shadowBlur = 12;
    ctx.beginPath();
    ctx.arc(dotX, dotY, 8, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;

    // Dot label
    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 13px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('YOU', dotX + 14, dotY - 4);

    // Bar labels with values
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'center';
    if (beta > 0.05) {
      ctx.fillStyle = '#06b6d4';
      ctx.fillText((beta * 100).toFixed(0) + '%', ox + beta * R / 2, oy + 48);
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText('through space', ox + beta * R / 2, oy + 63);
    }
    ctx.font = 'bold 14px system-ui';
    if (timeFrac > 0.05) {
      ctx.fillStyle = '#f59e0b';
      ctx.fillText((timeFrac * 100).toFixed(0) + '%', ox - 50, oy - timeFrac * R / 2 + 5);
      ctx.font = '11px system-ui';
      ctx.fillStyle = '#94a3b8';
      ctx.fillText('through time', ox - 50, oy - timeFrac * R / 2 + 20);
    }

    // Animated rocket icon on space axis
    if (beta > 0.01) {
      ctx.fillStyle = '#06b6d4';
      ctx.font = '16px system-ui';
      ctx.textAlign = 'center';
      const rx = ox + beta * R;
      ctx.fillText('\u{1F680}', rx, oy - 14);
    }
    // Clock icon on time axis
    if (timeFrac > 0.01) {
      ctx.font = '16px system-ui';
      ctx.fillStyle = '#f59e0b';
      const ty = oy - timeFrac * R;
      ctx.fillText('\u{1F552}', ox + 14, ty + 5);
    }

    ctx.restore();

    // Descriptive text below
    ctx.textAlign = 'center';
    ctx.font = '15px system-ui';
    let msg = '', msgColor = '#94a3b8';
    if (beta < 0.01) {
      msg = 'Sitting still \u2014 ALL your speed goes through time. You age at full speed.';
      msgColor = '#f59e0b';
    } else if (beta < 0.3) {
      msg = 'Moving slowly \u2014 almost all your speed still goes through time.';
      msgColor = '#f59e0b';
    } else if (beta < 0.6) {
      msg = 'Getting fast! Time is noticeably slowing down for you.';
      msgColor = '#e2e8f0';
    } else if (beta < 0.85) {
      msg = 'Very fast \u2014 you\'re aging significantly slower than someone standing still.';
      msgColor = '#06b6d4';
    } else if (beta < 0.95) {
      msg = 'Extreme speed \u2014 most of your speed goes through space now. Time barely passes.';
      msgColor = '#06b6d4';
    } else if (beta < 1.0) {
      msg = 'Nearly light speed \u2014 time has almost stopped for you!';
      msgColor = '#ef4444';
    } else {
      msg = 'LIGHT SPEED \u2014 ALL speed through space, ZERO through time. Time STOPS.';
      msgColor = '#ef4444';
    }
    ctx.fillStyle = msgColor;
    ctx.fillText(msg, w / 2, h - 20);

    // Budget label
    ctx.fillStyle = '#475569';
    ctx.font = '12px system-ui';
    ctx.fillText('The dot always stays on the arc \u2014 your total speed through spacetime is always c', w / 2, h - 44);
  }

  // =============================================================
  //  TAB 2 — ASTRONAUT AGING
  // =============================================================
  let astroRunning = false, astroTime = 0, astroPrevTs = null;
  let astroBeta = 0.8;

  document.getElementById('sl-astro-vel').addEventListener('input', (e) => {
    astroBeta = e.target.value / 100;
    document.getElementById('sl-astro-vel-label').textContent = astroBeta.toFixed(2) + 'c';
  });
  document.getElementById('sl-astro-play').addEventListener('click', () => {
    const btn = document.getElementById('sl-astro-play');
    if (astroRunning) { astroRunning = false; btn.textContent = 'Resume'; }
    else { astroRunning = true; btn.textContent = 'Pause'; }
  });
  document.getElementById('sl-astro-reset').addEventListener('click', () => {
    astroRunning = false; astroTime = 0; astroPrevTs = null;
    document.getElementById('sl-astro-play').textContent = 'Start Aging';
  });

  function drawAstronaut_tab(ts) {
    const ctx = s2.ctx, w = s2.w, h = s2.h;
    if (astroPrevTs === null) astroPrevTs = ts;
    const dt = Math.min(ts - astroPrevTs, 50);
    astroPrevTs = ts;
    if (astroRunning) astroTime += dt * 0.001;

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#080c16';
    ctx.fillRect(0, 0, w, h);

    const colW = w / 3;
    const g = gamma(Math.min(astroBeta, 0.999));
    const configs = [
      { label: 'Sitting Still', speed: 0, beta: 0, color: '#f59e0b' },
      { label: 'Fast Rocket (' + astroBeta.toFixed(2) + 'c)', speed: astroBeta, beta: astroBeta, color: '#06b6d4' },
      { label: 'Photon (1.00c)', speed: 1, beta: 0.9999, color: '#ef4444' }
    ];

    configs.forEach((cfg, i) => {
      const cx = colW * i + colW / 2;
      const gLocal = cfg.speed >= 0.9999 ? Infinity : gamma(cfg.speed);
      const ageRate = cfg.speed >= 0.9999 ? 0 : 1 / gLocal;
      const age = astroTime * ageRate;

      // Column background
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.beginPath();
      ctx.roundRect(colW * i + 8, 8, colW - 16, h - 16, 12);
      ctx.fill();
      ctx.strokeStyle = 'rgba(255,255,255,0.05)';
      ctx.lineWidth = 1;
      ctx.stroke();

      // Stars (move if speed > 0)
      ctx.save();
      ctx.beginPath();
      ctx.rect(colW * i + 8, 8, colW - 16, h - 16);
      ctx.clip();
      if (cfg.speed > 0 && cfg.speed < 1) {
        for (let s = 0; s < 15; s++) {
          const starSeed = i * 100 + s;
          const sy = ((starSeed * 7919) % 233280) / 233280 * h;
          const baseX = ((starSeed * 3571) % 233280) / 233280 * colW;
          const sx = colW * i + ((baseX + ts * cfg.speed * 0.08) % colW);
          const streak = cfg.speed * 12;
          ctx.strokeStyle = `rgba(255,255,255,${0.2 + cfg.speed * 0.3})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(sx, sy);
          ctx.lineTo(sx - streak, sy);
          ctx.stroke();
        }
      } else if (cfg.speed >= 1) {
        // Motion blur lines for photon
        for (let s = 0; s < 30; s++) {
          const starSeed = i * 100 + s;
          const sy = ((starSeed * 7919) % 233280) / 233280 * h;
          const sx = colW * i + ((starSeed * 3571) % 233280) / 233280 * colW;
          ctx.strokeStyle = 'rgba(255,255,255,0.1)';
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(colW * i + 8, sy);
          ctx.lineTo(colW * (i + 1) - 8, sy);
          ctx.stroke();
        }
      } else {
        drawStars(ctx, colW - 16, h - 16, i * 50 + 7, 0, 0);
      }
      ctx.restore();

      // Column label
      ctx.fillStyle = cfg.color;
      ctx.font = 'bold 14px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(cfg.label, cx, 36);

      // Clock
      const clockFrac = age / 12;
      drawClockFace(ctx, cx, 100, 36, clockFrac);

      // Clock speed label
      ctx.fillStyle = '#94a3b8';
      ctx.font = '11px system-ui';
      if (cfg.speed >= 0.9999) {
        ctx.fillStyle = '#ef4444';
        ctx.fillText('FROZEN', cx, 150);
      } else if (cfg.speed === 0) {
        ctx.fillText('Normal speed', cx, 150);
      } else {
        ctx.fillText('Ticking at ' + (ageRate * 100).toFixed(0) + '% speed', cx, 150);
      }

      // Astronaut figure
      drawAstronaut(ctx, cx, 225, 1.6, cfg.speed);

      // Age display
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 22px system-ui';
      ctx.textAlign = 'center';
      const displayAge = 30 + age;
      ctx.fillText(displayAge.toFixed(1) + ' years old', cx, 340);

      // Time elapsed
      ctx.fillStyle = '#64748b';
      ctx.font = '12px system-ui';
      ctx.fillText('Elapsed: ' + age.toFixed(1) + ' years', cx, 360);

      // Status text
      ctx.font = '12px system-ui';
      if (cfg.speed >= 0.9999) {
        ctx.fillStyle = '#ef4444';
        ctx.fillText('Doesn\'t age AT ALL', cx, 385);
      } else if (cfg.speed === 0) {
        ctx.fillStyle = '#f59e0b';
        ctx.fillText('Aging at full speed', cx, 385);
      } else {
        ctx.fillStyle = '#06b6d4';
        const diff = astroTime - age;
        if (diff > 0.05) ctx.fillText((diff.toFixed(1)) + ' years younger than still twin', cx, 385);
      }
    });

    // Summary at bottom
    if (astroTime > 1) {
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 14px system-ui';
      ctx.textAlign = 'center';
      const rocketAge = astroTime / g;
      ctx.fillText('Same amount of real time passed \u2014 but they\'ve aged differently!', w / 2, h - 50);
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui';
      ctx.fillText('Moving through space steals from your speed through time.', w / 2, h - 30);
    }
  }

  // =============================================================
  //  TAB 3 — PHOTON'S VIEW
  // =============================================================
  let photonRunning = false, photonFrac = 0, photonPrevTs = null, photonDone = false;

  document.getElementById('sl-photon-play').addEventListener('click', () => {
    const btn = document.getElementById('sl-photon-play');
    if (photonDone) return;
    if (photonRunning) { photonRunning = false; btn.textContent = 'Resume'; }
    else { photonRunning = true; btn.textContent = 'Pause'; }
  });
  document.getElementById('sl-photon-reset').addEventListener('click', () => {
    photonRunning = false; photonFrac = 0; photonPrevTs = null; photonDone = false;
    document.getElementById('sl-photon-play').textContent = 'Send Photon';
  });

  function drawPhoton(ts) {
    const ctx = s3.ctx, w = s3.w, h = s3.h;
    if (photonPrevTs === null) photonPrevTs = ts;
    const dt = Math.min(ts - photonPrevTs, 50);
    photonPrevTs = ts;
    if (photonRunning && !photonDone) {
      photonFrac += dt * 0.0002;
      if (photonFrac >= 1) { photonFrac = 1; photonDone = true; photonRunning = false;
        document.getElementById('sl-photon-play').textContent = 'Done!'; }
    }

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#080c16';
    ctx.fillRect(0, 0, w, h);

    const midY = h / 2;

    // ---- TOP HALF: YOUR VIEW ----
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(20, 10, w - 40, midY - 20);

    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 16px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('YOUR VIEW (from Earth)', w / 2, 34);

    // Sun
    const sunX = 100, sunY = midY / 2 + 20, earthX = w - 100, earthY = sunY;
    // Sun glow
    const sunGrad = ctx.createRadialGradient(sunX, sunY, 5, sunX, sunY, 45);
    sunGrad.addColorStop(0, '#fbbf24');
    sunGrad.addColorStop(0.4, 'rgba(251,191,36,0.3)');
    sunGrad.addColorStop(1, 'transparent');
    ctx.fillStyle = sunGrad;
    ctx.beginPath();
    ctx.arc(sunX, sunY, 45, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.arc(sunX, sunY, 22, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#1e293b';
    ctx.font = 'bold 12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('SUN', sunX, sunY + 4);

    // Earth
    ctx.fillStyle = '#3b82f6';
    ctx.beginPath();
    ctx.arc(earthX, earthY, 16, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#22c55e';
    ctx.beginPath();
    ctx.ellipse(earthX - 3, earthY - 2, 8, 5, 0.3, 0, Math.PI * 2);
    ctx.fill();
    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 11px system-ui';
    ctx.fillText('EARTH', earthX, earthY + 30);

    // Distance label
    ctx.fillStyle = '#64748b';
    ctx.font = '11px system-ui';
    ctx.fillText('150 million km', (sunX + earthX) / 2, sunY - 40);
    // Dashed line
    ctx.setLineDash([4, 4]);
    ctx.strokeStyle = '#334466';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(sunX + 30, sunY - 30);
    ctx.lineTo(earthX - 20, sunY - 30);
    ctx.stroke();
    ctx.setLineDash([]);

    // Photon traveling
    if (photonFrac > 0) {
      const px = sunX + 30 + photonFrac * (earthX - sunX - 50);
      ctx.fillStyle = '#fbbf24';
      ctx.shadowColor = '#fbbf24';
      ctx.shadowBlur = 15;
      ctx.beginPath();
      ctx.arc(px, sunY, 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.shadowBlur = 0;
      // Trail
      ctx.strokeStyle = 'rgba(251,191,36,0.2)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(sunX + 30, sunY);
      ctx.lineTo(px, sunY);
      ctx.stroke();
    }

    // Timer
    ctx.fillStyle = photonDone ? '#22c55e' : '#f59e0b';
    ctx.font = 'bold 18px system-ui';
    ctx.textAlign = 'center';
    const mins = photonFrac * 8;
    ctx.fillText('Time: ' + mins.toFixed(1) + ' minutes', w / 2, midY - 25);

    // ---- DIVIDER ----
    ctx.strokeStyle = '#1e293b';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(40, midY);
    ctx.lineTo(w - 40, midY);
    ctx.stroke();
    ctx.fillStyle = '#475569';
    ctx.font = '11px system-ui';
    ctx.fillText('\u2193 Same journey, different perspective \u2193', w / 2, midY + 14);

    // ---- BOTTOM HALF: PHOTON'S VIEW ----
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    ctx.fillRect(20, midY + 20, w - 40, midY - 30);

    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 16px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('PHOTON\'S VIEW', w / 2, midY + 44);

    const bCenterY = midY + h / 4 + 30;
    // Length contraction squishes everything together
    const squeeze = photonFrac > 0 ? Math.max(0.01, 1 - photonFrac * 0.99) : 1;
    const bSunX = w / 2 - (earthX - sunX) / 2 * squeeze;
    const bEarthX = w / 2 + (earthX - sunX) / 2 * squeeze;

    if (photonFrac === 0) {
      // Before sending - show normal spacing fading to squished
      const bSunGrad = ctx.createRadialGradient(bSunX, bCenterY, 3, bSunX, bCenterY, 30);
      bSunGrad.addColorStop(0, '#fbbf24');
      bSunGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = bSunGrad;
      ctx.beginPath();
      ctx.arc(bSunX, bCenterY, 30, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(bSunX, bCenterY, 15, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.arc(bEarthX, bCenterY, 12, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#94a3b8';
      ctx.font = '13px system-ui';
      ctx.fillText('Press "Send Photon" to see what the photon experiences', w / 2, h - 25);
    } else {
      // Squished view - Sun and Earth nearly touching
      const bSunGrad = ctx.createRadialGradient(bSunX, bCenterY, 2, bSunX, bCenterY, 25 * squeeze + 5);
      bSunGrad.addColorStop(0, '#fbbf24');
      bSunGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = bSunGrad;
      ctx.beginPath();
      ctx.arc(bSunX, bCenterY, 25 * squeeze + 5, 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#fbbf24';
      ctx.beginPath();
      ctx.arc(bSunX, bCenterY, Math.max(8, 15 * squeeze), 0, Math.PI * 2);
      ctx.fill();
      ctx.fillStyle = '#3b82f6';
      ctx.beginPath();
      ctx.arc(bEarthX, bCenterY, Math.max(6, 12 * squeeze), 0, Math.PI * 2);
      ctx.fill();

      // Flash effect when arriving
      if (photonDone) {
        const flash = Math.max(0, 1 - (ts % 2000) / 1000);
        ctx.fillStyle = `rgba(251,191,36,${flash * 0.3})`;
        ctx.beginPath();
        ctx.arc(w / 2, bCenterY, 60, 0, Math.PI * 2);
        ctx.fill();
      }

      // Labels
      ctx.fillStyle = '#f59e0b';
      ctx.font = 'bold 16px system-ui';
      ctx.fillText('Time: 0 seconds (instant!)', w / 2, bCenterY + 60);

      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 13px system-ui';
      if (photonDone) {
        ctx.fillText('To the photon, the entire universe is squished flat!', w / 2, bCenterY + 82);
        ctx.fillStyle = '#94a3b8';
        ctx.font = '12px system-ui';
        ctx.fillText('Distance = 0. Time = 0. Birth and death are the same instant.', w / 2, bCenterY + 100);
      } else {
        ctx.fillText('Distance contracts to nearly zero...', w / 2, bCenterY + 82);
      }
    }
  }

  // =============================================================
  //  TAB 4 — THE WALL
  // =============================================================
  let wallBeta = 0;
  document.getElementById('sl-wall-speed').addEventListener('input', (e) => {
    wallBeta = e.target.value / 100;
    document.getElementById('sl-wall-label').textContent = wallBeta.toFixed(2) + 'c';
  });

  function drawWall(ts) {
    const ctx = s4.ctx, w = s4.w, h = s4.h;
    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#080c16';
    ctx.fillRect(0, 0, w, h);
    drawStars(ctx, w, h, 99, 0, 0);

    const beta = wallBeta;
    const groundY = h - 60;
    const hillLeft = 80, hillRight = w - 60;
    const hillW = hillRight - hillLeft;

    // Title
    ctx.fillStyle = '#e2e8f0';
    ctx.font = 'bold 18px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText('The Energy Hill', w / 2, 30);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '13px system-ui';
    ctx.fillText('The faster you push, the steeper the hill gets', w / 2, 50);

    // Draw the hill curve
    // At beta=0: flat. At beta=1: vertical wall.
    // Use gamma-1 to shape the curve height
    ctx.beginPath();
    ctx.moveTo(hillLeft, groundY);
    const hillPts = 100;
    for (let i = 0; i <= hillPts; i++) {
      const t = i / hillPts;
      const bAt = t; // beta at this x-position
      const g = 1 / Math.sqrt(Math.max(0.001, 1 - bAt * bAt));
      const energyFrac = Math.min(1, (g - 1) / 15);
      const px = hillLeft + t * hillW;
      const py = groundY - energyFrac * (groundY - 70);
      if (i === 0) ctx.moveTo(px, py);
      else ctx.lineTo(px, py);
    }
    ctx.lineTo(hillRight, 70);
    ctx.lineTo(hillRight, groundY);
    ctx.closePath();

    // Hill gradient: green → yellow → red
    const hillGrad = ctx.createLinearGradient(hillLeft, groundY, hillRight, 70);
    hillGrad.addColorStop(0, 'rgba(34,197,94,0.3)');
    hillGrad.addColorStop(0.3, 'rgba(245,158,11,0.3)');
    hillGrad.addColorStop(0.7, 'rgba(239,68,68,0.3)');
    hillGrad.addColorStop(1, 'rgba(239,68,68,0.5)');
    ctx.fillStyle = hillGrad;
    ctx.fill();

    // Hill outline
    ctx.beginPath();
    ctx.moveTo(hillLeft, groundY);
    for (let i = 0; i <= hillPts; i++) {
      const t = i / hillPts;
      const bAt = t;
      const g = 1 / Math.sqrt(Math.max(0.001, 1 - bAt * bAt));
      const energyFrac = Math.min(1, (g - 1) / 15);
      const px = hillLeft + t * hillW;
      const py = groundY - energyFrac * (groundY - 70);
      ctx.lineTo(px, py);
    }
    ctx.strokeStyle = '#64748b';
    ctx.lineWidth = 2;
    ctx.stroke();

    // Speed labels along bottom
    ctx.fillStyle = '#475569';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'center';
    [0, 0.25, 0.5, 0.75, 0.9, 0.99].forEach(b => {
      const px = hillLeft + b * hillW;
      ctx.fillText(b.toFixed(2) + 'c', px, groundY + 18);
    });
    // "c" at the wall
    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 13px system-ui';
    ctx.fillText('c', hillRight, groundY + 18);

    // WALL at c
    ctx.fillStyle = 'rgba(239,68,68,0.15)';
    ctx.fillRect(hillRight - 4, 60, 30, groundY - 60);
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(hillRight, groundY);
    ctx.lineTo(hillRight, 60);
    ctx.stroke();
    ctx.fillStyle = '#ef4444';
    ctx.font = 'bold 14px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('WALL', hillRight + 6, 100);
    ctx.font = '11px system-ui';
    ctx.fillText('Infinite', hillRight + 6, 116);
    ctx.fillText('energy', hillRight + 6, 130);
    ctx.fillText('needed!', hillRight + 6, 144);

    // Position of the figure on the hill
    const figBeta = Math.min(beta, 0.995);
    const figG = 1 / Math.sqrt(Math.max(0.001, 1 - figBeta * figBeta));
    const figEnergyFrac = Math.min(1, (figG - 1) / 15);
    const figX = hillLeft + figBeta * hillW;
    const figY = groundY - figEnergyFrac * (groundY - 70);

    // Compute slope angle at this point
    const dBeta = 0.01;
    const bNext = Math.min(figBeta + dBeta, 0.999);
    const gNext = 1 / Math.sqrt(1 - bNext * bNext);
    const eNext = Math.min(1, (gNext - 1) / 15);
    const yNext = groundY - eNext * (groundY - 70);
    const xNext = hillLeft + bNext * hillW;
    const slopeAngle = Math.atan2(figY - yNext, xNext - figX);

    // Boulder
    const boulderR = 14;
    ctx.fillStyle = '#94a3b8';
    ctx.beginPath();
    ctx.arc(figX, figY - boulderR - 2, boulderR, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = '#64748b';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Boulder cracks
    ctx.strokeStyle = '#475569';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(figX - 4, figY - boulderR - 8);
    ctx.lineTo(figX + 2, figY - boulderR);
    ctx.lineTo(figX - 1, figY - boulderR + 6);
    ctx.stroke();

    // Figure pushing (behind boulder)
    const figScale = 0.7;
    const figLean = Math.min(slopeAngle * 0.5, 0.8);
    ctx.save();
    ctx.translate(figX - 25, figY - 2);
    ctx.rotate(-figLean * 0.3);
    // Stick figure
    // Head
    ctx.fillStyle = '#fbbf24';
    ctx.beginPath();
    ctx.arc(0, -30 * figScale, 7 * figScale, 0, Math.PI * 2);
    ctx.fill();
    // Body
    ctx.strokeStyle = '#e2e8f0';
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, -23 * figScale);
    ctx.lineTo(0, 0);
    ctx.stroke();
    // Arms (pushing forward)
    ctx.beginPath();
    ctx.moveTo(0, -15 * figScale);
    ctx.lineTo(18 * figScale, -12 * figScale);
    ctx.stroke();
    // Legs
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(-8 * figScale, 15 * figScale);
    ctx.moveTo(0, 0);
    ctx.lineTo(5 * figScale, 15 * figScale);
    ctx.stroke();

    // Strain indicators (sweat drops at high speed)
    if (beta > 0.5) {
      const numDrops = Math.floor((beta - 0.5) * 8);
      for (let d = 0; d < numDrops; d++) {
        const dy = -35 * figScale - d * 6;
        const dx = -10 + Math.sin(ts * 0.003 + d) * 4;
        ctx.fillStyle = '#3b82f6';
        ctx.beginPath();
        ctx.arc(dx, dy, 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }
    ctx.restore();

    // Difficulty label
    ctx.textAlign = 'center';
    ctx.font = '13px system-ui';
    if (beta < 0.1) {
      ctx.fillStyle = '#22c55e';
      ctx.fillText('Easy! The hill is nearly flat.', w / 2, groundY + 40);
    } else if (beta < 0.5) {
      ctx.fillStyle = '#22c55e';
      ctx.fillText('Getting steeper, but manageable.', w / 2, groundY + 40);
    } else if (beta < 0.8) {
      ctx.fillStyle = '#f59e0b';
      ctx.fillText('Steep! Takes a LOT more energy to go a little faster.', w / 2, groundY + 40);
    } else if (beta < 0.95) {
      ctx.fillStyle = '#ef4444';
      ctx.fillText('Nearly vertical! Enormous energy for tiny speed gains.', w / 2, groundY + 40);
    } else {
      ctx.fillStyle = '#ef4444';
      ctx.font = 'bold 14px system-ui';
      ctx.fillText('IMPOSSIBLY STEEP! No amount of energy is enough!', w / 2, groundY + 40);
    }

    // Photon floating over the wall
    const photonY = 50 + Math.sin(ts * 0.002) * 8;
    ctx.fillStyle = '#fbbf24';
    ctx.shadowColor = '#fbbf24';
    ctx.shadowBlur = 20;
    ctx.beginPath();
    ctx.arc(hillRight + 15, photonY, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.shadowBlur = 0;
    ctx.fillStyle = '#fbbf24';
    ctx.font = '11px system-ui';
    ctx.textAlign = 'left';
    ctx.fillText('Photon', hillRight + 26, photonY + 4);
    ctx.fillStyle = '#94a3b8';
    ctx.font = '10px system-ui';
    ctx.fillText('(massless \u2014 no', hillRight + 26, photonY + 17);
    ctx.fillText('hill to climb!)', hillRight + 26, photonY + 29);
  }

  // =============================================================
  //  TAB 5 — BIRTHDAY CANDLES
  // =============================================================
  let candleRunning = false, candleTime = 0, candlePrevTs = null, candleDone = false;
  let candleBeta = 0.8, candleSimSpeed = 1;

  document.getElementById('sl-candle-vel').addEventListener('input', (e) => {
    candleBeta = e.target.value / 100;
    document.getElementById('sl-candle-vel-label').textContent = candleBeta.toFixed(2) + 'c';
  });
  document.getElementById('sl-candle-play').addEventListener('click', () => {
    const btn = document.getElementById('sl-candle-play');
    if (candleDone) return;
    if (candleRunning) { candleRunning = false; btn.textContent = 'Resume'; }
    else { candleRunning = true; btn.textContent = 'Pause'; }
  });
  document.getElementById('sl-candle-reset').addEventListener('click', () => {
    candleRunning = false; candleTime = 0; candlePrevTs = null; candleDone = false;
    document.getElementById('sl-candle-play').textContent = 'Start Journey';
  });
  const candleSpeeds = [1, 2, 5, 10];
  let candleSpeedIdx = 0;
  document.getElementById('sl-candle-speed').addEventListener('click', () => {
    candleSpeedIdx = (candleSpeedIdx + 1) % candleSpeeds.length;
    candleSimSpeed = candleSpeeds[candleSpeedIdx];
    document.getElementById('sl-candle-speed').innerHTML = 'Speed: ' + candleSimSpeed + '&times;';
  });

  function drawCandle(ctx, cx, baseY, lit, flicker) {
    // Candle stick
    ctx.fillStyle = '#e2e8f0';
    ctx.fillRect(cx - 3, baseY - 22, 6, 22);
    // Wick
    ctx.fillStyle = '#475569';
    ctx.fillRect(cx - 1, baseY - 26, 2, 5);
    if (lit) {
      // Flame
      const fh = 8 + flicker * 3;
      const fGrad = ctx.createRadialGradient(cx, baseY - 26 - fh / 2, 1, cx, baseY - 26 - fh / 2, fh);
      fGrad.addColorStop(0, '#fbbf24');
      fGrad.addColorStop(0.5, '#f59e0b');
      fGrad.addColorStop(1, 'transparent');
      ctx.fillStyle = fGrad;
      ctx.beginPath();
      ctx.ellipse(cx, baseY - 26 - fh / 2, 4, fh / 2, 0, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  function drawCandles(ts) {
    const ctx = s5.ctx, w = s5.w, h = s5.h;
    if (candlePrevTs === null) candlePrevTs = ts;
    const dt = Math.min(ts - candlePrevTs, 50);
    candlePrevTs = ts;

    const tripYears = 20;
    if (candleRunning && !candleDone) {
      candleTime += dt * 0.001 * candleSimSpeed * 0.5;
      if (candleTime >= tripYears) { candleTime = tripYears; candleDone = true; candleRunning = false;
        document.getElementById('sl-candle-play').textContent = 'Journey Complete!'; }
    }

    ctx.clearRect(0, 0, w, h);
    ctx.fillStyle = '#080c16';
    ctx.fillRect(0, 0, w, h);

    const g = gamma(Math.min(candleBeta, 0.999));
    const earthAge = candleTime;
    const travAge = candleTime / g;
    const earthCandles = Math.floor(earthAge);
    const travCandles = Math.floor(travAge);

    const colW = w / 2;

    // Two columns
    [{ label: 'Earth Twin', age: earthAge, candles: earthCandles, color: '#f59e0b', x: 0 },
     { label: 'Traveler Twin (' + candleBeta.toFixed(2) + 'c)', age: travAge, candles: travCandles, color: '#06b6d4', x: colW }
    ].forEach((twin) => {
      const cx = twin.x + colW / 2;

      // Column background
      ctx.fillStyle = 'rgba(255,255,255,0.02)';
      ctx.beginPath();
      ctx.roundRect(twin.x + 10, 10, colW - 20, h - 20, 12);
      ctx.fill();

      // Label
      ctx.fillStyle = twin.color;
      ctx.font = 'bold 16px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(twin.label, cx, 38);

      // Clock
      drawClockFace(ctx, cx, 95, 35, twin.age / 12);

      // Age display
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 20px system-ui';
      ctx.fillText((30 + twin.age).toFixed(1) + ' years old', cx, 160);

      // Birthday cake
      const cakeY = 280;
      const cakeW = Math.min(colW - 60, twin.candles * 14 + 40);
      const cakeX = cx - cakeW / 2;

      // Cake body
      ctx.fillStyle = '#7c3aed';
      ctx.beginPath();
      ctx.roundRect(cakeX, cakeY, cakeW, 40, 8);
      ctx.fill();
      // Frosting
      ctx.fillStyle = '#a78bfa';
      ctx.beginPath();
      ctx.roundRect(cakeX, cakeY, cakeW, 14, [8, 8, 0, 0]);
      ctx.fill();
      // Frosting drips
      for (let d = 0; d < cakeW / 15; d++) {
        const dx = cakeX + 10 + d * 15;
        const dh = 4 + Math.sin(d * 2.3) * 3;
        ctx.fillStyle = '#a78bfa';
        ctx.beginPath();
        ctx.ellipse(dx, cakeY + 14, 4, dh, 0, 0, Math.PI);
        ctx.fill();
      }

      // Candles on the cake
      const maxVisible = Math.min(twin.candles, 20);
      const candleSpacing = maxVisible > 0 ? Math.min(14, (cakeW - 20) / maxVisible) : 14;
      const candleStart = cx - (maxVisible * candleSpacing) / 2 + candleSpacing / 2;
      const flicker = Math.sin(ts * 0.005) * 0.5 + 0.5;
      for (let c = 0; c < maxVisible; c++) {
        drawCandle(ctx, candleStart + c * candleSpacing, cakeY, true, flicker + Math.sin(c * 1.7) * 0.3);
      }

      // Candle count
      ctx.fillStyle = twin.color;
      ctx.font = 'bold 18px system-ui';
      ctx.textAlign = 'center';
      if (twin.candles > 0) {
        ctx.fillText(twin.candles + (twin.candles === 1 ? ' candle' : ' candles'), cx, cakeY + 70);
      }
      if (twin.candles > 20) {
        ctx.fillStyle = '#94a3b8';
        ctx.font = '11px system-ui';
        ctx.fillText('(showing 20 of ' + twin.candles + ')', cx, cakeY + 86);
      }
    });

    // Comparison at bottom
    if (candleTime > 0.5) {
      const diff = earthCandles - travCandles;
      ctx.fillStyle = '#e2e8f0';
      ctx.font = 'bold 14px system-ui';
      ctx.textAlign = 'center';
      if (diff > 0) {
        ctx.fillText('The traveler has ' + diff + ' fewer birthday' + (diff === 1 ? '' : 's') + '!', w / 2, h - 50);
      }
      ctx.fillStyle = '#94a3b8';
      ctx.font = '12px system-ui';
      ctx.fillText('Same trip, same duration \u2014 but the traveler aged less because time ran slower.', w / 2, h - 30);
    } else if (!candleRunning && !candleDone) {
      ctx.fillStyle = '#94a3b8';
      ctx.font = '13px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Press "Start Journey" to send one twin on a ' + tripYears + '-year round trip', w / 2, h - 30);
    }
  }

  // =============================================================
  //  MAIN ANIMATION LOOP
  // =============================================================
  function mainDraw(ts) {
    if (activeTab === 'sl-speedometer') drawSpeedometer(ts);
    else if (activeTab === 'sl-astronaut') drawAstronaut_tab(ts);
    else if (activeTab === 'sl-photon') drawPhoton(ts);
    else if (activeTab === 'sl-wall') drawWall(ts);
    else if (activeTab === 'sl-candles') drawCandles(ts);
    requestAnimationFrame(mainDraw);
  }
  requestAnimationFrame(mainDraw);
})();

// ==================== DIFFICULTY LEVEL SYSTEM ====================
(function initDifficulty() {
  const urlLevel = new URLSearchParams(window.location.search).get('level');
  const saved = localStorage.getItem('ftl-difficulty');
  const level = ['beginner','intermediate','advanced'].includes(urlLevel) ? urlLevel
    : ['beginner','intermediate','advanced'].includes(saved) ? saved
    : 'intermediate';

  function setLevel(lv) {
    document.body.classList.remove('level-beginner', 'level-intermediate', 'level-advanced');
    document.body.classList.add('level-' + lv);
    localStorage.setItem('ftl-difficulty', lv);
    document.querySelectorAll('.dt-btn').forEach(function(b) {
      b.classList.toggle('active', b.getAttribute('data-level') === lv);
    });
  }

  // Main toggle buttons
  document.querySelectorAll('.dt-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      setLevel(btn.getAttribute('data-level'));
    });
  });

  // If URL param provided, hide the toggle (classroom mode)
  if (urlLevel && ['beginner','intermediate','advanced'].includes(urlLevel)) {
    var toggle = document.getElementById('difficulty-toggle');
    if (toggle) toggle.style.display = 'none';
  }

  // Per-section "Show Simple / Show Full" toggle buttons
  document.querySelectorAll('.ls-btn').forEach(function(btn) {
    btn.addEventListener('click', function() {
      var card = btn.closest('.card');
      if (!card) return;
      var show = btn.getAttribute('data-show');
      // Remove all level overrides on this card
      card.classList.remove('level-override-beg', 'level-override-int', 'level-override-adv');
      if (show === 'simple') {
        card.classList.add('level-override-beg');
      } else if (show === 'full') {
        card.classList.add('level-override-adv');
      }
      // Update active state
      card.querySelectorAll('.ls-btn').forEach(function(b) { b.classList.remove('active'); });
      btn.classList.add('active');
    });
  });

  setLevel(level);
})();

// ==================== ROUNDRECT POLYFILL ====================
if (!CanvasRenderingContext2D.prototype.roundRect) {
  CanvasRenderingContext2D.prototype.roundRect = function(x, y, w, h, radii) {
    const r = Array.isArray(radii) ? radii[0] : (radii || 0);
    this.moveTo(x + r, y);
    this.lineTo(x + w - r, y);
    this.quadraticCurveTo(x + w, y, x + w, y + r);
    this.lineTo(x + w, y + h - r);
    this.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
    this.lineTo(x + r, y + h);
    this.quadraticCurveTo(x, y + h, x, y + h - r);
    this.lineTo(x, y + r);
    this.quadraticCurveTo(x, y, x + r, y);
    this.closePath();
  };
}

// ==================== NETFLIX LANDING: PROGRESS, NAV, SCROLL ====================
(function initLandingPage() {
  'use strict';
  var STORAGE_KEY = 'ftl-visited-sections';
  var ALL_SECTIONS = [
    'sec-speedlimit', 'sec-twins', 'sec-contraction', 'sec-causality',
    'sec-curvature', 'sec-clocks', 'sec-spacetime', 'sec-lorentz',
    'sec-energy', 'sec-examples', 'sec-emc2', 'sec-compare'
  ];
  var TOTAL = ALL_SECTIONS.length;

  function getVisited() {
    try { var raw = localStorage.getItem(STORAGE_KEY); return raw ? JSON.parse(raw) : []; }
    catch (e) { return []; }
  }
  function markVisited(sectionId) {
    var visited = getVisited();
    if (visited.indexOf(sectionId) === -1) {
      visited.push(sectionId);
      localStorage.setItem(STORAGE_KEY, JSON.stringify(visited));
      updateAllProgressUI();
    }
  }
  function updateAllProgressUI() {
    var visited = getVisited();
    var count = visited.length;
    var pct = Math.round((count / TOTAL) * 100);
    var heroFill = document.getElementById('hero-progress-fill');
    var heroPct = document.getElementById('hero-progress-pct');
    if (heroFill) heroFill.style.width = pct + '%';
    if (heroPct) heroPct.textContent = count + ' / ' + TOTAL + ' modules';
    var navFill = document.getElementById('nav-progress-fill');
    var navText = document.getElementById('nav-progress-text');
    if (navFill) navFill.style.width = pct + '%';
    if (navText) navText.textContent = pct + '%';
    document.querySelectorAll('.module-card').forEach(function(card) {
      var target = card.getAttribute('data-section');
      var isV = visited.indexOf(target) !== -1;
      card.classList.toggle('visited', isV);
      var st = card.querySelector('.module-card-status-text');
      if (st) st.textContent = isV ? 'Visited' : 'Not visited';
    });
  }

  // Mark sections visited after 2s dwell at 30% visibility
  var sectionTimers = {};
  var sectionObserver = new IntersectionObserver(function(entries) {
    entries.forEach(function(entry) {
      var id = entry.target.id;
      if (entry.isIntersecting && entry.intersectionRatio >= 0.25) {
        if (!sectionTimers[id]) {
          sectionTimers[id] = setTimeout(function() {
            markVisited(id);
            delete sectionTimers[id];
          }, 2000);
        }
      } else {
        if (sectionTimers[id]) { clearTimeout(sectionTimers[id]); delete sectionTimers[id]; }
      }
    });
  }, { threshold: [0.25] });
  ALL_SECTIONS.forEach(function(id) {
    var el = document.getElementById(id);
    if (el) sectionObserver.observe(el);
  });

  // Nav highlighting: track current section
  var navHighlightObserver = new IntersectionObserver(function(entries) {
    entries.forEach(function(entry) {
      if (entry.isIntersecting) {
        document.querySelectorAll('.sticky-nav-item').forEach(function(btn) {
          btn.classList.toggle('active', btn.getAttribute('data-target') === entry.target.id);
        });
      }
    });
  }, { rootMargin: '-80px 0px -60% 0px', threshold: [0] });
  ALL_SECTIONS.forEach(function(id) {
    var el = document.getElementById(id);
    if (el) navHighlightObserver.observe(el);
  });

  // Sticky nav: show when module grid leaves viewport
  var stickyNav = document.getElementById('sticky-nav');
  var moduleGrid = document.getElementById('module-grid');
  if (stickyNav && moduleGrid) {
    var navShowObserver = new IntersectionObserver(function(entries) {
      entries.forEach(function(entry) {
        if (!entry.isIntersecting) stickyNav.classList.add('visible');
        else stickyNav.classList.remove('visible');
      });
    }, { threshold: [0] });
    navShowObserver.observe(moduleGrid);
  }

  // Module card click → smooth scroll
  document.querySelectorAll('.module-card').forEach(function(card) {
    card.addEventListener('click', function() {
      var el = document.getElementById(card.getAttribute('data-section'));
      if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
    card.setAttribute('tabindex', '0');
    card.setAttribute('role', 'button');
    card.addEventListener('keydown', function(e) {
      if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); card.click(); }
    });
  });

  // Sticky nav click → smooth scroll
  document.querySelectorAll('.sticky-nav-item').forEach(function(btn) {
    btn.addEventListener('click', function() {
      var el = document.getElementById(btn.getAttribute('data-target'));
      if (el) el.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
  });

  updateAllProgressUI();
})();
</script>

</body>
</html>
